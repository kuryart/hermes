// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/@libsql/hrana-client/lib-esm/encoding/p
var require_err_helpers = __commonJS((exports, module) => {
  var isErrorLike = (err) => {
    return err && typeof err.message === "string";
  };
  var getErrorCause = (err) => {
    if (!err)
      return;
    const cause = err.cause;
    if (typeof cause === "function") {
      const causeResult = err.cause();
      return isErrorLike(causeResult) ? causeResult : undefined;
    } else {
      return isErrorLike(cause) ? cause : undefined;
    }
  };
  var _stackWithCauses = (err, seen) => {
    if (!isErrorLike(err))
      return "";
    const stack = err.stack || "";
    if (seen.has(err)) {
      return stack + "\ncauses have become circular...";
    }
    const cause = getErrorCause(err);
    if (cause) {
      seen.add(err);
      return stack + "\ncaused by: " + _stackWithCauses(cause, seen);
    } else {
      return stack;
    }
  };
  var stackWithCauses = (err) => _stackWithCauses(err, new Set);
  var _messageWithCauses = (err, seen, skip) => {
    if (!isErrorLike(err))
      return "";
    const message = skip ? "" : err.message || "";
    if (seen.has(err)) {
      return message + ": ...";
    }
    const cause = getErrorCause(err);
    if (cause) {
      seen.add(err);
      const skipIfVErrorStyleCause = typeof err.cause === "function";
      return message + (skipIfVErrorStyleCause ? "" : ": ") + _messageWithCauses(cause, seen, skipIfVErrorStyleCause);
    } else {
      return message;
    }
  };
  var messageWithCauses = (err) => _messageWithCauses(err, new Set);
  module.exports = {
    isErrorLike,
    getErrorCause,
    stackWithCauses,
    messageWithCauses
  };
});

// node_modules/@libsql/hrana-client/lib-esm/encoding
var require_err_proto = __commonJS((exports, module) => {
  var seen = Symbol("circular-ref-tag");
  var rawSymbol = Symbol("pino-raw-err-ref");
  var pinoErrProto = Object.create({}, {
    type: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    message: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    stack: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    aggregateErrors: {
      enumerable: true,
      writable: true,
      value: undefined
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoErrProto, rawSymbol, {
    writable: true,
    value: {}
  });
  module.exports = {
    pinoErrProto,
    pinoErrorSymbols: {
      seen,
      rawSymbol
    }
  };
});

// node_modules/@libsql/hrana-client/lib-esm/en
var require_err = __commonJS((exports, module) => {
  var errSerializer = function(err) {
    if (!isErrorLike(err)) {
      return err;
    }
    err[seen] = undefined;
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
    _err.message = messageWithCauses(err);
    _err.stack = stackWithCauses(err);
    if (Array.isArray(err.errors)) {
      _err.aggregateErrors = err.errors.map((err2) => errSerializer(err2));
    }
    for (const key in err) {
      if (_err[key] === undefined) {
        const val = err[key];
        if (isErrorLike(val)) {
          if (key !== "cause" && !Object.prototype.hasOwnProperty.call(val, seen)) {
            _err[key] = errSerializer(val);
          }
        } else {
          _err[key] = val;
        }
      }
    }
    delete err[seen];
    _err.raw = err;
    return _err;
  };
  module.exports = errSerializer;
  var { messageWithCauses, stackWithCauses, isErrorLike } = require_err_helpers();
  var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
  var { seen } = pinoErrorSymbols;
  var { toString } = Object.prototype;
});

// node_modules/@libsql/hrana-client/lib-esm/encoding/prot
var require_err_with_cause = __commonJS((exports, module) => {
  var errWithCauseSerializer = function(err) {
    if (!isErrorLike(err)) {
      return err;
    }
    err[seen] = undefined;
    const _err = Object.create(pinoErrProto);
    _err.type = toString.call(err.constructor) === "[object Function]" ? err.constructor.name : err.name;
    _err.message = err.message;
    _err.stack = err.stack;
    if (Array.isArray(err.errors)) {
      _err.aggregateErrors = err.errors.map((err2) => errWithCauseSerializer(err2));
    }
    if (isErrorLike(err.cause) && !Object.prototype.hasOwnProperty.call(err.cause, seen)) {
      _err.cause = errWithCauseSerializer(err.cause);
    }
    for (const key in err) {
      if (_err[key] === undefined) {
        const val = err[key];
        if (isErrorLike(val)) {
          if (!Object.prototype.hasOwnProperty.call(val, seen)) {
            _err[key] = errWithCauseSerializer(val);
          }
        } else {
          _err[key] = val;
        }
      }
    }
    delete err[seen];
    _err.raw = err;
    return _err;
  };
  module.exports = errWithCauseSerializer;
  var { isErrorLike } = require_err_helpers();
  var { pinoErrProto, pinoErrorSymbols } = require_err_proto();
  var { seen } = pinoErrorSymbols;
  var { toString } = Object.prototype;
});

// node_modules/@libsql/hrana-client/lib-esm/en
var require_req = __commonJS((exports, module) => {
  var reqSerializer = function(req) {
    const connection = req.info || req.socket;
    const _req = Object.create(pinoReqProto);
    _req.id = typeof req.id === "function" ? req.id() : req.id || (req.info ? req.info.id : undefined);
    _req.method = req.method;
    if (req.originalUrl) {
      _req.url = req.originalUrl;
    } else {
      const path = req.path;
      _req.url = typeof path === "string" ? path : req.url ? req.url.path || req.url : undefined;
    }
    if (req.query) {
      _req.query = req.query;
    }
    if (req.params) {
      _req.params = req.params;
    }
    _req.headers = req.headers;
    _req.remoteAddress = connection && connection.remoteAddress;
    _req.remotePort = connection && connection.remotePort;
    _req.raw = req.raw || req;
    return _req;
  };
  var mapHttpRequest = function(req) {
    return {
      req: reqSerializer(req)
    };
  };
  module.exports = {
    mapHttpRequest,
    reqSerializer
  };
  var rawSymbol = Symbol("pino-raw-req-ref");
  var pinoReqProto = Object.create({}, {
    id: {
      enumerable: true,
      writable: true,
      value: ""
    },
    method: {
      enumerable: true,
      writable: true,
      value: ""
    },
    url: {
      enumerable: true,
      writable: true,
      value: ""
    },
    query: {
      enumerable: true,
      writable: true,
      value: ""
    },
    params: {
      enumerable: true,
      writable: true,
      value: ""
    },
    headers: {
      enumerable: true,
      writable: true,
      value: {}
    },
    remoteAddress: {
      enumerable: true,
      writable: true,
      value: ""
    },
    remotePort: {
      enumerable: true,
      writable: true,
      value: ""
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoReqProto, rawSymbol, {
    writable: true,
    value: {}
  });
});

// node_modules/@libsql/hrana-client/lib-esm/en
var require_res = __commonJS((exports, module) => {
  var resSerializer = function(res) {
    const _res = Object.create(pinoResProto);
    _res.statusCode = res.headersSent ? res.statusCode : null;
    _res.headers = res.getHeaders ? res.getHeaders() : res._headers;
    _res.raw = res;
    return _res;
  };
  var mapHttpResponse = function(res) {
    return {
      res: resSerializer(res)
    };
  };
  module.exports = {
    mapHttpResponse,
    resSerializer
  };
  var rawSymbol = Symbol("pino-raw-res-ref");
  var pinoResProto = Object.create({}, {
    statusCode: {
      enumerable: true,
      writable: true,
      value: 0
    },
    headers: {
      enumerable: true,
      writable: true,
      value: ""
    },
    raw: {
      enumerable: false,
      get: function() {
        return this[rawSymbol];
      },
      set: function(val) {
        this[rawSymbol] = val;
      }
    }
  });
  Object.defineProperty(pinoResProto, rawSymbol, {
    writable: true,
    value: {}
  });
});

// node_modules/@libsql/hrana-client/lib-esm/
var require_pino_std_serializers = __commonJS((exports, module) => {
  var errSerializer = require_err();
  var errWithCauseSerializer = require_err_with_cause();
  var reqSerializers = require_req();
  var resSerializers = require_res();
  module.exports = {
    err: errSerializer,
    errWithCause: errWithCauseSerializer,
    mapHttpRequest: reqSerializers.mapHttpRequest,
    mapHttpResponse: resSerializers.mapHttpResponse,
    req: reqSerializers.reqSerializer,
    res: resSerializers.resSerializer,
    wrapErrorSerializer: function wrapErrorSerializer(customSerializer) {
      if (customSerializer === errSerializer)
        return customSerializer;
      return function wrapErrSerializer(err) {
        return customSerializer(errSerializer(err));
      };
    },
    wrapRequestSerializer: function wrapRequestSerializer(customSerializer) {
      if (customSerializer === reqSerializers.reqSerializer)
        return customSerializer;
      return function wrappedReqSerializer(req) {
        return customSerializer(reqSerializers.reqSerializer(req));
      };
    },
    wrapResponseSerializer: function wrapResponseSerializer(customSerializer) {
      if (customSerializer === resSerializers.resSerializer)
        return customSerializer;
      return function wrappedResSerializer(res) {
        return customSerializer(resSerializers.resSerializer(res));
      };
    }
  };
});

// node_modules/@libsql/hrana-clie
var require_caller = __commonJS((exports, module) => {
  var noOpPrepareStackTrace = function(_, stack) {
    return stack;
  };
  module.exports = function getCallers() {
    const originalPrepare = Error.prepareStackTrace;
    Error.prepareStackTrace = noOpPrepareStackTrace;
    const stack = new Error().stack;
    Error.prepareStackTrace = originalPrepare;
    if (!Array.isArray(stack)) {
      return;
    }
    const entries = stack.slice(2);
    const fileNames = [];
    for (const entry of entries) {
      if (!entry) {
        continue;
      }
      fileNames.push(entry.getFileName());
    }
    return fileNames;
  };
});

// node_modules/@libsql/hrana-client/lib-esm
var require_validator = __commonJS((exports, module) => {
  var validator = function(opts = {}) {
    const {
      ERR_PATHS_MUST_BE_STRINGS = () => "fast-redact - Paths must be (non-empty) strings",
      ERR_INVALID_PATH = (s) => `fast-redact \u2013 Invalid path (${s})`
    } = opts;
    return function validate({ paths }) {
      paths.forEach((s) => {
        if (typeof s !== "string") {
          throw Error(ERR_PATHS_MUST_BE_STRINGS());
        }
        try {
          if (/\u3007/.test(s))
            throw Error();
          const expr = (s[0] === "[" ? "" : ".") + s.replace(/^\*/, "\u3007").replace(/\.\*/g, ".\u3007").replace(/\[\*\]/g, "[\u3007]");
          if (/\n|\r|;/.test(expr))
            throw Error();
          if (/\/\*/.test(expr))
            throw Error();
          Function(`
            'use strict'
            const o = new Proxy({}, { get: () => o, set: () => { throw Error() } });
            const \u3007 = null;
            o${expr}
            if ([o${expr}].length !== 1) throw Error()`)();
        } catch (e) {
          throw Error(ERR_INVALID_PATH(s));
        }
      });
    };
  };
  module.exports = validator;
});

// node_modules/@libsql/hrana-client/
var require_rx = __commonJS((exports, module) => {
  module.exports = /[^.[\]]+|\[((?:.)*?)\]/g;
});

// node_modules/@libsql/hrana-client/lib
var require_parse = __commonJS((exports, module) => {
  var parse = function({ paths }) {
    const wildcards = [];
    var wcLen = 0;
    const secret = paths.reduce(function(o, strPath, ix) {
      var path = strPath.match(rx).map((p) => p.replace(/'|"|`/g, ""));
      const leadingBracket = strPath[0] === "[";
      path = path.map((p) => {
        if (p[0] === "[")
          return p.substr(1, p.length - 2);
        else
          return p;
      });
      const star = path.indexOf("*");
      if (star > -1) {
        const before = path.slice(0, star);
        const beforeStr = before.join(".");
        const after = path.slice(star + 1, path.length);
        const nested = after.length > 0;
        wcLen++;
        wildcards.push({
          before,
          beforeStr,
          after,
          nested
        });
      } else {
        o[strPath] = {
          path,
          val: undefined,
          precensored: false,
          circle: "",
          escPath: JSON.stringify(strPath),
          leadingBracket
        };
      }
      return o;
    }, {});
    return { wildcards, wcLen, secret };
  };
  var rx = require_rx();
  module.exports = parse;
});

// node_modules/@libsql/hrana-client/lib-es
var require_redactor = __commonJS((exports, module) => {
  var redactor = function({ secret, serialize, wcLen, strict, isCensorFct, censorFctTakesPath }, state) {
    const redact = Function("o", `
    if (typeof o !== 'object' || o == null) {
      ${strictImpl(strict, serialize)}
    }
    const { censor, secret } = this
    ${redactTmpl(secret, isCensorFct, censorFctTakesPath)}
    this.compileRestore()
    ${dynamicRedactTmpl(wcLen > 0, isCensorFct, censorFctTakesPath)}
    ${resultTmpl(serialize)}
  `).bind(state);
    if (serialize === false) {
      redact.restore = (o) => state.restore(o);
    }
    return redact;
  };
  var redactTmpl = function(secret, isCensorFct, censorFctTakesPath) {
    return Object.keys(secret).map((path) => {
      const { escPath, leadingBracket, path: arrPath } = secret[path];
      const skip = leadingBracket ? 1 : 0;
      const delim = leadingBracket ? "" : ".";
      const hops = [];
      var match;
      while ((match = rx.exec(path)) !== null) {
        const [, ix] = match;
        const { index, input } = match;
        if (index > skip)
          hops.push(input.substring(0, index - (ix ? 0 : 1)));
      }
      var existence = hops.map((p) => `o${delim}${p}`).join(" && ");
      if (existence.length === 0)
        existence += `o${delim}${path} != null`;
      else
        existence += ` && o${delim}${path} != null`;
      const circularDetection = `
      switch (true) {
        ${hops.reverse().map((p) => `
          case o${delim}${p} === censor:
            secret[${escPath}].circle = ${JSON.stringify(p)}
            break
        `).join("\n")}
      }
    `;
      const censorArgs = censorFctTakesPath ? `val, ${JSON.stringify(arrPath)}` : `val`;
      return `
      if (${existence}) {
        const val = o${delim}${path}
        if (val === censor) {
          secret[${escPath}].precensored = true
        } else {
          secret[${escPath}].val = val
          o${delim}${path} = ${isCensorFct ? `censor(${censorArgs})` : "censor"}
          ${circularDetection}
        }
      }
    `;
    }).join("\n");
  };
  var dynamicRedactTmpl = function(hasWildcards, isCensorFct, censorFctTakesPath) {
    return hasWildcards === true ? `
    {
      const { wildcards, wcLen, groupRedact, nestedRedact } = this
      for (var i = 0; i < wcLen; i++) {
        const { before, beforeStr, after, nested } = wildcards[i]
        if (nested === true) {
          secret[beforeStr] = secret[beforeStr] || []
          nestedRedact(secret[beforeStr], o, before, after, censor, ${isCensorFct}, ${censorFctTakesPath})
        } else secret[beforeStr] = groupRedact(o, before, censor, ${isCensorFct}, ${censorFctTakesPath})
      }
    }
  ` : "";
  };
  var resultTmpl = function(serialize) {
    return serialize === false ? `return o` : `
    var s = this.serialize(o)
    this.restore(o)
    return s
  `;
  };
  var strictImpl = function(strict, serialize) {
    return strict === true ? `throw Error('fast-redact: primitives cannot be redacted')` : serialize === false ? `return o` : `return this.serialize(o)`;
  };
  var rx = require_rx();
  module.exports = redactor;
});

// node_modules/@libsql/hrana-client/lib-esm
var require_modifiers = __commonJS((exports, module) => {
  var groupRestore = function({ keys, values, target }) {
    if (target == null)
      return;
    const length = keys.length;
    for (var i = 0;i < length; i++) {
      const k = keys[i];
      target[k] = values[i];
    }
  };
  var groupRedact = function(o, path, censor, isCensorFct, censorFctTakesPath) {
    const target = get(o, path);
    if (target == null)
      return { keys: null, values: null, target: null, flat: true };
    const keys = Object.keys(target);
    const keysLength = keys.length;
    const pathLength = path.length;
    const pathWithKey = censorFctTakesPath ? [...path] : undefined;
    const values = new Array(keysLength);
    for (var i = 0;i < keysLength; i++) {
      const key = keys[i];
      values[i] = target[key];
      if (censorFctTakesPath) {
        pathWithKey[pathLength] = key;
        target[key] = censor(target[key], pathWithKey);
      } else if (isCensorFct) {
        target[key] = censor(target[key]);
      } else {
        target[key] = censor;
      }
    }
    return { keys, values, target, flat: true };
  };
  var nestedRestore = function(instructions) {
    for (let i = 0;i < instructions.length; i++) {
      const { target, path, value } = instructions[i];
      let current = target;
      for (let i2 = path.length - 1;i2 > 0; i2--) {
        current = current[path[i2]];
      }
      current[path[0]] = value;
    }
  };
  var nestedRedact = function(store, o, path, ns, censor, isCensorFct, censorFctTakesPath) {
    const target = get(o, path);
    if (target == null)
      return;
    const keys = Object.keys(target);
    const keysLength = keys.length;
    for (var i = 0;i < keysLength; i++) {
      const key = keys[i];
      specialSet(store, target, key, path, ns, censor, isCensorFct, censorFctTakesPath);
    }
    return store;
  };
  var has = function(obj, prop) {
    return obj !== undefined && obj !== null ? "hasOwn" in Object ? Object.hasOwn(obj, prop) : Object.prototype.hasOwnProperty.call(obj, prop) : false;
  };
  var specialSet = function(store, o, k, path, afterPath, censor, isCensorFct, censorFctTakesPath) {
    const afterPathLen = afterPath.length;
    const lastPathIndex = afterPathLen - 1;
    const originalKey = k;
    var i = -1;
    var n;
    var nv;
    var ov;
    var oov = null;
    var wc = null;
    var kIsWc;
    var wcov;
    var consecutive = false;
    var level = 0;
    var depth = 0;
    var redactPathCurrent = tree();
    ov = n = o[k];
    if (typeof n !== "object")
      return;
    while (n != null && ++i < afterPathLen) {
      depth += 1;
      k = afterPath[i];
      oov = ov;
      if (k !== "*" && !wc && !(typeof n === "object" && (k in n))) {
        break;
      }
      if (k === "*") {
        if (wc === "*") {
          consecutive = true;
        }
        wc = k;
        if (i !== lastPathIndex) {
          continue;
        }
      }
      if (wc) {
        const wcKeys = Object.keys(n);
        for (var j = 0;j < wcKeys.length; j++) {
          const wck = wcKeys[j];
          wcov = n[wck];
          kIsWc = k === "*";
          if (consecutive) {
            redactPathCurrent = node(redactPathCurrent, wck, depth);
            level = i;
            ov = iterateNthLevel(wcov, level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, o[originalKey], depth + 1);
          } else {
            if (kIsWc || typeof wcov === "object" && wcov !== null && (k in wcov)) {
              if (kIsWc) {
                ov = wcov;
              } else {
                ov = wcov[k];
              }
              nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
              if (kIsWc) {
                const rv = restoreInstr(node(redactPathCurrent, wck, depth), ov, o[originalKey]);
                store.push(rv);
                n[wck] = nv;
              } else {
                if (wcov[k] === nv) {
                } else if (nv === undefined && censor !== undefined || has(wcov, k) && nv === ov) {
                  redactPathCurrent = node(redactPathCurrent, wck, depth);
                } else {
                  redactPathCurrent = node(redactPathCurrent, wck, depth);
                  const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, o[originalKey]);
                  store.push(rv);
                  wcov[k] = nv;
                }
              }
            }
          }
        }
        wc = null;
      } else {
        ov = n[k];
        redactPathCurrent = node(redactPathCurrent, k, depth);
        nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
        if (has(n, k) && nv === ov || nv === undefined && censor !== undefined) {
        } else {
          const rv = restoreInstr(redactPathCurrent, ov, o[originalKey]);
          store.push(rv);
          n[k] = nv;
        }
        n = n[k];
      }
      if (typeof n !== "object")
        break;
      if (ov === oov || typeof ov === "undefined") {
      }
    }
  };
  var get = function(o, p) {
    var i = -1;
    var l = p.length;
    var n = o;
    while (n != null && ++i < l) {
      n = n[p[i]];
    }
    return n;
  };
  var iterateNthLevel = function(wcov, level, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth) {
    if (level === 0) {
      if (kIsWc || typeof wcov === "object" && wcov !== null && (k in wcov)) {
        if (kIsWc) {
          ov = wcov;
        } else {
          ov = wcov[k];
        }
        nv = i !== lastPathIndex ? ov : isCensorFct ? censorFctTakesPath ? censor(ov, [...path, originalKey, ...afterPath]) : censor(ov) : censor;
        if (kIsWc) {
          const rv = restoreInstr(redactPathCurrent, ov, parent);
          store.push(rv);
          n[wck] = nv;
        } else {
          if (wcov[k] === nv) {
          } else if (nv === undefined && censor !== undefined || has(wcov, k) && nv === ov) {
          } else {
            const rv = restoreInstr(node(redactPathCurrent, k, depth + 1), ov, parent);
            store.push(rv);
            wcov[k] = nv;
          }
        }
      }
    }
    for (const key in wcov) {
      if (typeof wcov[key] === "object") {
        redactPathCurrent = node(redactPathCurrent, key, depth);
        iterateNthLevel(wcov[key], level - 1, k, path, afterPath, censor, isCensorFct, censorFctTakesPath, originalKey, n, nv, ov, kIsWc, wck, i, lastPathIndex, redactPathCurrent, store, parent, depth + 1);
      }
    }
  };
  var tree = function() {
    return { parent: null, key: null, children: [], depth: 0 };
  };
  var node = function(parent, key, depth) {
    if (parent.depth === depth) {
      return node(parent.parent, key, depth);
    }
    var child = {
      parent,
      key,
      depth,
      children: []
    };
    parent.children.push(child);
    return child;
  };
  var restoreInstr = function(node2, value, target) {
    let current = node2;
    const path = [];
    do {
      path.push(current.key);
      current = current.parent;
    } while (current.parent != null);
    return { path, value, target };
  };
  module.exports = {
    groupRedact,
    groupRestore,
    nestedRedact,
    nestedRestore
  };
});

// node_modules/@libsql/hrana-client/lib-es
var require_restorer = __commonJS((exports, module) => {
  var restorer = function({ secret, wcLen }) {
    return function compileRestore() {
      if (this.restore)
        return;
      const paths = Object.keys(secret);
      const resetters = resetTmpl(secret, paths);
      const hasWildcards = wcLen > 0;
      const state = hasWildcards ? { secret, groupRestore, nestedRestore } : { secret };
      this.restore = Function("o", restoreTmpl(resetters, paths, hasWildcards)).bind(state);
    };
  };
  var resetTmpl = function(secret, paths) {
    return paths.map((path) => {
      const { circle, escPath, leadingBracket } = secret[path];
      const delim = leadingBracket ? "" : ".";
      const reset = circle ? `o.${circle} = secret[${escPath}].val` : `o${delim}${path} = secret[${escPath}].val`;
      const clear = `secret[${escPath}].val = undefined`;
      return `
      if (secret[${escPath}].val !== undefined) {
        try { ${reset} } catch (e) {}
        ${clear}
      }
    `;
    }).join("");
  };
  var restoreTmpl = function(resetters, paths, hasWildcards) {
    const dynamicReset = hasWildcards === true ? `
    const keys = Object.keys(secret)
    const len = keys.length
    for (var i = len - 1; i >= ${paths.length}; i--) {
      const k = keys[i]
      const o = secret[k]
      if (o.flat === true) this.groupRestore(o)
      else this.nestedRestore(o)
      secret[k] = null
    }
  ` : "";
    return `
    const secret = this.secret
    ${dynamicReset}
    ${resetters}
    return o
  `;
  };
  var { groupRestore, nestedRestore } = require_modifiers();
  module.exports = restorer;
});

// node_modules/@libsql/hrana-client/lib
var require_state = __commonJS((exports, module) => {
  var state = function(o) {
    const {
      secret,
      censor,
      compileRestore,
      serialize,
      groupRedact,
      nestedRedact,
      wildcards,
      wcLen
    } = o;
    const builder = [{ secret, censor, compileRestore }];
    if (serialize !== false)
      builder.push({ serialize });
    if (wcLen > 0)
      builder.push({ groupRedact, nestedRedact, wildcards, wcLen });
    return Object.assign(...builder);
  };
  module.exports = state;
});

// node_modules/@libsql/hrana-client
var require_fast_redact = __commonJS((exports, module) => {
  var fastRedact = function(opts = {}) {
    const paths = Array.from(new Set(opts.paths || []));
    const serialize = "serialize" in opts ? opts.serialize === false ? opts.serialize : typeof opts.serialize === "function" ? opts.serialize : JSON.stringify : JSON.stringify;
    const remove = opts.remove;
    if (remove === true && serialize !== JSON.stringify) {
      throw Error("fast-redact \u2013 remove option may only be set when serializer is JSON.stringify");
    }
    const censor = remove === true ? undefined : ("censor" in opts) ? opts.censor : DEFAULT_CENSOR;
    const isCensorFct = typeof censor === "function";
    const censorFctTakesPath = isCensorFct && censor.length > 1;
    if (paths.length === 0)
      return serialize || noop;
    validate({ paths, serialize, censor });
    const { wildcards, wcLen, secret } = parse({ paths, censor });
    const compileRestore = restorer({ secret, wcLen });
    const strict = "strict" in opts ? opts.strict : true;
    return redactor({ secret, wcLen, serialize, strict, isCensorFct, censorFctTakesPath }, state({
      secret,
      censor,
      compileRestore,
      serialize,
      groupRedact,
      nestedRedact,
      wildcards,
      wcLen
    }));
  };
  var validator = require_validator();
  var parse = require_parse();
  var redactor = require_redactor();
  var restorer = require_restorer();
  var { groupRedact, nestedRedact } = require_modifiers();
  var state = require_state();
  var rx = require_rx();
  var validate = validator();
  var noop = (o) => o;
  noop.restore = noop;
  var DEFAULT_CENSOR = "[REDACTED]";
  fastRedact.rx = rx;
  fastRedact.validator = validator;
  module.exports = fastRedact;
});

// node_modules/@libsql/hrana-clien
var require_symbols = __commonJS((exports, module) => {
  var setLevelSym = Symbol("pino.setLevel");
  var getLevelSym = Symbol("pino.getLevel");
  var levelValSym = Symbol("pino.levelVal");
  var useLevelLabelsSym = Symbol("pino.useLevelLabels");
  var useOnlyCustomLevelsSym = Symbol("pino.useOnlyCustomLevels");
  var mixinSym = Symbol("pino.mixin");
  var lsCacheSym = Symbol("pino.lsCache");
  var chindingsSym = Symbol("pino.chindings");
  var asJsonSym = Symbol("pino.asJson");
  var writeSym = Symbol("pino.write");
  var redactFmtSym = Symbol("pino.redactFmt");
  var timeSym = Symbol("pino.time");
  var timeSliceIndexSym = Symbol("pino.timeSliceIndex");
  var streamSym = Symbol("pino.stream");
  var stringifySym = Symbol("pino.stringify");
  var stringifySafeSym = Symbol("pino.stringifySafe");
  var stringifiersSym = Symbol("pino.stringifiers");
  var endSym = Symbol("pino.end");
  var formatOptsSym = Symbol("pino.formatOpts");
  var messageKeySym = Symbol("pino.messageKey");
  var errorKeySym = Symbol("pino.errorKey");
  var nestedKeySym = Symbol("pino.nestedKey");
  var nestedKeyStrSym = Symbol("pino.nestedKeyStr");
  var mixinMergeStrategySym = Symbol("pino.mixinMergeStrategy");
  var msgPrefixSym = Symbol("pino.msgPrefix");
  var wildcardFirstSym = Symbol("pino.wildcardFirst");
  var serializersSym = Symbol.for("pino.serializers");
  var formattersSym = Symbol.for("pino.formatters");
  var hooksSym = Symbol.for("pino.hooks");
  var needsMetadataGsym = Symbol.for("pino.metadata");
  module.exports = {
    setLevelSym,
    getLevelSym,
    levelValSym,
    useLevelLabelsSym,
    mixinSym,
    lsCacheSym,
    chindingsSym,
    asJsonSym,
    writeSym,
    serializersSym,
    redactFmtSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    wildcardFirstSym,
    needsMetadataGsym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
  };
});

// node_modules/@libsql/hrana-client/
var require_redaction = __commonJS((exports, module) => {
  var redaction = function(opts, serialize) {
    const { paths, censor } = handle(opts);
    const shape = paths.reduce((o, str) => {
      rx.lastIndex = 0;
      const first = rx.exec(str);
      const next = rx.exec(str);
      let ns = first[1] !== undefined ? first[1].replace(/^(?:"|'|`)(.*)(?:"|'|`)$/, "$1") : first[0];
      if (ns === "*") {
        ns = wildcardFirstSym;
      }
      if (next === null) {
        o[ns] = null;
        return o;
      }
      if (o[ns] === null) {
        return o;
      }
      const { index } = next;
      const nextPath = `${str.substr(index, str.length - 1)}`;
      o[ns] = o[ns] || [];
      if (ns !== wildcardFirstSym && o[ns].length === 0) {
        o[ns].push(...o[wildcardFirstSym] || []);
      }
      if (ns === wildcardFirstSym) {
        Object.keys(o).forEach(function(k) {
          if (o[k]) {
            o[k].push(nextPath);
          }
        });
      }
      o[ns].push(nextPath);
      return o;
    }, {});
    const result = {
      [redactFmtSym]: fastRedact({ paths, censor, serialize, strict })
    };
    const topCensor = (...args2) => {
      return typeof censor === "function" ? serialize(censor(...args2)) : serialize(censor);
    };
    return [...Object.keys(shape), ...Object.getOwnPropertySymbols(shape)].reduce((o, k) => {
      if (shape[k] === null) {
        o[k] = (value) => topCensor(value, [k]);
      } else {
        const wrappedCensor = typeof censor === "function" ? (value, path) => {
          return censor(value, [k, ...path]);
        } : censor;
        o[k] = fastRedact({
          paths: shape[k],
          censor: wrappedCensor,
          serialize,
          strict
        });
      }
      return o;
    }, result);
  };
  var handle = function(opts) {
    if (Array.isArray(opts)) {
      opts = { paths: opts, censor: CENSOR };
      validate(opts);
      return opts;
    }
    let { paths, censor = CENSOR, remove } = opts;
    if (Array.isArray(paths) === false) {
      throw Error("pino \u2013 redact must contain an array of strings");
    }
    if (remove === true)
      censor = undefined;
    validate({ paths, censor });
    return { paths, censor };
  };
  var fastRedact = require_fast_redact();
  var { redactFmtSym, wildcardFirstSym } = require_symbols();
  var { rx, validator } = fastRedact;
  var validate = validator({
    ERR_PATHS_MUST_BE_STRINGS: () => "pino \u2013 redacted paths must be strings",
    ERR_INVALID_PATH: (s) => `pino \u2013 redact paths array contains an invalid path (${s})`
  });
  var CENSOR = "[Redacted]";
  var strict = false;
  module.exports = redaction;
});

// node_modules/@libsql/hrana-cl
var require_time = __commonJS((exports, module) => {
  var nullTime = () => "";
  var epochTime = () => `,"time":${Date.now()}`;
  var unixTime = () => `,"time":${Math.round(Date.now() / 1000)}`;
  var isoTime = () => `,"time":"${new Date(Date.now()).toISOString()}"`;
  module.exports = { nullTime, epochTime, unixTime, isoTime };
});

// node_modules/@libsql/hrana-client/lib-esm/en
var require_quick_format_unescaped = __commonJS((exports, module) => {
  var tryStringify = function(o) {
    try {
      return JSON.stringify(o);
    } catch (e) {
      return '"[Circular]"';
    }
  };
  var format2 = function(f, args2, opts) {
    var ss = opts && opts.stringify || tryStringify;
    var offset = 1;
    if (typeof f === "object" && f !== null) {
      var len = args2.length + offset;
      if (len === 1)
        return f;
      var objects = new Array(len);
      objects[0] = ss(f);
      for (var index = 1;index < len; index++) {
        objects[index] = ss(args2[index]);
      }
      return objects.join(" ");
    }
    if (typeof f !== "string") {
      return f;
    }
    var argLen = args2.length;
    if (argLen === 0)
      return f;
    var str = "";
    var a = 1 - offset;
    var lastPos = -1;
    var flen = f && f.length || 0;
    for (var i = 0;i < flen; ) {
      if (f.charCodeAt(i) === 37 && i + 1 < flen) {
        lastPos = lastPos > -1 ? lastPos : 0;
        switch (f.charCodeAt(i + 1)) {
          case 100:
          case 102:
            if (a >= argLen)
              break;
            if (args2[a] == null)
              break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += Number(args2[a]);
            lastPos = i + 2;
            i++;
            break;
          case 105:
            if (a >= argLen)
              break;
            if (args2[a] == null)
              break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += Math.floor(Number(args2[a]));
            lastPos = i + 2;
            i++;
            break;
          case 79:
          case 111:
          case 106:
            if (a >= argLen)
              break;
            if (args2[a] === undefined)
              break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            var type = typeof args2[a];
            if (type === "string") {
              str += "\'" + args2[a] + "\'";
              lastPos = i + 2;
              i++;
              break;
            }
            if (type === "function") {
              str += args2[a].name || "<anonymous>";
              lastPos = i + 2;
              i++;
              break;
            }
            str += ss(args2[a]);
            lastPos = i + 2;
            i++;
            break;
          case 115:
            if (a >= argLen)
              break;
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += String(args2[a]);
            lastPos = i + 2;
            i++;
            break;
          case 37:
            if (lastPos < i)
              str += f.slice(lastPos, i);
            str += "%";
            lastPos = i + 2;
            i++;
            a--;
            break;
        }
        ++a;
      }
      ++i;
    }
    if (lastPos === -1)
      return f;
    else if (lastPos < flen) {
      str += f.slice(lastPos);
    }
    return str;
  };
  module.exports = format2;
});

// node_modules/@libsql/hrana-client/
var require_atomic_sleep = __commonJS((exports, module) => {
  if (typeof SharedArrayBuffer !== "undefined" && typeof Atomics !== "undefined") {
    let sleep = function(ms) {
      const valid = ms > 0 && ms < Infinity;
      if (valid === false) {
        if (typeof ms !== "number" && typeof ms !== "bigint") {
          throw TypeError("sleep: ms must be a number");
        }
        throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      }
      Atomics.wait(nil, 0, 0, Number(ms));
    };
    const nil = new Int32Array(new SharedArrayBuffer(4));
    module.exports = sleep;
  } else {
    let sleep = function(ms) {
      const valid = ms > 0 && ms < Infinity;
      if (valid === false) {
        if (typeof ms !== "number" && typeof ms !== "bigint") {
          throw TypeError("sleep: ms must be a number");
        }
        throw RangeError("sleep: ms must be a number that is greater than 0 but less than Infinity");
      }
      const target = Date.now() + Number(ms);
      while (target > Date.now()) {
      }
    };
    module.exports = sleep;
  }
});

// node_modules/@libsql/hrana-clien
var require_sonic_boom = __commonJS((exports, module) => {
  var openFile = function(file, sonic) {
    sonic._opening = true;
    sonic._writing = true;
    sonic._asyncDrainScheduled = false;
    function fileOpened(err, fd) {
      if (err) {
        sonic._reopening = false;
        sonic._writing = false;
        sonic._opening = false;
        if (sonic.sync) {
          process.nextTick(() => {
            if (sonic.listenerCount("error") > 0) {
              sonic.emit("error", err);
            }
          });
        } else {
          sonic.emit("error", err);
        }
        return;
      }
      sonic.fd = fd;
      sonic.file = file;
      sonic._reopening = false;
      sonic._opening = false;
      sonic._writing = false;
      if (sonic.sync) {
        process.nextTick(() => sonic.emit("ready"));
      } else {
        sonic.emit("ready");
      }
      if (sonic._reopening) {
        return;
      }
      if (!sonic._writing && sonic._len > sonic.minLength && !sonic.destroyed) {
        actualWrite(sonic);
      }
    }
    const flags = sonic.append ? "a" : "w";
    const mode = sonic.mode;
    if (sonic.sync) {
      try {
        if (sonic.mkdir)
          fs.mkdirSync(path.dirname(file), { recursive: true });
        const fd = fs.openSync(file, flags, mode);
        fileOpened(null, fd);
      } catch (err) {
        fileOpened(err);
        throw err;
      }
    } else if (sonic.mkdir) {
      fs.mkdir(path.dirname(file), { recursive: true }, (err) => {
        if (err)
          return fileOpened(err);
        fs.open(file, flags, mode, fileOpened);
      });
    } else {
      fs.open(file, flags, mode, fileOpened);
    }
  };
  var SonicBoom = function(opts) {
    if (!(this instanceof SonicBoom)) {
      return new SonicBoom(opts);
    }
    let { fd, dest, minLength, maxLength, maxWrite, sync, append = true, mode, mkdir, retryEAGAIN, fsync } = opts || {};
    fd = fd || dest;
    this._bufs = [];
    this._len = 0;
    this.fd = -1;
    this._writing = false;
    this._writingBuf = "";
    this._ending = false;
    this._reopening = false;
    this._asyncDrainScheduled = false;
    this._hwm = Math.max(minLength || 0, 16387);
    this.file = null;
    this.destroyed = false;
    this.minLength = minLength || 0;
    this.maxLength = maxLength || 0;
    this.maxWrite = maxWrite || MAX_WRITE;
    this.sync = sync || false;
    this._fsync = fsync || false;
    this.append = append || false;
    this.mode = mode;
    this.retryEAGAIN = retryEAGAIN || (() => true);
    this.mkdir = mkdir || false;
    if (typeof fd === "number") {
      this.fd = fd;
      process.nextTick(() => this.emit("ready"));
    } else if (typeof fd === "string") {
      openFile(fd, this);
    } else {
      throw new Error("SonicBoom supports only file descriptors and files");
    }
    if (this.minLength >= this.maxWrite) {
      throw new Error(`minLength should be smaller than maxWrite (${this.maxWrite})`);
    }
    this.release = (err, n) => {
      if (err) {
        if ((err.code === "EAGAIN" || err.code === "EBUSY") && this.retryEAGAIN(err, this._writingBuf.length, this._len - this._writingBuf.length)) {
          if (this.sync) {
            try {
              sleep(BUSY_WRITE_TIMEOUT);
              this.release(undefined, 0);
            } catch (err2) {
              this.release(err2);
            }
          } else {
            setTimeout(() => {
              fs.write(this.fd, this._writingBuf, "utf8", this.release);
            }, BUSY_WRITE_TIMEOUT);
          }
        } else {
          this._writing = false;
          this.emit("error", err);
        }
        return;
      }
      this.emit("write", n);
      this._len -= n;
      if (this._len < 0) {
        this._len = 0;
      }
      this._writingBuf = this._writingBuf.slice(n);
      if (this._writingBuf.length) {
        if (!this.sync) {
          fs.write(this.fd, this._writingBuf, "utf8", this.release);
          return;
        }
        try {
          do {
            const n2 = fs.writeSync(this.fd, this._writingBuf, "utf8");
            this._len -= n2;
            this._writingBuf = this._writingBuf.slice(n2);
          } while (this._writingBuf);
        } catch (err2) {
          this.release(err2);
          return;
        }
      }
      if (this._fsync) {
        fs.fsyncSync(this.fd);
      }
      const len = this._len;
      if (this._reopening) {
        this._writing = false;
        this._reopening = false;
        this.reopen();
      } else if (len > this.minLength) {
        actualWrite(this);
      } else if (this._ending) {
        if (len > 0) {
          actualWrite(this);
        } else {
          this._writing = false;
          actualClose(this);
        }
      } else {
        this._writing = false;
        if (this.sync) {
          if (!this._asyncDrainScheduled) {
            this._asyncDrainScheduled = true;
            process.nextTick(emitDrain, this);
          }
        } else {
          this.emit("drain");
        }
      }
    };
    this.on("newListener", function(name) {
      if (name === "drain") {
        this._asyncDrainScheduled = false;
      }
    });
  };
  var emitDrain = function(sonic) {
    const hasListeners = sonic.listenerCount("drain") > 0;
    if (!hasListeners)
      return;
    sonic._asyncDrainScheduled = false;
    sonic.emit("drain");
  };
  var actualWrite = function(sonic) {
    const release = sonic.release;
    sonic._writing = true;
    sonic._writingBuf = sonic._writingBuf || sonic._bufs.shift() || "";
    if (sonic.sync) {
      try {
        const written = fs.writeSync(sonic.fd, sonic._writingBuf, "utf8");
        release(null, written);
      } catch (err) {
        release(err);
      }
    } else {
      fs.write(sonic.fd, sonic._writingBuf, "utf8", release);
    }
  };
  var actualClose = function(sonic) {
    if (sonic.fd === -1) {
      sonic.once("ready", actualClose.bind(null, sonic));
      return;
    }
    sonic.destroyed = true;
    sonic._bufs = [];
    if (sonic.fd !== 1 && sonic.fd !== 2) {
      fs.close(sonic.fd, done);
    } else {
      setImmediate(done);
    }
    function done(err) {
      if (err) {
        sonic.emit("error", err);
        return;
      }
      if (sonic._ending && !sonic._writing) {
        sonic.emit("finish");
      }
      sonic.emit("close");
    }
  };
  var fs = import.meta.require("fs");
  var EventEmitter = import.meta.require("events");
  var inherits = import.meta.require("util").inherits;
  var path = import.meta.require("path");
  var sleep = require_atomic_sleep();
  var BUSY_WRITE_TIMEOUT = 100;
  var MAX_WRITE = 16 * 1024;
  inherits(SonicBoom, EventEmitter);
  SonicBoom.prototype.write = function(data) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    const len = this._len + data.length;
    const bufs = this._bufs;
    if (this.maxLength && len > this.maxLength) {
      this.emit("drop", data);
      return this._len < this._hwm;
    }
    if (bufs.length === 0 || bufs[bufs.length - 1].length + data.length > this.maxWrite) {
      bufs.push("" + data);
    } else {
      bufs[bufs.length - 1] += data;
    }
    this._len = len;
    if (!this._writing && this._len >= this.minLength) {
      actualWrite(this);
    }
    return this._len < this._hwm;
  };
  SonicBoom.prototype.flush = function() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._writing || this.minLength <= 0) {
      return;
    }
    if (this._bufs.length === 0) {
      this._bufs.push("");
    }
    actualWrite(this);
  };
  SonicBoom.prototype.reopen = function(file) {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._opening) {
      this.once("ready", () => {
        this.reopen(file);
      });
      return;
    }
    if (this._ending) {
      return;
    }
    if (!this.file) {
      throw new Error("Unable to reopen a file descriptor, you must pass a file to SonicBoom");
    }
    this._reopening = true;
    if (this._writing) {
      return;
    }
    const fd = this.fd;
    this.once("ready", () => {
      if (fd !== this.fd) {
        fs.close(fd, (err) => {
          if (err) {
            return this.emit("error", err);
          }
        });
      }
    });
    openFile(file || this.file, this);
  };
  SonicBoom.prototype.end = function() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this._opening) {
      this.once("ready", () => {
        this.end();
      });
      return;
    }
    if (this._ending) {
      return;
    }
    this._ending = true;
    if (this._writing) {
      return;
    }
    if (this._len > 0 && this.fd >= 0) {
      actualWrite(this);
    } else {
      actualClose(this);
    }
  };
  SonicBoom.prototype.flushSync = function() {
    if (this.destroyed) {
      throw new Error("SonicBoom destroyed");
    }
    if (this.fd < 0) {
      throw new Error("sonic boom is not ready yet");
    }
    if (!this._writing && this._writingBuf.length > 0) {
      this._bufs.unshift(this._writingBuf);
      this._writingBuf = "";
    }
    let buf = "";
    while (this._bufs.length || buf.length) {
      if (buf.length <= 0) {
        buf = this._bufs[0];
      }
      try {
        const n = fs.writeSync(this.fd, buf, "utf8");
        buf = buf.slice(n);
        this._len = Math.max(this._len - n, 0);
        if (buf.length <= 0) {
          this._bufs.shift();
        }
      } catch (err) {
        const shouldRetry = err.code === "EAGAIN" || err.code === "EBUSY";
        if (shouldRetry && !this.retryEAGAIN(err, buf.length, this._len - buf.length)) {
          throw err;
        }
        sleep(BUSY_WRITE_TIMEOUT);
      }
    }
  };
  SonicBoom.prototype.destroy = function() {
    if (this.destroyed) {
      return;
    }
    actualClose(this);
  };
  SonicBoom.SonicBoom = SonicBoom;
  SonicBoom.default = SonicBoom;
  module.exports = SonicBoom;
});

// node_modules/@libsql/hrana-client/lib-e
var require_on_exit_leak_free = __commonJS((exports, module) => {
  var install = function(event) {
    if (refs[event].length > 0) {
      return;
    }
    process.on(event, functions[event]);
  };
  var uninstall = function(event) {
    if (refs[event].length > 0) {
      return;
    }
    process.removeListener(event, functions[event]);
  };
  var onExit = function() {
    callRefs("exit");
  };
  var onBeforeExit = function() {
    callRefs("beforeExit");
  };
  var callRefs = function(event) {
    for (const ref of refs[event]) {
      const obj = ref.deref();
      const fn = ref.fn;
      if (obj !== undefined) {
        fn(obj, event);
      }
    }
  };
  var clear = function(ref) {
    for (const event of ["exit", "beforeExit"]) {
      const index = refs[event].indexOf(ref);
      refs[event].splice(index, index + 1);
      uninstall(event);
    }
  };
  var _register = function(event, obj, fn) {
    if (obj === undefined) {
      throw new Error("the object can\'t be undefined");
    }
    install(event);
    const ref = new WeakRef(obj);
    ref.fn = fn;
    registry.register(obj, ref);
    refs[event].push(ref);
  };
  var register = function(obj, fn) {
    _register("exit", obj, fn);
  };
  var registerBeforeExit = function(obj, fn) {
    _register("beforeExit", obj, fn);
  };
  var unregister = function(obj) {
    registry.unregister(obj);
    for (const event of ["exit", "beforeExit"]) {
      refs[event] = refs[event].filter((ref) => {
        const _obj = ref.deref();
        return _obj && _obj !== obj;
      });
      uninstall(event);
    }
  };
  var refs = {
    exit: [],
    beforeExit: []
  };
  var functions = {
    exit: onExit,
    beforeExit: onBeforeExit
  };
  var registry = new FinalizationRegistry(clear);
  module.exports = {
    register,
    registerBeforeExit,
    unregister
  };
});

// node_modules/@libsql/hrana-client/lib-e
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "thread-stream",
    version: "2.4.0",
    description: "A streaming way to send data to a Node.js Worker Thread",
    main: "index.js",
    types: "index.d.ts",
    dependencies: {
      "real-require": "^0.2.0"
    },
    devDependencies: {
      "@types/node": "^20.1.0",
      "@types/tap": "^15.0.0",
      desm: "^1.3.0",
      fastbench: "^1.0.1",
      husky: "^8.0.1",
      "pino-elasticsearch": "^6.0.0",
      "sonic-boom": "^3.0.0",
      standard: "^17.0.0",
      tap: "^16.2.0",
      "ts-node": "^10.8.0",
      typescript: "^4.7.2",
      "why-is-node-running": "^2.2.2"
    },
    scripts: {
      test: "standard && npm run transpile && tap test/*.test.*js && tap --ts test/*.test.*ts",
      "test:ci": "standard && npm run transpile && npm run test:ci:js && npm run test:ci:ts",
      "test:ci:js": "tap --no-check-coverage --coverage-report=lcovonly \"test/**/*.test.*js\"",
      "test:ci:ts": "tap --ts --no-check-coverage --coverage-report=lcovonly \"test/**/*.test.*ts\"",
      "test:yarn": "npm run transpile && tap \"test/**/*.test.js\" --no-check-coverage",
      transpile: "sh ./test/ts/transpile.sh",
      prepare: "husky install"
    },
    standard: {
      ignore: [
        "test/ts/**/*"
      ]
    },
    repository: {
      type: "git",
      url: "git+https://github.com/mcollina/thread-stream.git"
    },
    keywords: [
      "worker",
      "thread",
      "threads",
      "stream"
    ],
    author: "Matteo Collina <hello@matteocollina.com>",
    license: "MIT",
    bugs: {
      url: "https://github.com/mcollina/thread-stream/issues"
    },
    homepage: "https://github.com/mcollina/thread-stream#readme"
  };
});

// node_modules/@libsql/hrana-client/lib-
var require_wait = __commonJS((exports, module) => {
  var wait = function(state, index, expected, timeout, done) {
    const max = Date.now() + timeout;
    let current = Atomics.load(state, index);
    if (current === expected) {
      done(null, "ok");
      return;
    }
    let prior = current;
    const check = (backoff) => {
      if (Date.now() > max) {
        done(null, "timed-out");
      } else {
        setTimeout(() => {
          prior = current;
          current = Atomics.load(state, index);
          if (current === prior) {
            check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
          } else {
            if (current === expected)
              done(null, "ok");
            else
              done(null, "not-equal");
          }
        }, backoff);
      }
    };
    check(1);
  };
  var waitDiff = function(state, index, expected, timeout, done) {
    const max = Date.now() + timeout;
    let current = Atomics.load(state, index);
    if (current !== expected) {
      done(null, "ok");
      return;
    }
    const check = (backoff) => {
      if (Date.now() > max) {
        done(null, "timed-out");
      } else {
        setTimeout(() => {
          current = Atomics.load(state, index);
          if (current !== expected) {
            done(null, "ok");
          } else {
            check(backoff >= MAX_TIMEOUT ? MAX_TIMEOUT : backoff * 2);
          }
        }, backoff);
      }
    };
    check(1);
  };
  var MAX_TIMEOUT = 1000;
  module.exports = { wait, waitDiff };
});

// node_modules/@libsql/hrana-client/lib-esm
var require_indexes = __commonJS((exports, module) => {
  var WRITE_INDEX = 4;
  var READ_INDEX = 8;
  module.exports = {
    WRITE_INDEX,
    READ_INDEX
  };
});

// node_modules/@libsql/hrana-client/l
var require_thread_stream = __commonJS((exports, module) => {
  var createWorker = function(stream2, opts) {
    const { filename, workerData } = opts;
    const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    const toExecute = bundlerOverrides["thread-stream-worker"] || join2(__dirname, "lib", "worker.js");
    const worker = new Worker(toExecute, {
      ...opts.workerOpts,
      trackUnmanagedFds: false,
      workerData: {
        filename: filename.indexOf("file://") === 0 ? filename : pathToFileURL(filename).href,
        dataBuf: stream2[kImpl].dataBuf,
        stateBuf: stream2[kImpl].stateBuf,
        workerData: {
          $context: {
            threadStreamVersion: version
          },
          ...workerData
        }
      }
    });
    worker.stream = new FakeWeakRef(stream2);
    worker.on("message", onWorkerMessage);
    worker.on("exit", onWorkerExit);
    registry.register(stream2, worker);
    return worker;
  };
  var drain = function(stream2) {
    assert(!stream2[kImpl].sync);
    if (stream2[kImpl].needDrain) {
      stream2[kImpl].needDrain = false;
      stream2.emit("drain");
    }
  };
  var nextFlush = function(stream2) {
    const writeIndex = Atomics.load(stream2[kImpl].state, WRITE_INDEX);
    let leftover = stream2[kImpl].data.length - writeIndex;
    if (leftover > 0) {
      if (stream2[kImpl].buf.length === 0) {
        stream2[kImpl].flushing = false;
        if (stream2[kImpl].ending) {
          end(stream2);
        } else if (stream2[kImpl].needDrain) {
          process.nextTick(drain, stream2);
        }
        return;
      }
      let toWrite = stream2[kImpl].buf.slice(0, leftover);
      let toWriteBytes = Buffer.byteLength(toWrite);
      if (toWriteBytes <= leftover) {
        stream2[kImpl].buf = stream2[kImpl].buf.slice(leftover);
        write(stream2, toWrite, nextFlush.bind(null, stream2));
      } else {
        stream2.flush(() => {
          if (stream2.destroyed) {
            return;
          }
          Atomics.store(stream2[kImpl].state, READ_INDEX, 0);
          Atomics.store(stream2[kImpl].state, WRITE_INDEX, 0);
          while (toWriteBytes > stream2[kImpl].data.length) {
            leftover = leftover / 2;
            toWrite = stream2[kImpl].buf.slice(0, leftover);
            toWriteBytes = Buffer.byteLength(toWrite);
          }
          stream2[kImpl].buf = stream2[kImpl].buf.slice(leftover);
          write(stream2, toWrite, nextFlush.bind(null, stream2));
        });
      }
    } else if (leftover === 0) {
      if (writeIndex === 0 && stream2[kImpl].buf.length === 0) {
        return;
      }
      stream2.flush(() => {
        Atomics.store(stream2[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream2[kImpl].state, WRITE_INDEX, 0);
        nextFlush(stream2);
      });
    } else {
      destroy(stream2, new Error("overwritten"));
    }
  };
  var onWorkerMessage = function(msg) {
    const stream2 = this.stream.deref();
    if (stream2 === undefined) {
      this.exited = true;
      this.terminate();
      return;
    }
    switch (msg.code) {
      case "READY":
        this.stream = new WeakRef2(stream2);
        stream2.flush(() => {
          stream2[kImpl].ready = true;
          stream2.emit("ready");
        });
        break;
      case "ERROR":
        destroy(stream2, msg.err);
        break;
      case "EVENT":
        if (Array.isArray(msg.args)) {
          stream2.emit(msg.name, ...msg.args);
        } else {
          stream2.emit(msg.name, msg.args);
        }
        break;
      case "WARNING":
        process.emitWarning(msg.err);
        break;
      default:
        destroy(stream2, new Error("this should not happen: " + msg.code));
    }
  };
  var onWorkerExit = function(code) {
    const stream2 = this.stream.deref();
    if (stream2 === undefined) {
      return;
    }
    registry.unregister(stream2);
    stream2.worker.exited = true;
    stream2.worker.off("exit", onWorkerExit);
    destroy(stream2, code !== 0 ? new Error("the worker thread exited") : null);
  };
  var error5 = function(stream2, err) {
    setImmediate(() => {
      stream2.emit("error", err);
    });
  };
  var destroy = function(stream2, err) {
    if (stream2[kImpl].destroyed) {
      return;
    }
    stream2[kImpl].destroyed = true;
    if (err) {
      stream2[kImpl].errored = err;
      error5(stream2, err);
    }
    if (!stream2.worker.exited) {
      stream2.worker.terminate().catch(() => {
      }).then(() => {
        stream2[kImpl].closed = true;
        stream2.emit("close");
      });
    } else {
      setImmediate(() => {
        stream2[kImpl].closed = true;
        stream2.emit("close");
      });
    }
  };
  var write = function(stream2, data, cb) {
    const current = Atomics.load(stream2[kImpl].state, WRITE_INDEX);
    const length = Buffer.byteLength(data);
    stream2[kImpl].data.write(data, current);
    Atomics.store(stream2[kImpl].state, WRITE_INDEX, current + length);
    Atomics.notify(stream2[kImpl].state, WRITE_INDEX);
    cb();
    return true;
  };
  var end = function(stream2) {
    if (stream2[kImpl].ended || !stream2[kImpl].ending || stream2[kImpl].flushing) {
      return;
    }
    stream2[kImpl].ended = true;
    try {
      stream2.flushSync();
      let readIndex = Atomics.load(stream2[kImpl].state, READ_INDEX);
      Atomics.store(stream2[kImpl].state, WRITE_INDEX, -1);
      Atomics.notify(stream2[kImpl].state, WRITE_INDEX);
      let spins = 0;
      while (readIndex !== -1) {
        Atomics.wait(stream2[kImpl].state, READ_INDEX, readIndex, 1000);
        readIndex = Atomics.load(stream2[kImpl].state, READ_INDEX);
        if (readIndex === -2) {
          destroy(stream2, new Error("end() failed"));
          return;
        }
        if (++spins === 10) {
          destroy(stream2, new Error("end() took too long (10s)"));
          return;
        }
      }
      process.nextTick(() => {
        stream2[kImpl].finished = true;
        stream2.emit("finish");
      });
    } catch (err) {
      destroy(stream2, err);
    }
  };
  var writeSync = function(stream2) {
    const cb = () => {
      if (stream2[kImpl].ending) {
        end(stream2);
      } else if (stream2[kImpl].needDrain) {
        process.nextTick(drain, stream2);
      }
    };
    stream2[kImpl].flushing = false;
    while (stream2[kImpl].buf.length !== 0) {
      const writeIndex = Atomics.load(stream2[kImpl].state, WRITE_INDEX);
      let leftover = stream2[kImpl].data.length - writeIndex;
      if (leftover === 0) {
        flushSync(stream2);
        Atomics.store(stream2[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream2[kImpl].state, WRITE_INDEX, 0);
        continue;
      } else if (leftover < 0) {
        throw new Error("overwritten");
      }
      let toWrite = stream2[kImpl].buf.slice(0, leftover);
      let toWriteBytes = Buffer.byteLength(toWrite);
      if (toWriteBytes <= leftover) {
        stream2[kImpl].buf = stream2[kImpl].buf.slice(leftover);
        write(stream2, toWrite, cb);
      } else {
        flushSync(stream2);
        Atomics.store(stream2[kImpl].state, READ_INDEX, 0);
        Atomics.store(stream2[kImpl].state, WRITE_INDEX, 0);
        while (toWriteBytes > stream2[kImpl].buf.length) {
          leftover = leftover / 2;
          toWrite = stream2[kImpl].buf.slice(0, leftover);
          toWriteBytes = Buffer.byteLength(toWrite);
        }
        stream2[kImpl].buf = stream2[kImpl].buf.slice(leftover);
        write(stream2, toWrite, cb);
      }
    }
  };
  var flushSync = function(stream2) {
    if (stream2[kImpl].flushing) {
      throw new Error("unable to flush while flushing");
    }
    const writeIndex = Atomics.load(stream2[kImpl].state, WRITE_INDEX);
    let spins = 0;
    while (true) {
      const readIndex = Atomics.load(stream2[kImpl].state, READ_INDEX);
      if (readIndex === -2) {
        throw Error("_flushSync failed");
      }
      if (readIndex !== writeIndex) {
        Atomics.wait(stream2[kImpl].state, READ_INDEX, readIndex, 1000);
      } else {
        break;
      }
      if (++spins === 10) {
        throw new Error("_flushSync took too long (10s)");
      }
    }
  };
  var __dirname = "/workspaces/hermes/node_modules/thread-stream";
  var { version } = require_package();
  var { EventEmitter } = import.meta.require("events");
  var { Worker } = import.meta.require("worker_threads");
  var { join: join2 } = import.meta.require("path");
  var { pathToFileURL } = import.meta.require("url");
  var { wait } = require_wait();
  var {
    WRITE_INDEX,
    READ_INDEX
  } = require_indexes();
  var buffer = import.meta.require("buffer");
  var assert = import.meta.require("assert");
  var kImpl = Symbol("kImpl");
  var MAX_STRING = buffer.constants.MAX_STRING_LENGTH;

  class FakeWeakRef {
    constructor(value) {
      this._value = value;
    }
    deref() {
      return this._value;
    }
  }
  var FinalizationRegistry2 = global.FinalizationRegistry || class FakeFinalizationRegistry {
    register() {
    }
    unregister() {
    }
  };
  var WeakRef2 = global.WeakRef || FakeWeakRef;
  var registry = new FinalizationRegistry2((worker) => {
    if (worker.exited) {
      return;
    }
    worker.terminate();
  });

  class ThreadStream extends EventEmitter {
    constructor(opts = {}) {
      super();
      if (opts.bufferSize < 4) {
        throw new Error("bufferSize must at least fit a 4-byte utf-8 char");
      }
      this[kImpl] = {};
      this[kImpl].stateBuf = new SharedArrayBuffer(128);
      this[kImpl].state = new Int32Array(this[kImpl].stateBuf);
      this[kImpl].dataBuf = new SharedArrayBuffer(opts.bufferSize || 4 * 1024 * 1024);
      this[kImpl].data = Buffer.from(this[kImpl].dataBuf);
      this[kImpl].sync = opts.sync || false;
      this[kImpl].ending = false;
      this[kImpl].ended = false;
      this[kImpl].needDrain = false;
      this[kImpl].destroyed = false;
      this[kImpl].flushing = false;
      this[kImpl].ready = false;
      this[kImpl].finished = false;
      this[kImpl].errored = null;
      this[kImpl].closed = false;
      this[kImpl].buf = "";
      this.worker = createWorker(this, opts);
    }
    write(data) {
      if (this[kImpl].destroyed) {
        error5(this, new Error("the worker has exited"));
        return false;
      }
      if (this[kImpl].ending) {
        error5(this, new Error("the worker is ending"));
        return false;
      }
      if (this[kImpl].flushing && this[kImpl].buf.length + data.length >= MAX_STRING) {
        try {
          writeSync(this);
          this[kImpl].flushing = true;
        } catch (err) {
          destroy(this, err);
          return false;
        }
      }
      this[kImpl].buf += data;
      if (this[kImpl].sync) {
        try {
          writeSync(this);
          return true;
        } catch (err) {
          destroy(this, err);
          return false;
        }
      }
      if (!this[kImpl].flushing) {
        this[kImpl].flushing = true;
        setImmediate(nextFlush, this);
      }
      this[kImpl].needDrain = this[kImpl].data.length - this[kImpl].buf.length - Atomics.load(this[kImpl].state, WRITE_INDEX) <= 0;
      return !this[kImpl].needDrain;
    }
    end() {
      if (this[kImpl].destroyed) {
        return;
      }
      this[kImpl].ending = true;
      end(this);
    }
    flush(cb) {
      if (this[kImpl].destroyed) {
        if (typeof cb === "function") {
          process.nextTick(cb, new Error("the worker has exited"));
        }
        return;
      }
      const writeIndex = Atomics.load(this[kImpl].state, WRITE_INDEX);
      wait(this[kImpl].state, READ_INDEX, writeIndex, Infinity, (err, res) => {
        if (err) {
          destroy(this, err);
          process.nextTick(cb, err);
          return;
        }
        if (res === "not-equal") {
          this.flush(cb);
          return;
        }
        process.nextTick(cb);
      });
    }
    flushSync() {
      if (this[kImpl].destroyed) {
        return;
      }
      writeSync(this);
      flushSync(this);
    }
    unref() {
      this.worker.unref();
    }
    ref() {
      this.worker.ref();
    }
    get ready() {
      return this[kImpl].ready;
    }
    get destroyed() {
      return this[kImpl].destroyed;
    }
    get closed() {
      return this[kImpl].closed;
    }
    get writable() {
      return !this[kImpl].destroyed && !this[kImpl].ending;
    }
    get writableEnded() {
      return this[kImpl].ending;
    }
    get writableFinished() {
      return this[kImpl].finished;
    }
    get writableNeedDrain() {
      return this[kImpl].needDrain;
    }
    get writableObjectMode() {
      return false;
    }
    get writableErrored() {
      return this[kImpl].errored;
    }
  }
  module.exports = ThreadStream;
});

// node_modules/@libsql/hrana-client/
var require_transport = __commonJS((exports, module) => {
  var setupOnExit = function(stream2) {
    onExit.register(stream2, autoEnd);
    onExit.registerBeforeExit(stream2, flush);
    stream2.on("close", function() {
      onExit.unregister(stream2);
    });
  };
  var buildStream = function(filename, workerData, workerOpts) {
    const stream2 = new ThreadStream({
      filename,
      workerData,
      workerOpts
    });
    stream2.on("ready", onReady);
    stream2.on("close", function() {
      process.removeListener("exit", onExit2);
    });
    process.on("exit", onExit2);
    function onReady() {
      process.removeListener("exit", onExit2);
      stream2.unref();
      if (workerOpts.autoEnd !== false) {
        setupOnExit(stream2);
      }
    }
    function onExit2() {
      if (stream2.closed) {
        return;
      }
      stream2.flushSync();
      sleep(100);
      stream2.end();
    }
    return stream2;
  };
  var autoEnd = function(stream2) {
    stream2.ref();
    stream2.flushSync();
    stream2.end();
    stream2.once("close", function() {
      stream2.unref();
    });
  };
  var flush = function(stream2) {
    stream2.flushSync();
  };
  var transport = function(fullOptions) {
    const { pipeline, targets, levels, dedupe, options = {}, worker = {}, caller = getCallers() } = fullOptions;
    const callers = typeof caller === "string" ? [caller] : caller;
    const bundlerOverrides = "__bundlerPathsOverrides" in globalThis ? globalThis.__bundlerPathsOverrides : {};
    let target = fullOptions.target;
    if (target && targets) {
      throw new Error("only one of target or targets can be specified");
    }
    if (targets) {
      target = bundlerOverrides["pino-worker"] || join2(__dirname, "worker.js");
      options.targets = targets.map((dest) => {
        return {
          ...dest,
          target: fixTarget(dest.target)
        };
      });
    } else if (pipeline) {
      target = bundlerOverrides["pino-pipeline-worker"] || join2(__dirname, "worker-pipeline.js");
      options.targets = pipeline.map((dest) => {
        return {
          ...dest,
          target: fixTarget(dest.target)
        };
      });
    }
    if (levels) {
      options.levels = levels;
    }
    if (dedupe) {
      options.dedupe = dedupe;
    }
    return buildStream(fixTarget(target), options, worker);
    function fixTarget(origin) {
      origin = bundlerOverrides[origin] || origin;
      if (isAbsolute(origin) || origin.indexOf("file://") === 0) {
        return origin;
      }
      if (origin === "pino/file") {
        return join2(__dirname, "..", "file.js");
      }
      let fixTarget2;
      for (const filePath of callers) {
        try {
          const context = filePath === "node:repl" ? process.cwd() + sep : filePath;
          fixTarget2 = createRequire(context).resolve(origin);
          break;
        } catch (err) {
          continue;
        }
      }
      if (!fixTarget2) {
        throw new Error(`unable to determine transport target for "${origin}"`);
      }
      return fixTarget2;
    }
  };
  var __dirname = "/workspaces/hermes/node_modules/pino/lib";
  var { createRequire } = import.meta.require("module");
  var getCallers = require_caller();
  var { join: join2, isAbsolute, sep } = import.meta.require("path");
  var sleep = require_atomic_sleep();
  var onExit = require_on_exit_leak_free();
  var ThreadStream = require_thread_stream();
  module.exports = transport;
});

// node_modules/@libsql/hrana-cli
var require_tools = __commonJS((exports, module) => {
  var noop = function() {
  };
  var genLog = function(level, hook) {
    if (!hook)
      return LOG;
    return function hookWrappedLog(...args2) {
      hook.call(this, args2, LOG, level);
    };
    function LOG(o, ...n) {
      if (typeof o === "object") {
        let msg = o;
        if (o !== null) {
          if (o.method && o.headers && o.socket) {
            o = mapHttpRequest(o);
          } else if (typeof o.setHeader === "function") {
            o = mapHttpResponse(o);
          }
        }
        let formatParams;
        if (msg === null && n.length === 0) {
          formatParams = [null];
        } else {
          msg = n.shift();
          formatParams = n;
        }
        if (typeof this[msgPrefixSym] === "string" && msg !== undefined && msg !== null) {
          msg = this[msgPrefixSym] + msg;
        }
        this[writeSym](o, format2(msg, formatParams, this[formatOptsSym]), level);
      } else {
        let msg = o === undefined ? n.shift() : o;
        if (typeof this[msgPrefixSym] === "string" && msg !== undefined && msg !== null) {
          msg = this[msgPrefixSym] + msg;
        }
        this[writeSym](null, format2(msg, n, this[formatOptsSym]), level);
      }
    }
  };
  var asString = function(str) {
    let result = "";
    let last = 0;
    let found = false;
    let point = 255;
    const l = str.length;
    if (l > 100) {
      return JSON.stringify(str);
    }
    for (var i = 0;i < l && point >= 32; i++) {
      point = str.charCodeAt(i);
      if (point === 34 || point === 92) {
        result += str.slice(last, i) + "\\";
        last = i;
        found = true;
      }
    }
    if (!found) {
      result = str;
    } else {
      result += str.slice(last);
    }
    return point < 32 ? JSON.stringify(str) : '"' + result + '"';
  };
  var asJson = function(obj, msg, num, time) {
    const stringify2 = this[stringifySym];
    const stringifySafe = this[stringifySafeSym];
    const stringifiers = this[stringifiersSym];
    const end = this[endSym];
    const chindings = this[chindingsSym];
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const messageKey = this[messageKeySym];
    const errorKey = this[errorKeySym];
    let data = this[lsCacheSym][num] + time;
    data = data + chindings;
    let value;
    if (formatters.log) {
      obj = formatters.log(obj);
    }
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    let propStr = "";
    for (const key in obj) {
      value = obj[key];
      if (Object.prototype.hasOwnProperty.call(obj, key) && value !== undefined) {
        if (serializers[key]) {
          value = serializers[key](value);
        } else if (key === errorKey && serializers.err) {
          value = serializers.err(value);
        }
        const stringifier = stringifiers[key] || wildcardStringifier;
        switch (typeof value) {
          case "undefined":
          case "function":
            continue;
          case "number":
            if (Number.isFinite(value) === false) {
              value = null;
            }
          case "boolean":
            if (stringifier)
              value = stringifier(value);
            break;
          case "string":
            value = (stringifier || asString)(value);
            break;
          default:
            value = (stringifier || stringify2)(value, stringifySafe);
        }
        if (value === undefined)
          continue;
        const strKey = asString(key);
        propStr += "," + strKey + ":" + value;
      }
    }
    let msgStr = "";
    if (msg !== undefined) {
      value = serializers[messageKey] ? serializers[messageKey](msg) : msg;
      const stringifier = stringifiers[messageKey] || wildcardStringifier;
      switch (typeof value) {
        case "function":
          break;
        case "number":
          if (Number.isFinite(value) === false) {
            value = null;
          }
        case "boolean":
          if (stringifier)
            value = stringifier(value);
          msgStr = ',"' + messageKey + '":' + value;
          break;
        case "string":
          value = (stringifier || asString)(value);
          msgStr = ',"' + messageKey + '":' + value;
          break;
        default:
          value = (stringifier || stringify2)(value, stringifySafe);
          msgStr = ',"' + messageKey + '":' + value;
      }
    }
    if (this[nestedKeySym] && propStr) {
      return data + this[nestedKeyStrSym] + propStr.slice(1) + "}" + msgStr + end;
    } else {
      return data + propStr + msgStr + end;
    }
  };
  var asChindings = function(instance, bindings) {
    let value;
    let data = instance[chindingsSym];
    const stringify2 = instance[stringifySym];
    const stringifySafe = instance[stringifySafeSym];
    const stringifiers = instance[stringifiersSym];
    const wildcardStringifier = stringifiers[wildcardFirstSym];
    const serializers = instance[serializersSym];
    const formatter = instance[formattersSym].bindings;
    bindings = formatter(bindings);
    for (const key in bindings) {
      value = bindings[key];
      const valid = key !== "level" && key !== "serializers" && key !== "formatters" && key !== "customLevels" && bindings.hasOwnProperty(key) && value !== undefined;
      if (valid === true) {
        value = serializers[key] ? serializers[key](value) : value;
        value = (stringifiers[key] || wildcardStringifier || stringify2)(value, stringifySafe);
        if (value === undefined)
          continue;
        data += ',"' + key + '":' + value;
      }
    }
    return data;
  };
  var hasBeenTampered = function(stream2) {
    return stream2.write !== stream2.constructor.prototype.write;
  };
  var buildSafeSonicBoom = function(opts) {
    const stream2 = new SonicBoom(opts);
    stream2.on("error", filterBrokenPipe);
    if (!opts.sync && isMainThread) {
      onExit.register(stream2, autoEnd);
      stream2.on("close", function() {
        onExit.unregister(stream2);
      });
    }
    return stream2;
    function filterBrokenPipe(err) {
      if (err.code === "EPIPE") {
        stream2.write = noop;
        stream2.end = noop;
        stream2.flushSync = noop;
        stream2.destroy = noop;
        return;
      }
      stream2.removeListener("error", filterBrokenPipe);
      stream2.emit("error", err);
    }
  };
  var autoEnd = function(stream2, eventName) {
    if (stream2.destroyed) {
      return;
    }
    if (eventName === "beforeExit") {
      stream2.flush();
      stream2.on("drain", function() {
        stream2.end();
      });
    } else {
      stream2.flushSync();
    }
  };
  var createArgsNormalizer = function(defaultOptions) {
    return function normalizeArgs(instance, caller, opts = {}, stream2) {
      if (typeof opts === "string") {
        stream2 = buildSafeSonicBoom({ dest: opts });
        opts = {};
      } else if (typeof stream2 === "string") {
        if (opts && opts.transport) {
          throw Error("only one of option.transport or stream can be specified");
        }
        stream2 = buildSafeSonicBoom({ dest: stream2 });
      } else if (opts instanceof SonicBoom || opts.writable || opts._writableState) {
        stream2 = opts;
        opts = {};
      } else if (opts.transport) {
        if (opts.transport instanceof SonicBoom || opts.transport.writable || opts.transport._writableState) {
          throw Error("option.transport do not allow stream, please pass to option directly. e.g. pino(transport)");
        }
        if (opts.transport.targets && opts.transport.targets.length && opts.formatters && typeof opts.formatters.level === "function") {
          throw Error("option.transport.targets do not allow custom level formatters");
        }
        let customLevels;
        if (opts.customLevels) {
          customLevels = opts.useOnlyCustomLevels ? opts.customLevels : Object.assign({}, opts.levels, opts.customLevels);
        }
        stream2 = transport({ caller, ...opts.transport, levels: customLevels });
      }
      opts = Object.assign({}, defaultOptions, opts);
      opts.serializers = Object.assign({}, defaultOptions.serializers, opts.serializers);
      opts.formatters = Object.assign({}, defaultOptions.formatters, opts.formatters);
      if (opts.prettyPrint) {
        throw new Error("prettyPrint option is no longer supported, see the pino-pretty package (https://github.com/pinojs/pino-pretty)");
      }
      const { enabled, onChild } = opts;
      if (enabled === false)
        opts.level = "silent";
      if (!onChild)
        opts.onChild = noop;
      if (!stream2) {
        if (!hasBeenTampered(process.stdout)) {
          stream2 = buildSafeSonicBoom({ fd: process.stdout.fd || 1 });
        } else {
          stream2 = process.stdout;
        }
      }
      return { opts, stream: stream2 };
    };
  };
  var stringify = function(obj, stringifySafeFn) {
    try {
      return JSON.stringify(obj);
    } catch (_) {
      try {
        const stringify2 = stringifySafeFn || this[stringifySafeSym];
        return stringify2(obj);
      } catch (_2) {
        return '"[unable to serialize, circular reference is too complex to analyze]"';
      }
    }
  };
  var buildFormatters = function(level, bindings, log3) {
    return {
      level,
      bindings,
      log: log3
    };
  };
  var normalizeDestFileDescriptor = function(destination) {
    const fd = Number(destination);
    if (typeof destination === "string" && Number.isFinite(fd)) {
      return fd;
    }
    if (destination === undefined) {
      return 1;
    }
    return destination;
  };
  var format2 = require_quick_format_unescaped();
  var { mapHttpRequest, mapHttpResponse } = require_pino_std_serializers();
  var SonicBoom = require_sonic_boom();
  var onExit = require_on_exit_leak_free();
  var {
    lsCacheSym,
    chindingsSym,
    writeSym,
    serializersSym,
    formatOptsSym,
    endSym,
    stringifiersSym,
    stringifySym,
    stringifySafeSym,
    wildcardFirstSym,
    nestedKeySym,
    formattersSym,
    messageKeySym,
    errorKeySym,
    nestedKeyStrSym,
    msgPrefixSym
  } = require_symbols();
  var { isMainThread } = import.meta.require("worker_threads");
  var transport = require_transport();
  module.exports = {
    noop,
    buildSafeSonicBoom,
    asChindings,
    asJson,
    genLog,
    createArgsNormalizer,
    stringify,
    buildFormatters,
    normalizeDestFileDescriptor
  };
});

// node_modules/@libsql/hrana-clie
var require_levels = __commonJS((exports, module) => {
  var genLsCache = function(instance) {
    const formatter = instance[formattersSym].level;
    const { labels } = instance.levels;
    const cache = {};
    for (const label in labels) {
      const level = formatter(labels[label], Number(label));
      cache[label] = JSON.stringify(level).slice(0, -1);
    }
    instance[lsCacheSym] = cache;
    return instance;
  };
  var isStandardLevel = function(level, useOnlyCustomLevels) {
    if (useOnlyCustomLevels) {
      return false;
    }
    switch (level) {
      case "fatal":
      case "error":
      case "warn":
      case "info":
      case "debug":
      case "trace":
        return true;
      default:
        return false;
    }
  };
  var setLevel = function(level) {
    const { labels, values } = this.levels;
    if (typeof level === "number") {
      if (labels[level] === undefined)
        throw Error("unknown level value" + level);
      level = labels[level];
    }
    if (values[level] === undefined)
      throw Error("unknown level " + level);
    const preLevelVal = this[levelValSym];
    const levelVal = this[levelValSym] = values[level];
    const useOnlyCustomLevelsVal = this[useOnlyCustomLevelsSym];
    const hook = this[hooksSym].logMethod;
    for (const key in values) {
      if (levelVal > values[key]) {
        this[key] = noop;
        continue;
      }
      this[key] = isStandardLevel(key, useOnlyCustomLevelsVal) ? levelMethods[key](hook) : genLog(values[key], hook);
    }
    this.emit("level-change", level, levelVal, labels[preLevelVal], preLevelVal, this);
  };
  var getLevel = function(level) {
    const { levels: levels2, levelVal } = this;
    return levels2 && levels2.labels ? levels2.labels[levelVal] : "";
  };
  var isLevelEnabled = function(logLevel) {
    const { values } = this.levels;
    const logLevelVal = values[logLevel];
    return logLevelVal !== undefined && logLevelVal >= this[levelValSym];
  };
  var mappings = function(customLevels = null, useOnlyCustomLevels = false) {
    const customNums = customLevels ? Object.keys(customLevels).reduce((o, k) => {
      o[customLevels[k]] = k;
      return o;
    }, {}) : null;
    const labels = Object.assign(Object.create(Object.prototype, { Infinity: { value: "silent" } }), useOnlyCustomLevels ? null : nums, customNums);
    const values = Object.assign(Object.create(Object.prototype, { silent: { value: Infinity } }), useOnlyCustomLevels ? null : levels, customLevels);
    return { labels, values };
  };
  var assertDefaultLevelFound = function(defaultLevel, customLevels, useOnlyCustomLevels) {
    if (typeof defaultLevel === "number") {
      const values = [].concat(Object.keys(customLevels || {}).map((key) => customLevels[key]), useOnlyCustomLevels ? [] : Object.keys(nums).map((level) => +level), Infinity);
      if (!values.includes(defaultLevel)) {
        throw Error(`default level:${defaultLevel} must be included in custom levels`);
      }
      return;
    }
    const labels = Object.assign(Object.create(Object.prototype, { silent: { value: Infinity } }), useOnlyCustomLevels ? null : levels, customLevels);
    if (!(defaultLevel in labels)) {
      throw Error(`default level:${defaultLevel} must be included in custom levels`);
    }
  };
  var assertNoLevelCollisions = function(levels2, customLevels) {
    const { labels, values } = levels2;
    for (const k in customLevels) {
      if (k in values) {
        throw Error("levels cannot be overridden");
      }
      if (customLevels[k] in labels) {
        throw Error("pre-existing level values cannot be used for new levels");
      }
    }
  };
  var {
    lsCacheSym,
    levelValSym,
    useOnlyCustomLevelsSym,
    streamSym,
    formattersSym,
    hooksSym
  } = require_symbols();
  var { noop, genLog } = require_tools();
  var levels = {
    trace: 10,
    debug: 20,
    info: 30,
    warn: 40,
    error: 50,
    fatal: 60
  };
  var levelMethods = {
    fatal: (hook) => {
      const logFatal = genLog(levels.fatal, hook);
      return function(...args2) {
        const stream2 = this[streamSym];
        logFatal.call(this, ...args2);
        if (typeof stream2.flushSync === "function") {
          try {
            stream2.flushSync();
          } catch (e) {
          }
        }
      };
    },
    error: (hook) => genLog(levels.error, hook),
    warn: (hook) => genLog(levels.warn, hook),
    info: (hook) => genLog(levels.info, hook),
    debug: (hook) => genLog(levels.debug, hook),
    trace: (hook) => genLog(levels.trace, hook)
  };
  var nums = Object.keys(levels).reduce((o, k) => {
    o[levels[k]] = k;
    return o;
  }, {});
  var initialLsCache = Object.keys(nums).reduce((o, k) => {
    o[k] = '{"level":' + Number(k);
    return o;
  }, {});
  module.exports = {
    initialLsCache,
    genLsCache,
    levelMethods,
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    levels,
    assertNoLevelCollisions,
    assertDefaultLevelFound
  };
});

// node_modules/@libsql/hrana-cl
var require_meta = __commonJS((exports, module) => {
  module.exports = { version: "8.15.1" };
});

// node_modules/@libsql/hrana-cli
var require_proto = __commonJS((exports, module) => {
  var child = function(bindings2, options) {
    if (!bindings2) {
      throw Error("missing bindings for child Pino");
    }
    options = options || {};
    const serializers = this[serializersSym];
    const formatters = this[formattersSym];
    const instance = Object.create(this);
    if (options.hasOwnProperty("serializers") === true) {
      instance[serializersSym] = Object.create(null);
      for (const k in serializers) {
        instance[serializersSym][k] = serializers[k];
      }
      const parentSymbols = Object.getOwnPropertySymbols(serializers);
      for (var i = 0;i < parentSymbols.length; i++) {
        const ks = parentSymbols[i];
        instance[serializersSym][ks] = serializers[ks];
      }
      for (const bk in options.serializers) {
        instance[serializersSym][bk] = options.serializers[bk];
      }
      const bindingsSymbols = Object.getOwnPropertySymbols(options.serializers);
      for (var bi = 0;bi < bindingsSymbols.length; bi++) {
        const bks = bindingsSymbols[bi];
        instance[serializersSym][bks] = options.serializers[bks];
      }
    } else
      instance[serializersSym] = serializers;
    if (options.hasOwnProperty("formatters")) {
      const { level, bindings: chindings, log: log3 } = options.formatters;
      instance[formattersSym] = buildFormatters(level || formatters.level, chindings || resetChildingsFormatter, log3 || formatters.log);
    } else {
      instance[formattersSym] = buildFormatters(formatters.level, resetChildingsFormatter, formatters.log);
    }
    if (options.hasOwnProperty("customLevels") === true) {
      assertNoLevelCollisions(this.levels, options.customLevels);
      instance.levels = mappings(options.customLevels, instance[useOnlyCustomLevelsSym]);
      genLsCache(instance);
    }
    if (typeof options.redact === "object" && options.redact !== null || Array.isArray(options.redact)) {
      instance.redact = options.redact;
      const stringifiers = redaction(instance.redact, stringify);
      const formatOpts = { stringify: stringifiers[redactFmtSym] };
      instance[stringifySym] = stringify;
      instance[stringifiersSym] = stringifiers;
      instance[formatOptsSym] = formatOpts;
    }
    if (typeof options.msgPrefix === "string") {
      instance[msgPrefixSym] = (this[msgPrefixSym] || "") + options.msgPrefix;
    }
    instance[chindingsSym] = asChindings(instance, bindings2);
    const childLevel = options.level || this.level;
    instance[setLevelSym](childLevel);
    this.onChild(instance);
    return instance;
  };
  var bindings = function() {
    const chindings = this[chindingsSym];
    const chindingsJson = `{${chindings.substr(1)}}`;
    const bindingsFromJson = JSON.parse(chindingsJson);
    delete bindingsFromJson.pid;
    delete bindingsFromJson.hostname;
    return bindingsFromJson;
  };
  var setBindings = function(newBindings) {
    const chindings = asChindings(this, newBindings);
    this[chindingsSym] = chindings;
    delete this[parsedChindingsSym];
  };
  var defaultMixinMergeStrategy = function(mergeObject, mixinObject) {
    return Object.assign(mixinObject, mergeObject);
  };
  var write = function(_obj, msg, num) {
    const t = this[timeSym]();
    const mixin = this[mixinSym];
    const errorKey = this[errorKeySym];
    const messageKey = this[messageKeySym];
    const mixinMergeStrategy = this[mixinMergeStrategySym] || defaultMixinMergeStrategy;
    let obj;
    if (_obj === undefined || _obj === null) {
      obj = {};
    } else if (_obj instanceof Error) {
      obj = { [errorKey]: _obj };
      if (msg === undefined) {
        msg = _obj.message;
      }
    } else {
      obj = _obj;
      if (msg === undefined && _obj[messageKey] === undefined && _obj[errorKey]) {
        msg = _obj[errorKey].message;
      }
    }
    if (mixin) {
      obj = mixinMergeStrategy(obj, mixin(obj, num, this));
    }
    const s = this[asJsonSym](obj, msg, num, t);
    const stream2 = this[streamSym];
    if (stream2[needsMetadataGsym] === true) {
      stream2.lastLevel = num;
      stream2.lastObj = obj;
      stream2.lastMsg = msg;
      stream2.lastTime = t.slice(this[timeSliceIndexSym]);
      stream2.lastLogger = this;
    }
    stream2.write(s);
  };
  var noop = function() {
  };
  var flush = function() {
    const stream2 = this[streamSym];
    if ("flush" in stream2)
      stream2.flush(noop);
  };
  var { EventEmitter } = import.meta.require("events");
  var {
    lsCacheSym,
    levelValSym,
    setLevelSym,
    getLevelSym,
    chindingsSym,
    parsedChindingsSym,
    mixinSym,
    asJsonSym,
    writeSym,
    mixinMergeStrategySym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    serializersSym,
    formattersSym,
    errorKeySym,
    messageKeySym,
    useOnlyCustomLevelsSym,
    needsMetadataGsym,
    redactFmtSym,
    stringifySym,
    formatOptsSym,
    stringifiersSym,
    msgPrefixSym
  } = require_symbols();
  var {
    getLevel,
    setLevel,
    isLevelEnabled,
    mappings,
    initialLsCache,
    genLsCache,
    assertNoLevelCollisions
  } = require_levels();
  var {
    asChindings,
    asJson,
    buildFormatters,
    stringify
  } = require_tools();
  var {
    version
  } = require_meta();
  var redaction = require_redaction();
  var constructor = class Pino {
  };
  var prototype = {
    constructor,
    child,
    bindings,
    setBindings,
    flush,
    isLevelEnabled,
    version,
    get level() {
      return this[getLevelSym]();
    },
    set level(lvl) {
      this[setLevelSym](lvl);
    },
    get levelVal() {
      return this[levelValSym];
    },
    set levelVal(n) {
      throw Error("levelVal is read-only");
    },
    [lsCacheSym]: initialLsCache,
    [writeSym]: write,
    [asJsonSym]: asJson,
    [getLevelSym]: getLevel,
    [setLevelSym]: setLevel
  };
  Object.setPrototypeOf(prototype, EventEmitter.prototype);
  module.exports = function() {
    return Object.create(prototype);
  };
  var resetChildingsFormatter = (bindings2) => bindings2;
});

// node_modules/@libsql/hrana-client/lib-esm/e
var require_safe_stable_stringify = __commonJS((exports, module) => {
  var strEscape = function(str) {
    if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
      return `"${str}"`;
    }
    return JSON.stringify(str);
  };
  var insertSort = function(array) {
    if (array.length > 200) {
      return array.sort();
    }
    for (let i = 1;i < array.length; i++) {
      const currentValue = array[i];
      let position = i;
      while (position !== 0 && array[position - 1] > currentValue) {
        array[position] = array[position - 1];
        position--;
      }
      array[position] = currentValue;
    }
    return array;
  };
  var isTypedArrayWithEntries = function(value) {
    return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0;
  };
  var stringifyTypedArray = function(array, separator, maximumBreadth) {
    if (array.length < maximumBreadth) {
      maximumBreadth = array.length;
    }
    const whitespace = separator === "," ? "" : " ";
    let res = `"0":${whitespace}${array[0]}`;
    for (let i = 1;i < maximumBreadth; i++) {
      res += `${separator}"${i}":${whitespace}${array[i]}`;
    }
    return res;
  };
  var getCircularValueOption = function(options) {
    if (hasOwnProperty.call(options, "circularValue")) {
      const circularValue = options.circularValue;
      if (typeof circularValue === "string") {
        return `"${circularValue}"`;
      }
      if (circularValue == null) {
        return circularValue;
      }
      if (circularValue === Error || circularValue === TypeError) {
        return {
          toString() {
            throw new TypeError("Converting circular structure to JSON");
          }
        };
      }
      throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
    }
    return '"[Circular]"';
  };
  var getBooleanOption = function(options, key) {
    let value;
    if (hasOwnProperty.call(options, key)) {
      value = options[key];
      if (typeof value !== "boolean") {
        throw new TypeError(`The "${key}" argument must be of type boolean`);
      }
    }
    return value === undefined ? true : value;
  };
  var getPositiveIntegerOption = function(options, key) {
    let value;
    if (hasOwnProperty.call(options, key)) {
      value = options[key];
      if (typeof value !== "number") {
        throw new TypeError(`The "${key}" argument must be of type number`);
      }
      if (!Number.isInteger(value)) {
        throw new TypeError(`The "${key}" argument must be an integer`);
      }
      if (value < 1) {
        throw new RangeError(`The "${key}" argument must be >= 1`);
      }
    }
    return value === undefined ? Infinity : value;
  };
  var getItemCount = function(number) {
    if (number === 1) {
      return "1 item";
    }
    return `${number} items`;
  };
  var getUniqueReplacerSet = function(replacerArray) {
    const replacerSet = new Set;
    for (const value of replacerArray) {
      if (typeof value === "string" || typeof value === "number") {
        replacerSet.add(String(value));
      }
    }
    return replacerSet;
  };
  var getStrictOption = function(options) {
    if (hasOwnProperty.call(options, "strict")) {
      const value = options.strict;
      if (typeof value !== "boolean") {
        throw new TypeError('The "strict" argument must be of type boolean');
      }
      if (value) {
        return (value2) => {
          let message = `Object can not safely be stringified. Received type ${typeof value2}`;
          if (typeof value2 !== "function")
            message += ` (${value2.toString()})`;
          throw new Error(message);
        };
      }
    }
  };
  var configure = function(options) {
    options = { ...options };
    const fail = getStrictOption(options);
    if (fail) {
      if (options.bigint === undefined) {
        options.bigint = false;
      }
      if (!("circularValue" in options)) {
        options.circularValue = Error;
      }
    }
    const circularValue = getCircularValueOption(options);
    const bigint = getBooleanOption(options, "bigint");
    const deterministic = getBooleanOption(options, "deterministic");
    const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
    const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
    function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
      let value = parent[key];
      if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      value = replacer.call(parent, key, value);
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          let res = "";
          let join2 = ",";
          const originalIndentation = indentation;
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            if (spacer !== "") {
              indentation += spacer;
              res += `\n${indentation}`;
              join2 = `,\n${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join2;
            }
            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `\n${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let whitespace = "";
          let separator = "";
          if (spacer !== "") {
            indentation += spacer;
            join2 = `,\n${indentation}`;
            whitespace = " ";
          }
          const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (deterministic && !isTypedArrayWithEntries(value)) {
            keys = insertSort(keys);
          }
          stack.push(value);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join2;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
            separator = join2;
          }
          if (spacer !== "" && separator.length > 1) {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
      if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
        value = value.toJSON(key);
      }
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          let res = "";
          let join2 = ",";
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            if (spacer !== "") {
              indentation += spacer;
              res += `\n${indentation}`;
              join2 = `,\n${indentation}`;
            }
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += join2;
            }
            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            if (spacer !== "") {
              res += `\n${originalIndentation}`;
            }
            stack.pop();
            return `[${res}]`;
          }
          stack.push(value);
          let whitespace = "";
          if (spacer !== "") {
            indentation += spacer;
            join2 = `,\n${indentation}`;
            whitespace = " ";
          }
          let separator = "";
          for (const key2 of replacer) {
            const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
              separator = join2;
            }
          }
          if (spacer !== "" && separator.length > 1) {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifyIndent(key, value, stack, spacer, indentation) {
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (typeof value.toJSON === "function") {
            value = value.toJSON(key);
            if (typeof value !== "object") {
              return stringifyIndent(key, value, stack, spacer, indentation);
            }
            if (value === null) {
              return "null";
            }
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          const originalIndentation = indentation;
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            indentation += spacer;
            let res2 = `\n${indentation}`;
            const join3 = `,\n${indentation}`;
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp2 !== undefined ? tmp2 : "null";
              res2 += join3;
            }
            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
            res2 += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res2 += `${join3}"... ${getItemCount(removedKeys)} not stringified"`;
            }
            res2 += `\n${originalIndentation}`;
            stack.pop();
            return `[${res2}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          indentation += spacer;
          const join2 = `,\n${indentation}`;
          let res = "";
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (isTypedArrayWithEntries(value)) {
            res += stringifyTypedArray(value, join2, maximumBreadth);
            keys = keys.slice(value.length);
            maximumPropertiesToStringify -= value.length;
            separator = join2;
          }
          if (deterministic) {
            keys = insertSort(keys);
          }
          stack.push(value);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}: ${tmp}`;
              separator = join2;
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
            separator = join2;
          }
          if (separator !== "") {
            res = `\n${indentation}${res}\n${originalIndentation}`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringifySimple(key, value, stack) {
      switch (typeof value) {
        case "string":
          return strEscape(value);
        case "object": {
          if (value === null) {
            return "null";
          }
          if (typeof value.toJSON === "function") {
            value = value.toJSON(key);
            if (typeof value !== "object") {
              return stringifySimple(key, value, stack);
            }
            if (value === null) {
              return "null";
            }
          }
          if (stack.indexOf(value) !== -1) {
            return circularValue;
          }
          let res = "";
          if (Array.isArray(value)) {
            if (value.length === 0) {
              return "[]";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Array]"';
            }
            stack.push(value);
            const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
            let i = 0;
            for (;i < maximumValuesToStringify - 1; i++) {
              const tmp2 = stringifySimple(String(i), value[i], stack);
              res += tmp2 !== undefined ? tmp2 : "null";
              res += ",";
            }
            const tmp = stringifySimple(String(i), value[i], stack);
            res += tmp !== undefined ? tmp : "null";
            if (value.length - 1 > maximumBreadth) {
              const removedKeys = value.length - maximumBreadth - 1;
              res += `,"... ${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `[${res}]`;
          }
          let keys = Object.keys(value);
          const keyLength = keys.length;
          if (keyLength === 0) {
            return "{}";
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Object]"';
          }
          let separator = "";
          let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
          if (isTypedArrayWithEntries(value)) {
            res += stringifyTypedArray(value, ",", maximumBreadth);
            keys = keys.slice(value.length);
            maximumPropertiesToStringify -= value.length;
            separator = ",";
          }
          if (deterministic) {
            keys = insertSort(keys);
          }
          stack.push(value);
          for (let i = 0;i < maximumPropertiesToStringify; i++) {
            const key2 = keys[i];
            const tmp = stringifySimple(key2, value[key2], stack);
            if (tmp !== undefined) {
              res += `${separator}${strEscape(key2)}:${tmp}`;
              separator = ",";
            }
          }
          if (keyLength > maximumBreadth) {
            const removedKeys = keyLength - maximumBreadth;
            res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
          }
          stack.pop();
          return `{${res}}`;
        }
        case "number":
          return isFinite(value) ? String(value) : fail ? fail(value) : "null";
        case "boolean":
          return value === true ? "true" : "false";
        case "undefined":
          return;
        case "bigint":
          if (bigint) {
            return String(value);
          }
        default:
          return fail ? fail(value) : undefined;
      }
    }
    function stringify2(value, replacer, space) {
      if (arguments.length > 1) {
        let spacer = "";
        if (typeof space === "number") {
          spacer = " ".repeat(Math.min(space, 10));
        } else if (typeof space === "string") {
          spacer = space.slice(0, 10);
        }
        if (replacer != null) {
          if (typeof replacer === "function") {
            return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
          }
          if (Array.isArray(replacer)) {
            return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
          }
        }
        if (spacer.length !== 0) {
          return stringifyIndent("", value, [], spacer, "");
        }
      }
      return stringifySimple("", value, []);
    }
    return stringify2;
  };
  var { hasOwnProperty } = Object.prototype;
  var stringify = configure();
  stringify.configure = configure;
  stringify.stringify = stringify;
  stringify.default = stringify;
  exports.stringify = stringify;
  exports.configure = configure;
  module.exports = stringify;
  var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/;
  var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array)), Symbol.toStringTag).get;
});

// node_modules/@libsql/hrana-client/li
var require_multistream = __commonJS((exports, module) => {
  var multistream = function(streamsArray, opts) {
    let counter = 0;
    streamsArray = streamsArray || [];
    opts = opts || { dedupe: false };
    const streamLevels = Object.create(levels);
    streamLevels.silent = Infinity;
    if (opts.levels && typeof opts.levels === "object") {
      Object.keys(opts.levels).forEach((i) => {
        streamLevels[i] = opts.levels[i];
      });
    }
    const res = {
      write,
      add,
      flushSync,
      end,
      minLevel: 0,
      streams: [],
      clone,
      [metadata]: true,
      streamLevels
    };
    if (Array.isArray(streamsArray)) {
      streamsArray.forEach(add, res);
    } else {
      add.call(res, streamsArray);
    }
    streamsArray = null;
    return res;
    function write(data) {
      let dest;
      const level = this.lastLevel;
      const { streams } = this;
      let recordedLevel = 0;
      let stream2;
      for (let i = initLoopVar(streams.length, opts.dedupe);checkLoopVar(i, streams.length, opts.dedupe); i = adjustLoopVar(i, opts.dedupe)) {
        dest = streams[i];
        if (dest.level <= level) {
          if (recordedLevel !== 0 && recordedLevel !== dest.level) {
            break;
          }
          stream2 = dest.stream;
          if (stream2[metadata]) {
            const { lastTime, lastMsg, lastObj, lastLogger } = this;
            stream2.lastLevel = level;
            stream2.lastTime = lastTime;
            stream2.lastMsg = lastMsg;
            stream2.lastObj = lastObj;
            stream2.lastLogger = lastLogger;
          }
          stream2.write(data);
          if (opts.dedupe) {
            recordedLevel = dest.level;
          }
        } else if (!opts.dedupe) {
          break;
        }
      }
    }
    function flushSync() {
      for (const { stream: stream2 } of this.streams) {
        if (typeof stream2.flushSync === "function") {
          stream2.flushSync();
        }
      }
    }
    function add(dest) {
      if (!dest) {
        return res;
      }
      const isStream = typeof dest.write === "function" || dest.stream;
      const stream_ = dest.write ? dest : dest.stream;
      if (!isStream) {
        throw Error("stream object needs to implement either StreamEntry or DestinationStream interface");
      }
      const { streams, streamLevels: streamLevels2 } = this;
      let level;
      if (typeof dest.levelVal === "number") {
        level = dest.levelVal;
      } else if (typeof dest.level === "string") {
        level = streamLevels2[dest.level];
      } else if (typeof dest.level === "number") {
        level = dest.level;
      } else {
        level = DEFAULT_INFO_LEVEL;
      }
      const dest_ = {
        stream: stream_,
        level,
        levelVal: undefined,
        id: counter++
      };
      streams.unshift(dest_);
      streams.sort(compareByLevel);
      this.minLevel = streams[0].level;
      return res;
    }
    function end() {
      for (const { stream: stream2 } of this.streams) {
        if (typeof stream2.flushSync === "function") {
          stream2.flushSync();
        }
        stream2.end();
      }
    }
    function clone(level) {
      const streams = new Array(this.streams.length);
      for (let i = 0;i < streams.length; i++) {
        streams[i] = {
          level,
          stream: this.streams[i].stream
        };
      }
      return {
        write,
        add,
        minLevel: level,
        streams,
        clone,
        flushSync,
        [metadata]: true
      };
    }
  };
  var compareByLevel = function(a, b) {
    return a.level - b.level;
  };
  var initLoopVar = function(length, dedupe) {
    return dedupe ? length - 1 : 0;
  };
  var adjustLoopVar = function(i, dedupe) {
    return dedupe ? i - 1 : i + 1;
  };
  var checkLoopVar = function(i, length, dedupe) {
    return dedupe ? i >= 0 : i < length;
  };
  var metadata = Symbol.for("pino.metadata");
  var { levels } = require_levels();
  var DEFAULT_INFO_LEVEL = levels.info;
  module.exports = multistream;
});

// node_modules/@libsql/hran
var require_pino = __commonJS((exports, module) => {
  var pino = function(...args2) {
    const instance = {};
    const { opts, stream: stream2 } = normalize(instance, caller(), ...args2);
    const {
      redact,
      crlf,
      serializers: serializers2,
      timestamp,
      messageKey,
      errorKey,
      nestedKey,
      base,
      name,
      level,
      customLevels,
      mixin,
      mixinMergeStrategy,
      useOnlyCustomLevels,
      formatters,
      hooks,
      depthLimit,
      edgeLimit,
      onChild,
      msgPrefix
    } = opts;
    const stringifySafe = configure({
      maximumDepth: depthLimit,
      maximumBreadth: edgeLimit
    });
    const allFormatters = buildFormatters(formatters.level, formatters.bindings, formatters.log);
    const stringifyFn = stringify.bind({
      [stringifySafeSym]: stringifySafe
    });
    const stringifiers = redact ? redaction(redact, stringifyFn) : {};
    const formatOpts = redact ? { stringify: stringifiers[redactFmtSym] } : { stringify: stringifyFn };
    const end = "}" + (crlf ? "\r\n" : "\n");
    const coreChindings = asChindings.bind(null, {
      [chindingsSym]: "",
      [serializersSym]: serializers2,
      [stringifiersSym]: stringifiers,
      [stringifySym]: stringify,
      [stringifySafeSym]: stringifySafe,
      [formattersSym]: allFormatters
    });
    let chindings = "";
    if (base !== null) {
      if (name === undefined) {
        chindings = coreChindings(base);
      } else {
        chindings = coreChindings(Object.assign({}, base, { name }));
      }
    }
    const time2 = timestamp instanceof Function ? timestamp : timestamp ? epochTime : nullTime;
    const timeSliceIndex = time2().indexOf(":") + 1;
    if (useOnlyCustomLevels && !customLevels)
      throw Error("customLevels is required if useOnlyCustomLevels is set true");
    if (mixin && typeof mixin !== "function")
      throw Error(`Unknown mixin type "${typeof mixin}" - expected "function"`);
    if (msgPrefix && typeof msgPrefix !== "string")
      throw Error(`Unknown msgPrefix type "${typeof msgPrefix}" - expected "string"`);
    assertDefaultLevelFound(level, customLevels, useOnlyCustomLevels);
    const levels2 = mappings(customLevels, useOnlyCustomLevels);
    Object.assign(instance, {
      levels: levels2,
      [useOnlyCustomLevelsSym]: useOnlyCustomLevels,
      [streamSym]: stream2,
      [timeSym]: time2,
      [timeSliceIndexSym]: timeSliceIndex,
      [stringifySym]: stringify,
      [stringifySafeSym]: stringifySafe,
      [stringifiersSym]: stringifiers,
      [endSym]: end,
      [formatOptsSym]: formatOpts,
      [messageKeySym]: messageKey,
      [errorKeySym]: errorKey,
      [nestedKeySym]: nestedKey,
      [nestedKeyStrSym]: nestedKey ? `,${JSON.stringify(nestedKey)}:{` : "",
      [serializersSym]: serializers2,
      [mixinSym]: mixin,
      [mixinMergeStrategySym]: mixinMergeStrategy,
      [chindingsSym]: chindings,
      [formattersSym]: allFormatters,
      [hooksSym]: hooks,
      silent: noop,
      onChild,
      [msgPrefixSym]: msgPrefix
    });
    Object.setPrototypeOf(instance, proto());
    genLsCache(instance);
    instance[setLevelSym](level);
    return instance;
  };
  var os = import.meta.require("os");
  var stdSerializers = require_pino_std_serializers();
  var caller = require_caller();
  var redaction = require_redaction();
  var time = require_time();
  var proto = require_proto();
  var symbols = require_symbols();
  var { configure } = require_safe_stable_stringify();
  var { assertDefaultLevelFound, mappings, genLsCache, levels } = require_levels();
  var {
    createArgsNormalizer,
    asChindings,
    buildSafeSonicBoom,
    buildFormatters,
    stringify,
    normalizeDestFileDescriptor,
    noop
  } = require_tools();
  var { version } = require_meta();
  var {
    chindingsSym,
    redactFmtSym,
    serializersSym,
    timeSym,
    timeSliceIndexSym,
    streamSym,
    stringifySym,
    stringifySafeSym,
    stringifiersSym,
    setLevelSym,
    endSym,
    formatOptsSym,
    messageKeySym,
    errorKeySym,
    nestedKeySym,
    mixinSym,
    useOnlyCustomLevelsSym,
    formattersSym,
    hooksSym,
    nestedKeyStrSym,
    mixinMergeStrategySym,
    msgPrefixSym
  } = symbols;
  var { epochTime, nullTime } = time;
  var { pid } = process;
  var hostname = os.hostname();
  var defaultErrorSerializer = stdSerializers.err;
  var defaultOptions = {
    level: "info",
    levels,
    messageKey: "msg",
    errorKey: "err",
    nestedKey: null,
    enabled: true,
    base: { pid, hostname },
    serializers: Object.assign(Object.create(null), {
      err: defaultErrorSerializer
    }),
    formatters: Object.assign(Object.create(null), {
      bindings(bindings) {
        return bindings;
      },
      level(label, number) {
        return { level: number };
      }
    }),
    hooks: {
      logMethod: undefined
    },
    timestamp: epochTime,
    name: undefined,
    redact: null,
    customLevels: null,
    useOnlyCustomLevels: false,
    depthLimit: 5,
    edgeLimit: 100
  };
  var normalize = createArgsNormalizer(defaultOptions);
  var serializers = Object.assign(Object.create(null), stdSerializers);
  module.exports = pino;
  module.exports.destination = (dest = process.stdout.fd) => {
    if (typeof dest === "object") {
      dest.dest = normalizeDestFileDescriptor(dest.dest || process.stdout.fd);
      return buildSafeSonicBoom(dest);
    } else {
      return buildSafeSonicBoom({ dest: normalizeDestFileDescriptor(dest), minLength: 0 });
    }
  };
  module.exports.transport = require_transport();
  module.exports.multistream = require_multistream();
  module.exports.levels = mappings();
  module.exports.stdSerializers = serializers;
  module.exports.stdTimeFunctions = Object.assign({}, time);
  module.exports.symbols = symbols;
  module.exports.version = version;
  module.exports.default = pino;
  module.exports.pino = pino;
});

// node_modules/@libsql/hrana-client/lib-esm
var require_typebox = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Type = exports.JsonType = exports.JavaScriptTypeBuilder = exports.JsonTypeBuilder = exports.TypeBuilder = exports.TypeBuilderError = exports.TransformEncodeBuilder = exports.TransformDecodeBuilder = exports.TemplateLiteralDslParser = exports.TemplateLiteralGenerator = exports.TemplateLiteralGeneratorError = exports.TemplateLiteralFinite = exports.TemplateLiteralFiniteError = exports.TemplateLiteralParser = exports.TemplateLiteralParserError = exports.TemplateLiteralResolver = exports.TemplateLiteralPattern = exports.TemplateLiteralPatternError = exports.UnionResolver = exports.KeyArrayResolver = exports.KeyArrayResolverError = exports.KeyResolver = exports.ObjectMap = exports.Intrinsic = exports.IndexedAccessor = exports.TypeClone = exports.TypeExtends = exports.TypeExtendsResult = exports.TypeExtendsError = exports.ExtendsUndefined = exports.TypeGuard = exports.TypeGuardUnknownTypeError = exports.ValueGuard = exports.FormatRegistry = exports.TypeBoxError = exports.TypeRegistry = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = exports.Kind = exports.Hint = exports.Optional = exports.Readonly = exports.Transform = undefined;
  exports.Transform = Symbol.for("TypeBox.Transform");
  exports.Readonly = Symbol.for("TypeBox.Readonly");
  exports.Optional = Symbol.for("TypeBox.Optional");
  exports.Hint = Symbol.for("TypeBox.Hint");
  exports.Kind = Symbol.for("TypeBox.Kind");
  exports.PatternBoolean = "(true|false)";
  exports.PatternNumber = "(0|[1-9][0-9]*)";
  exports.PatternString = "(.*)";
  exports.PatternBooleanExact = `^${exports.PatternBoolean}\$`;
  exports.PatternNumberExact = `^${exports.PatternNumber}\$`;
  exports.PatternStringExact = `^${exports.PatternString}\$`;
  var TypeRegistry;
  (function(TypeRegistry2) {
    const map = new Map;
    function Entries() {
      return new Map(map);
    }
    TypeRegistry2.Entries = Entries;
    function Clear() {
      return map.clear();
    }
    TypeRegistry2.Clear = Clear;
    function Delete(kind) {
      return map.delete(kind);
    }
    TypeRegistry2.Delete = Delete;
    function Has(kind) {
      return map.has(kind);
    }
    TypeRegistry2.Has = Has;
    function Set2(kind, func) {
      map.set(kind, func);
    }
    TypeRegistry2.Set = Set2;
    function Get(kind) {
      return map.get(kind);
    }
    TypeRegistry2.Get = Get;
  })(TypeRegistry || (exports.TypeRegistry = TypeRegistry = {}));

  class TypeBoxError extends Error {
    constructor(message) {
      super(message);
    }
  }
  exports.TypeBoxError = TypeBoxError;
  var FormatRegistry;
  (function(FormatRegistry2) {
    const map = new Map;
    function Entries() {
      return new Map(map);
    }
    FormatRegistry2.Entries = Entries;
    function Clear() {
      return map.clear();
    }
    FormatRegistry2.Clear = Clear;
    function Delete(format2) {
      return map.delete(format2);
    }
    FormatRegistry2.Delete = Delete;
    function Has(format2) {
      return map.has(format2);
    }
    FormatRegistry2.Has = Has;
    function Set2(format2, func) {
      map.set(format2, func);
    }
    FormatRegistry2.Set = Set2;
    function Get(format2) {
      return map.get(format2);
    }
    FormatRegistry2.Get = Get;
  })(FormatRegistry || (exports.FormatRegistry = FormatRegistry = {}));
  var ValueGuard;
  (function(ValueGuard2) {
    function IsArray(value) {
      return Array.isArray(value);
    }
    ValueGuard2.IsArray = IsArray;
    function IsBigInt(value) {
      return typeof value === "bigint";
    }
    ValueGuard2.IsBigInt = IsBigInt;
    function IsBoolean(value) {
      return typeof value === "boolean";
    }
    ValueGuard2.IsBoolean = IsBoolean;
    function IsNull(value) {
      return value === null;
    }
    ValueGuard2.IsNull = IsNull;
    function IsNumber(value) {
      return typeof value === "number";
    }
    ValueGuard2.IsNumber = IsNumber;
    function IsObject(value) {
      return typeof value === "object" && value !== null;
    }
    ValueGuard2.IsObject = IsObject;
    function IsString(value) {
      return typeof value === "string";
    }
    ValueGuard2.IsString = IsString;
    function IsUndefined(value) {
      return value === undefined;
    }
    ValueGuard2.IsUndefined = IsUndefined;
  })(ValueGuard || (exports.ValueGuard = ValueGuard = {}));

  class TypeGuardUnknownTypeError extends TypeBoxError {
  }
  exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
  var TypeGuard;
  (function(TypeGuard2) {
    function IsPattern(value) {
      try {
        new RegExp(value);
        return true;
      } catch {
        return false;
      }
    }
    function IsControlCharacterFree(value) {
      if (!ValueGuard.IsString(value))
        return false;
      for (let i = 0;i < value.length; i++) {
        const code = value.charCodeAt(i);
        if (code >= 7 && code <= 13 || code === 27 || code === 127) {
          return false;
        }
      }
      return true;
    }
    function IsAdditionalProperties(value) {
      return IsOptionalBoolean(value) || TSchema(value);
    }
    function IsOptionalBigInt(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
    }
    function IsOptionalNumber(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
    }
    function IsOptionalBoolean(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
    }
    function IsOptionalString(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
    }
    function IsOptionalPattern(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
    }
    function IsOptionalFormat(value) {
      return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value);
    }
    function IsOptionalSchema(value) {
      return ValueGuard.IsUndefined(value) || TSchema(value);
    }
    function TAny(schema) {
      return TKindOf(schema, "Any") && IsOptionalString(schema.$id);
    }
    TypeGuard2.TAny = TAny;
    function TArray(schema) {
      return TKindOf(schema, "Array") && schema.type === "array" && IsOptionalString(schema.$id) && TSchema(schema.items) && IsOptionalNumber(schema.minItems) && IsOptionalNumber(schema.maxItems) && IsOptionalBoolean(schema.uniqueItems) && IsOptionalSchema(schema.contains) && IsOptionalNumber(schema.minContains) && IsOptionalNumber(schema.maxContains);
    }
    TypeGuard2.TArray = TArray;
    function TAsyncIterator(schema) {
      return TKindOf(schema, "AsyncIterator") && schema.type === "AsyncIterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
    }
    TypeGuard2.TAsyncIterator = TAsyncIterator;
    function TBigInt(schema) {
      return TKindOf(schema, "BigInt") && schema.type === "bigint" && IsOptionalString(schema.$id) && IsOptionalBigInt(schema.exclusiveMaximum) && IsOptionalBigInt(schema.exclusiveMinimum) && IsOptionalBigInt(schema.maximum) && IsOptionalBigInt(schema.minimum) && IsOptionalBigInt(schema.multipleOf);
    }
    TypeGuard2.TBigInt = TBigInt;
    function TBoolean(schema) {
      return TKindOf(schema, "Boolean") && schema.type === "boolean" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TBoolean = TBoolean;
    function TConstructor(schema) {
      return TKindOf(schema, "Constructor") && schema.type === "Constructor" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every((schema2) => TSchema(schema2)) && TSchema(schema.returns);
    }
    TypeGuard2.TConstructor = TConstructor;
    function TDate(schema) {
      return TKindOf(schema, "Date") && schema.type === "Date" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximumTimestamp) && IsOptionalNumber(schema.exclusiveMinimumTimestamp) && IsOptionalNumber(schema.maximumTimestamp) && IsOptionalNumber(schema.minimumTimestamp) && IsOptionalNumber(schema.multipleOfTimestamp);
    }
    TypeGuard2.TDate = TDate;
    function TFunction(schema) {
      return TKindOf(schema, "Function") && schema.type === "Function" && IsOptionalString(schema.$id) && ValueGuard.IsArray(schema.parameters) && schema.parameters.every((schema2) => TSchema(schema2)) && TSchema(schema.returns);
    }
    TypeGuard2.TFunction = TFunction;
    function TInteger(schema) {
      return TKindOf(schema, "Integer") && schema.type === "integer" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);
    }
    TypeGuard2.TInteger = TInteger;
    function TIntersect(schema) {
      return TKindOf(schema, "Intersect") && (ValueGuard.IsString(schema.type) && schema.type !== "object" ? false : true) && ValueGuard.IsArray(schema.allOf) && schema.allOf.every((schema2) => TSchema(schema2) && !TTransform(schema2)) && IsOptionalString(schema.type) && (IsOptionalBoolean(schema.unevaluatedProperties) || IsOptionalSchema(schema.unevaluatedProperties)) && IsOptionalString(schema.$id);
    }
    TypeGuard2.TIntersect = TIntersect;
    function TIterator(schema) {
      return TKindOf(schema, "Iterator") && schema.type === "Iterator" && IsOptionalString(schema.$id) && TSchema(schema.items);
    }
    TypeGuard2.TIterator = TIterator;
    function TKindOf(schema, kind) {
      return TKind(schema) && schema[exports.Kind] === kind;
    }
    TypeGuard2.TKindOf = TKindOf;
    function TKind(schema) {
      return ValueGuard.IsObject(schema) && (exports.Kind in schema) && ValueGuard.IsString(schema[exports.Kind]);
    }
    TypeGuard2.TKind = TKind;
    function TLiteralString(schema) {
      return TLiteral(schema) && ValueGuard.IsString(schema.const);
    }
    TypeGuard2.TLiteralString = TLiteralString;
    function TLiteralNumber(schema) {
      return TLiteral(schema) && ValueGuard.IsNumber(schema.const);
    }
    TypeGuard2.TLiteralNumber = TLiteralNumber;
    function TLiteralBoolean(schema) {
      return TLiteral(schema) && ValueGuard.IsBoolean(schema.const);
    }
    TypeGuard2.TLiteralBoolean = TLiteralBoolean;
    function TLiteral(schema) {
      return TKindOf(schema, "Literal") && IsOptionalString(schema.$id) && (ValueGuard.IsBoolean(schema.const) || ValueGuard.IsNumber(schema.const) || ValueGuard.IsString(schema.const));
    }
    TypeGuard2.TLiteral = TLiteral;
    function TNever(schema) {
      return TKindOf(schema, "Never") && ValueGuard.IsObject(schema.not) && Object.getOwnPropertyNames(schema.not).length === 0;
    }
    TypeGuard2.TNever = TNever;
    function TNot(schema) {
      return TKindOf(schema, "Not") && TSchema(schema.not);
    }
    TypeGuard2.TNot = TNot;
    function TNull(schema) {
      return TKindOf(schema, "Null") && schema.type === "null" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TNull = TNull;
    function TNumber(schema) {
      return TKindOf(schema, "Number") && schema.type === "number" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.exclusiveMaximum) && IsOptionalNumber(schema.exclusiveMinimum) && IsOptionalNumber(schema.maximum) && IsOptionalNumber(schema.minimum) && IsOptionalNumber(schema.multipleOf);
    }
    TypeGuard2.TNumber = TNumber;
    function TObject(schema) {
      return TKindOf(schema, "Object") && schema.type === "object" && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema.properties) && IsAdditionalProperties(schema.additionalProperties) && IsOptionalNumber(schema.minProperties) && IsOptionalNumber(schema.maxProperties) && Object.entries(schema.properties).every(([key, schema2]) => IsControlCharacterFree(key) && TSchema(schema2));
    }
    TypeGuard2.TObject = TObject;
    function TPromise(schema) {
      return TKindOf(schema, "Promise") && schema.type === "Promise" && IsOptionalString(schema.$id) && TSchema(schema.item);
    }
    TypeGuard2.TPromise = TPromise;
    function TRecord(schema) {
      return TKindOf(schema, "Record") && schema.type === "object" && IsOptionalString(schema.$id) && IsAdditionalProperties(schema.additionalProperties) && ValueGuard.IsObject(schema.patternProperties) && ((schema2) => {
        const keys = Object.getOwnPropertyNames(schema2.patternProperties);
        return keys.length === 1 && IsPattern(keys[0]) && ValueGuard.IsObject(schema2.patternProperties) && TSchema(schema2.patternProperties[keys[0]]);
      })(schema);
    }
    TypeGuard2.TRecord = TRecord;
    function TRecursive(schema) {
      return ValueGuard.IsObject(schema) && (exports.Hint in schema) && schema[exports.Hint] === "Recursive";
    }
    TypeGuard2.TRecursive = TRecursive;
    function TRef(schema) {
      return TKindOf(schema, "Ref") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
    }
    TypeGuard2.TRef = TRef;
    function TString(schema) {
      return TKindOf(schema, "String") && schema.type === "string" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minLength) && IsOptionalNumber(schema.maxLength) && IsOptionalPattern(schema.pattern) && IsOptionalFormat(schema.format);
    }
    TypeGuard2.TString = TString;
    function TSymbol(schema) {
      return TKindOf(schema, "Symbol") && schema.type === "symbol" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TSymbol = TSymbol;
    function TTemplateLiteral(schema) {
      return TKindOf(schema, "TemplateLiteral") && schema.type === "string" && ValueGuard.IsString(schema.pattern) && schema.pattern[0] === "^" && schema.pattern[schema.pattern.length - 1] === "$";
    }
    TypeGuard2.TTemplateLiteral = TTemplateLiteral;
    function TThis(schema) {
      return TKindOf(schema, "This") && IsOptionalString(schema.$id) && ValueGuard.IsString(schema.$ref);
    }
    TypeGuard2.TThis = TThis;
    function TTransform(schema) {
      return ValueGuard.IsObject(schema) && (exports.Transform in schema);
    }
    TypeGuard2.TTransform = TTransform;
    function TTuple(schema) {
      return TKindOf(schema, "Tuple") && schema.type === "array" && IsOptionalString(schema.$id) && ValueGuard.IsNumber(schema.minItems) && ValueGuard.IsNumber(schema.maxItems) && schema.minItems === schema.maxItems && (ValueGuard.IsUndefined(schema.items) && ValueGuard.IsUndefined(schema.additionalItems) && schema.minItems === 0 || ValueGuard.IsArray(schema.items) && schema.items.every((schema2) => TSchema(schema2)));
    }
    TypeGuard2.TTuple = TTuple;
    function TUndefined(schema) {
      return TKindOf(schema, "Undefined") && schema.type === "undefined" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TUndefined = TUndefined;
    function TUnionLiteral(schema) {
      return TUnion(schema) && schema.anyOf.every((schema2) => TLiteralString(schema2) || TLiteralNumber(schema2));
    }
    TypeGuard2.TUnionLiteral = TUnionLiteral;
    function TUnion(schema) {
      return TKindOf(schema, "Union") && IsOptionalString(schema.$id) && ValueGuard.IsObject(schema) && ValueGuard.IsArray(schema.anyOf) && schema.anyOf.every((schema2) => TSchema(schema2));
    }
    TypeGuard2.TUnion = TUnion;
    function TUint8Array(schema) {
      return TKindOf(schema, "Uint8Array") && schema.type === "Uint8Array" && IsOptionalString(schema.$id) && IsOptionalNumber(schema.minByteLength) && IsOptionalNumber(schema.maxByteLength);
    }
    TypeGuard2.TUint8Array = TUint8Array;
    function TUnknown(schema) {
      return TKindOf(schema, "Unknown") && IsOptionalString(schema.$id);
    }
    TypeGuard2.TUnknown = TUnknown;
    function TUnsafe(schema) {
      return TKindOf(schema, "Unsafe");
    }
    TypeGuard2.TUnsafe = TUnsafe;
    function TVoid(schema) {
      return TKindOf(schema, "Void") && schema.type === "void" && IsOptionalString(schema.$id);
    }
    TypeGuard2.TVoid = TVoid;
    function TReadonly(schema) {
      return ValueGuard.IsObject(schema) && schema[exports.Readonly] === "Readonly";
    }
    TypeGuard2.TReadonly = TReadonly;
    function TOptional(schema) {
      return ValueGuard.IsObject(schema) && schema[exports.Optional] === "Optional";
    }
    TypeGuard2.TOptional = TOptional;
    function TSchema(schema) {
      return ValueGuard.IsObject(schema) && (TAny(schema) || TArray(schema) || TBoolean(schema) || TBigInt(schema) || TAsyncIterator(schema) || TConstructor(schema) || TDate(schema) || TFunction(schema) || TInteger(schema) || TIntersect(schema) || TIterator(schema) || TLiteral(schema) || TNever(schema) || TNot(schema) || TNull(schema) || TNumber(schema) || TObject(schema) || TPromise(schema) || TRecord(schema) || TRef(schema) || TString(schema) || TSymbol(schema) || TTemplateLiteral(schema) || TThis(schema) || TTuple(schema) || TUndefined(schema) || TUnion(schema) || TUint8Array(schema) || TUnknown(schema) || TUnsafe(schema) || TVoid(schema) || TKind(schema) && TypeRegistry.Has(schema[exports.Kind]));
    }
    TypeGuard2.TSchema = TSchema;
  })(TypeGuard || (exports.TypeGuard = TypeGuard = {}));
  var ExtendsUndefined;
  (function(ExtendsUndefined2) {
    function Check(schema) {
      return schema[exports.Kind] === "Intersect" ? schema.allOf.every((schema2) => Check(schema2)) : schema[exports.Kind] === "Union" ? schema.anyOf.some((schema2) => Check(schema2)) : schema[exports.Kind] === "Undefined" ? true : schema[exports.Kind] === "Not" ? !Check(schema.not) : false;
    }
    ExtendsUndefined2.Check = Check;
  })(ExtendsUndefined || (exports.ExtendsUndefined = ExtendsUndefined = {}));

  class TypeExtendsError extends TypeBoxError {
  }
  exports.TypeExtendsError = TypeExtendsError;
  var TypeExtendsResult;
  (function(TypeExtendsResult2) {
    TypeExtendsResult2[TypeExtendsResult2["Union"] = 0] = "Union";
    TypeExtendsResult2[TypeExtendsResult2["True"] = 1] = "True";
    TypeExtendsResult2[TypeExtendsResult2["False"] = 2] = "False";
  })(TypeExtendsResult || (exports.TypeExtendsResult = TypeExtendsResult = {}));
  var TypeExtends;
  (function(TypeExtends2) {
    function IntoBooleanResult(result) {
      return result === TypeExtendsResult.False ? result : TypeExtendsResult.True;
    }
    function Throw(message) {
      throw new TypeExtendsError(message);
    }
    function IsStructuralRight(right) {
      return TypeGuard.TNever(right) || TypeGuard.TIntersect(right) || TypeGuard.TUnion(right) || TypeGuard.TUnknown(right) || TypeGuard.TAny(right);
    }
    function StructuralRight(left, right) {
      return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : Throw("StructuralRight");
    }
    function TAnyRight(left, right) {
      return TypeExtendsResult.True;
    }
    function TAny(left, right) {
      return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) && right.anyOf.some((schema) => TypeGuard.TAny(schema) || TypeGuard.TUnknown(schema)) ? TypeExtendsResult.True : TypeGuard.TUnion(right) ? TypeExtendsResult.Union : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeGuard.TAny(right) ? TypeExtendsResult.True : TypeExtendsResult.Union;
    }
    function TArrayRight(left, right) {
      return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TArray(left, right) {
      return TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TArray(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
    }
    function TAsyncIterator(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TAsyncIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
    }
    function TBigInt(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBigInt(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TBooleanRight(left, right) {
      return TypeGuard.TLiteral(left) && ValueGuard.IsBoolean(left.const) ? TypeExtendsResult.True : TypeGuard.TBoolean(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TBoolean(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TBoolean(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TConstructor(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TConstructor(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
    }
    function TDate(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TDate(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TFunction(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TFunction(right) ? TypeExtendsResult.False : left.parameters.length > right.parameters.length ? TypeExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === TypeExtendsResult.True) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
    }
    function TIntegerRight(left, right) {
      return TypeGuard.TLiteral(left) && ValueGuard.IsNumber(left.const) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TInteger(left, right) {
      return TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeExtendsResult.False;
    }
    function TIntersectRight(left, right) {
      return right.allOf.every((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TIntersect(left, right) {
      return left.allOf.some((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TIterator(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : !TypeGuard.TIterator(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
    }
    function TLiteral(left, right) {
      return TypeGuard.TLiteral(right) && right.const === left.const ? TypeExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeExtendsResult.False;
    }
    function TNeverRight(left, right) {
      return TypeExtendsResult.False;
    }
    function TNever(left, right) {
      return TypeExtendsResult.True;
    }
    function UnwrapTNot(schema) {
      let [current, depth] = [schema, 0];
      while (true) {
        if (!TypeGuard.TNot(current))
          break;
        current = current.not;
        depth += 1;
      }
      return depth % 2 === 0 ? current : exports.Type.Unknown();
    }
    function TNot(left, right) {
      return TypeGuard.TNot(left) ? Visit(UnwrapTNot(left), right) : TypeGuard.TNot(right) ? Visit(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
    }
    function TNull(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TNull(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TNumberRight(left, right) {
      return TypeGuard.TLiteralNumber(left) ? TypeExtendsResult.True : TypeGuard.TNumber(left) || TypeGuard.TInteger(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TNumber(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TInteger(right) || TypeGuard.TNumber(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function IsObjectPropertyCount(schema, count) {
      return Object.getOwnPropertyNames(schema.properties).length === count;
    }
    function IsObjectStringLike(schema) {
      return IsObjectArrayLike(schema);
    }
    function IsObjectSymbolLike(schema) {
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && ("description" in schema.properties) && TypeGuard.TUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (TypeGuard.TString(schema.properties.description.anyOf[0]) && TypeGuard.TUndefined(schema.properties.description.anyOf[1]) || TypeGuard.TString(schema.properties.description.anyOf[1]) && TypeGuard.TUndefined(schema.properties.description.anyOf[0]));
    }
    function IsObjectNumberLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectBooleanLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectBigIntLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectDateLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectUint8ArrayLike(schema) {
      return IsObjectArrayLike(schema);
    }
    function IsObjectFunctionLike(schema) {
      const length = exports.Type.Number();
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && ("length" in schema.properties) && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
    }
    function IsObjectConstructorLike(schema) {
      return IsObjectPropertyCount(schema, 0);
    }
    function IsObjectArrayLike(schema) {
      const length = exports.Type.Number();
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && ("length" in schema.properties) && IntoBooleanResult(Visit(schema.properties["length"], length)) === TypeExtendsResult.True;
    }
    function IsObjectPromiseLike(schema) {
      const then = exports.Type.Function([exports.Type.Any()], exports.Type.Any());
      return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && ("then" in schema.properties) && IntoBooleanResult(Visit(schema.properties["then"], then)) === TypeExtendsResult.True;
    }
    function Property(left, right) {
      return Visit(left, right) === TypeExtendsResult.False ? TypeExtendsResult.False : TypeGuard.TOptional(left) && !TypeGuard.TOptional(right) ? TypeExtendsResult.False : TypeExtendsResult.True;
    }
    function TObjectRight(left, right) {
      return TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeGuard.TNever(left) || TypeGuard.TLiteralString(left) && IsObjectStringLike(right) || TypeGuard.TLiteralNumber(left) && IsObjectNumberLike(right) || TypeGuard.TLiteralBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TBigInt(left) && IsObjectBigIntLike(right) || TypeGuard.TString(left) && IsObjectStringLike(right) || TypeGuard.TSymbol(left) && IsObjectSymbolLike(right) || TypeGuard.TNumber(left) && IsObjectNumberLike(right) || TypeGuard.TInteger(left) && IsObjectNumberLike(right) || TypeGuard.TBoolean(left) && IsObjectBooleanLike(right) || TypeGuard.TUint8Array(left) && IsObjectUint8ArrayLike(right) || TypeGuard.TDate(left) && IsObjectDateLike(right) || TypeGuard.TConstructor(left) && IsObjectConstructorLike(right) || TypeGuard.TFunction(left) && IsObjectFunctionLike(right) ? TypeExtendsResult.True : TypeGuard.TRecord(left) && TypeGuard.TString(RecordKey(left)) ? (() => {
        return right[exports.Hint] === "Record" ? TypeExtendsResult.True : TypeExtendsResult.False;
      })() : TypeGuard.TRecord(left) && TypeGuard.TNumber(RecordKey(left)) ? (() => {
        return IsObjectPropertyCount(right, 0) ? TypeExtendsResult.True : TypeExtendsResult.False;
      })() : TypeExtendsResult.False;
    }
    function TObject(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : !TypeGuard.TObject(right) ? TypeExtendsResult.False : (() => {
        for (const key of Object.getOwnPropertyNames(right.properties)) {
          if (!(key in left.properties))
            return TypeExtendsResult.False;
          if (Property(left.properties[key], right.properties[key]) === TypeExtendsResult.False) {
            return TypeExtendsResult.False;
          }
        }
        return TypeExtendsResult.True;
      })();
    }
    function TPromise(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectPromiseLike(right) ? TypeExtendsResult.True : !TypeGuard.TPromise(right) ? TypeExtendsResult.False : IntoBooleanResult(Visit(left.item, right.item));
    }
    function RecordKey(schema) {
      return exports.PatternNumberExact in schema.patternProperties ? exports.Type.Number() : (exports.PatternStringExact in schema.patternProperties) ? exports.Type.String() : Throw("Unknown record key pattern");
    }
    function RecordValue(schema) {
      return exports.PatternNumberExact in schema.patternProperties ? schema.patternProperties[exports.PatternNumberExact] : (exports.PatternStringExact in schema.patternProperties) ? schema.patternProperties[exports.PatternStringExact] : Throw("Unable to get record value schema");
    }
    function TRecordRight(left, right) {
      const [Key, Value] = [RecordKey(right), RecordValue(right)];
      return TypeGuard.TLiteralString(left) && TypeGuard.TNumber(Key) && IntoBooleanResult(Visit(left, Value)) === TypeExtendsResult.True ? TypeExtendsResult.True : TypeGuard.TUint8Array(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TString(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TArray(left) && TypeGuard.TNumber(Key) ? Visit(left, Value) : TypeGuard.TObject(left) ? (() => {
        for (const key of Object.getOwnPropertyNames(left.properties)) {
          if (Property(Value, left.properties[key]) === TypeExtendsResult.False) {
            return TypeExtendsResult.False;
          }
        }
        return TypeExtendsResult.True;
      })() : TypeExtendsResult.False;
    }
    function TRecord(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : !TypeGuard.TRecord(right) ? TypeExtendsResult.False : Visit(RecordValue(left), RecordValue(right));
    }
    function TStringRight(left, right) {
      return TypeGuard.TLiteral(left) && ValueGuard.IsString(left.const) ? TypeExtendsResult.True : TypeGuard.TString(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TString(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TString(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TSymbol(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TSymbol(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TTemplateLiteral(left, right) {
      return TypeGuard.TTemplateLiteral(left) ? Visit(TemplateLiteralResolver.Resolve(left), right) : TypeGuard.TTemplateLiteral(right) ? Visit(left, TemplateLiteralResolver.Resolve(right)) : Throw("Invalid fallthrough for TemplateLiteral");
    }
    function IsArrayOfTuple(left, right) {
      return TypeGuard.TArray(right) && left.items !== undefined && left.items.every((schema) => Visit(schema, right.items) === TypeExtendsResult.True);
    }
    function TTupleRight(left, right) {
      return TypeGuard.TNever(left) ? TypeExtendsResult.True : TypeGuard.TUnknown(left) ? TypeExtendsResult.False : TypeGuard.TAny(left) ? TypeExtendsResult.Union : TypeExtendsResult.False;
    }
    function TTuple(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) && IsObjectArrayLike(right) ? TypeExtendsResult.True : TypeGuard.TArray(right) && IsArrayOfTuple(left, right) ? TypeExtendsResult.True : !TypeGuard.TTuple(right) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) || !ValueGuard.IsUndefined(left.items) && ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.False : ValueGuard.IsUndefined(left.items) && !ValueGuard.IsUndefined(right.items) ? TypeExtendsResult.True : left.items.every((schema, index) => Visit(schema, right.items[index]) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUint8Array(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TUint8Array(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUndefined(left, right) {
      return IsStructuralRight(right) ? StructuralRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TRecord(right) ? TRecordRight(left, right) : TypeGuard.TVoid(right) ? VoidRight(left, right) : TypeGuard.TUndefined(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUnionRight(left, right) {
      return right.anyOf.some((schema) => Visit(left, schema) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUnion(left, right) {
      return left.anyOf.every((schema) => Visit(schema, right) === TypeExtendsResult.True) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TUnknownRight(left, right) {
      return TypeExtendsResult.True;
    }
    function TUnknown(left, right) {
      return TypeGuard.TNever(right) ? TNeverRight(left, right) : TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TString(right) ? TStringRight(left, right) : TypeGuard.TNumber(right) ? TNumberRight(left, right) : TypeGuard.TInteger(right) ? TIntegerRight(left, right) : TypeGuard.TBoolean(right) ? TBooleanRight(left, right) : TypeGuard.TArray(right) ? TArrayRight(left, right) : TypeGuard.TTuple(right) ? TTupleRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TUnknown(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function VoidRight(left, right) {
      return TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeGuard.TUndefined(left) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function TVoid(left, right) {
      return TypeGuard.TIntersect(right) ? TIntersectRight(left, right) : TypeGuard.TUnion(right) ? TUnionRight(left, right) : TypeGuard.TUnknown(right) ? TUnknownRight(left, right) : TypeGuard.TAny(right) ? TAnyRight(left, right) : TypeGuard.TObject(right) ? TObjectRight(left, right) : TypeGuard.TVoid(right) ? TypeExtendsResult.True : TypeExtendsResult.False;
    }
    function Visit(left, right) {
      return TypeGuard.TTemplateLiteral(left) || TypeGuard.TTemplateLiteral(right) ? TTemplateLiteral(left, right) : TypeGuard.TNot(left) || TypeGuard.TNot(right) ? TNot(left, right) : TypeGuard.TAny(left) ? TAny(left, right) : TypeGuard.TArray(left) ? TArray(left, right) : TypeGuard.TBigInt(left) ? TBigInt(left, right) : TypeGuard.TBoolean(left) ? TBoolean(left, right) : TypeGuard.TAsyncIterator(left) ? TAsyncIterator(left, right) : TypeGuard.TConstructor(left) ? TConstructor(left, right) : TypeGuard.TDate(left) ? TDate(left, right) : TypeGuard.TFunction(left) ? TFunction(left, right) : TypeGuard.TInteger(left) ? TInteger(left, right) : TypeGuard.TIntersect(left) ? TIntersect(left, right) : TypeGuard.TIterator(left) ? TIterator(left, right) : TypeGuard.TLiteral(left) ? TLiteral(left, right) : TypeGuard.TNever(left) ? TNever(left, right) : TypeGuard.TNull(left) ? TNull(left, right) : TypeGuard.TNumber(left) ? TNumber(left, right) : TypeGuard.TObject(left) ? TObject(left, right) : TypeGuard.TRecord(left) ? TRecord(left, right) : TypeGuard.TString(left) ? TString(left, right) : TypeGuard.TSymbol(left) ? TSymbol(left, right) : TypeGuard.TTuple(left) ? TTuple(left, right) : TypeGuard.TPromise(left) ? TPromise(left, right) : TypeGuard.TUint8Array(left) ? TUint8Array(left, right) : TypeGuard.TUndefined(left) ? TUndefined(left, right) : TypeGuard.TUnion(left) ? TUnion(left, right) : TypeGuard.TUnknown(left) ? TUnknown(left, right) : TypeGuard.TVoid(left) ? TVoid(left, right) : Throw(`Unknown left type operand '${left[exports.Kind]}'`);
    }
    function Extends(left, right) {
      return Visit(left, right);
    }
    TypeExtends2.Extends = Extends;
  })(TypeExtends || (exports.TypeExtends = TypeExtends = {}));
  var TypeClone;
  (function(TypeClone2) {
    function ObjectType(value) {
      const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
      const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
      return { ...clonedProperties, ...clonedSymbols };
    }
    function ArrayType(value) {
      return value.map((value2) => Visit(value2));
    }
    function Visit(value) {
      return ValueGuard.IsArray(value) ? ArrayType(value) : ValueGuard.IsObject(value) ? ObjectType(value) : value;
    }
    function Rest(schemas) {
      return schemas.map((schema) => Type(schema));
    }
    TypeClone2.Rest = Rest;
    function Type(schema, options = {}) {
      return { ...Visit(schema), ...options };
    }
    TypeClone2.Type = Type;
  })(TypeClone || (exports.TypeClone = TypeClone = {}));
  var IndexedAccessor;
  (function(IndexedAccessor2) {
    function OptionalUnwrap(schema) {
      return schema.map((schema2) => {
        const { [exports.Optional]: _, ...clone } = TypeClone.Type(schema2);
        return clone;
      });
    }
    function IsIntersectOptional(schema) {
      return schema.every((schema2) => TypeGuard.TOptional(schema2));
    }
    function IsUnionOptional(schema) {
      return schema.some((schema2) => TypeGuard.TOptional(schema2));
    }
    function ResolveIntersect(schema) {
      return IsIntersectOptional(schema.allOf) ? exports.Type.Optional(exports.Type.Intersect(OptionalUnwrap(schema.allOf))) : schema;
    }
    function ResolveUnion(schema) {
      return IsUnionOptional(schema.anyOf) ? exports.Type.Optional(exports.Type.Union(OptionalUnwrap(schema.anyOf))) : schema;
    }
    function ResolveOptional(schema) {
      return schema[exports.Kind] === "Intersect" ? ResolveIntersect(schema) : schema[exports.Kind] === "Union" ? ResolveUnion(schema) : schema;
    }
    function TIntersect(schema, key) {
      const resolved = schema.allOf.reduce((acc, schema2) => {
        const indexed = Visit(schema2, key);
        return indexed[exports.Kind] === "Never" ? acc : [...acc, indexed];
      }, []);
      return ResolveOptional(exports.Type.Intersect(resolved));
    }
    function TUnion(schema, key) {
      const resolved = schema.anyOf.map((schema2) => Visit(schema2, key));
      return ResolveOptional(exports.Type.Union(resolved));
    }
    function TObject(schema, key) {
      const property = schema.properties[key];
      return ValueGuard.IsUndefined(property) ? exports.Type.Never() : exports.Type.Union([property]);
    }
    function TTuple(schema, key) {
      const items = schema.items;
      if (ValueGuard.IsUndefined(items))
        return exports.Type.Never();
      const element = items[key];
      if (ValueGuard.IsUndefined(element))
        return exports.Type.Never();
      return element;
    }
    function Visit(schema, key) {
      return schema[exports.Kind] === "Intersect" ? TIntersect(schema, key) : schema[exports.Kind] === "Union" ? TUnion(schema, key) : schema[exports.Kind] === "Object" ? TObject(schema, key) : schema[exports.Kind] === "Tuple" ? TTuple(schema, key) : exports.Type.Never();
    }
    function Resolve(schema, keys, options = {}) {
      const resolved = keys.map((key) => Visit(schema, key.toString()));
      return ResolveOptional(exports.Type.Union(resolved, options));
    }
    IndexedAccessor2.Resolve = Resolve;
  })(IndexedAccessor || (exports.IndexedAccessor = IndexedAccessor = {}));
  var Intrinsic;
  (function(Intrinsic2) {
    function Uncapitalize(value) {
      const [first, rest] = [value.slice(0, 1), value.slice(1)];
      return `${first.toLowerCase()}${rest}`;
    }
    function Capitalize(value) {
      const [first, rest] = [value.slice(0, 1), value.slice(1)];
      return `${first.toUpperCase()}${rest}`;
    }
    function Uppercase(value) {
      return value.toUpperCase();
    }
    function Lowercase(value) {
      return value.toLowerCase();
    }
    function IntrinsicTemplateLiteral(schema, mode) {
      const expression = TemplateLiteralParser.ParseExact(schema.pattern);
      const finite = TemplateLiteralFinite.Check(expression);
      if (!finite)
        return { ...schema, pattern: IntrinsicLiteral(schema.pattern, mode) };
      const strings = [...TemplateLiteralGenerator.Generate(expression)];
      const literals = strings.map((value) => exports.Type.Literal(value));
      const mapped = IntrinsicRest(literals, mode);
      const union = exports.Type.Union(mapped);
      return exports.Type.TemplateLiteral([union]);
    }
    function IntrinsicLiteral(value, mode) {
      return typeof value === "string" ? mode === "Uncapitalize" ? Uncapitalize(value) : mode === "Capitalize" ? Capitalize(value) : mode === "Uppercase" ? Uppercase(value) : mode === "Lowercase" ? Lowercase(value) : value : value.toString();
    }
    function IntrinsicRest(schema, mode) {
      if (schema.length === 0)
        return [];
      const [L, ...R] = schema;
      return [Map2(L, mode), ...IntrinsicRest(R, mode)];
    }
    function Visit(schema, mode) {
      return TypeGuard.TTemplateLiteral(schema) ? IntrinsicTemplateLiteral(schema, mode) : TypeGuard.TUnion(schema) ? exports.Type.Union(IntrinsicRest(schema.anyOf, mode)) : TypeGuard.TLiteral(schema) ? exports.Type.Literal(IntrinsicLiteral(schema.const, mode)) : schema;
    }
    function Map2(schema, mode) {
      return Visit(schema, mode);
    }
    Intrinsic2.Map = Map2;
  })(Intrinsic || (exports.Intrinsic = Intrinsic = {}));
  var ObjectMap;
  (function(ObjectMap2) {
    function TIntersect(schema, callback) {
      return exports.Type.Intersect(schema.allOf.map((inner) => Visit(inner, callback)), { ...schema });
    }
    function TUnion(schema, callback) {
      return exports.Type.Union(schema.anyOf.map((inner) => Visit(inner, callback)), { ...schema });
    }
    function TObject(schema, callback) {
      return callback(schema);
    }
    function Visit(schema, callback) {
      return schema[exports.Kind] === "Intersect" ? TIntersect(schema, callback) : schema[exports.Kind] === "Union" ? TUnion(schema, callback) : schema[exports.Kind] === "Object" ? TObject(schema, callback) : schema;
    }
    function Map2(schema, callback, options) {
      return { ...Visit(TypeClone.Type(schema), callback), ...options };
    }
    ObjectMap2.Map = Map2;
  })(ObjectMap || (exports.ObjectMap = ObjectMap = {}));
  var KeyResolver;
  (function(KeyResolver2) {
    function UnwrapPattern(key) {
      return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
    }
    function TIntersect(schema, options) {
      return schema.allOf.reduce((acc, schema2) => [...acc, ...Visit(schema2, options)], []);
    }
    function TUnion(schema, options) {
      const sets = schema.anyOf.map((inner) => Visit(inner, options));
      return [...sets.reduce((set, outer) => outer.map((key) => sets.every((inner) => inner.includes(key)) ? set.add(key) : set)[0], new Set)];
    }
    function TObject(schema, options) {
      return Object.getOwnPropertyNames(schema.properties);
    }
    function TRecord(schema, options) {
      return options.includePatterns ? Object.getOwnPropertyNames(schema.patternProperties) : [];
    }
    function Visit(schema, options) {
      return TypeGuard.TIntersect(schema) ? TIntersect(schema, options) : TypeGuard.TUnion(schema) ? TUnion(schema, options) : TypeGuard.TObject(schema) ? TObject(schema, options) : TypeGuard.TRecord(schema) ? TRecord(schema, options) : [];
    }
    function ResolveKeys(schema, options) {
      return [...new Set(Visit(schema, options))];
    }
    KeyResolver2.ResolveKeys = ResolveKeys;
    function ResolvePattern(schema) {
      const keys = ResolveKeys(schema, { includePatterns: true });
      const pattern = keys.map((key) => `(${UnwrapPattern(key)})`);
      return `^(${pattern.join("|")})\$`;
    }
    KeyResolver2.ResolvePattern = ResolvePattern;
  })(KeyResolver || (exports.KeyResolver = KeyResolver = {}));

  class KeyArrayResolverError extends TypeBoxError {
  }
  exports.KeyArrayResolverError = KeyArrayResolverError;
  var KeyArrayResolver;
  (function(KeyArrayResolver2) {
    function Resolve(schema) {
      return Array.isArray(schema) ? schema : TypeGuard.TUnionLiteral(schema) ? schema.anyOf.map((schema2) => schema2.const.toString()) : TypeGuard.TLiteral(schema) ? [schema.const] : TypeGuard.TTemplateLiteral(schema) ? (() => {
        const expression = TemplateLiteralParser.ParseExact(schema.pattern);
        if (!TemplateLiteralFinite.Check(expression))
          throw new KeyArrayResolverError("Cannot resolve keys from infinite template expression");
        return [...TemplateLiteralGenerator.Generate(expression)];
      })() : [];
    }
    KeyArrayResolver2.Resolve = Resolve;
  })(KeyArrayResolver || (exports.KeyArrayResolver = KeyArrayResolver = {}));
  var UnionResolver;
  (function(UnionResolver2) {
    function* TUnion(union) {
      for (const schema of union.anyOf) {
        if (schema[exports.Kind] === "Union") {
          yield* TUnion(schema);
        } else {
          yield schema;
        }
      }
    }
    function Resolve(union) {
      return exports.Type.Union([...TUnion(union)], { ...union });
    }
    UnionResolver2.Resolve = Resolve;
  })(UnionResolver || (exports.UnionResolver = UnionResolver = {}));

  class TemplateLiteralPatternError extends TypeBoxError {
  }
  exports.TemplateLiteralPatternError = TemplateLiteralPatternError;
  var TemplateLiteralPattern;
  (function(TemplateLiteralPattern2) {
    function Throw(message) {
      throw new TemplateLiteralPatternError(message);
    }
    function Escape(value) {
      return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function Visit(schema, acc) {
      return TypeGuard.TTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : TypeGuard.TUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit(schema2, acc)).join("|")})` : TypeGuard.TNumber(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TInteger(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TBigInt(schema) ? `${acc}${exports.PatternNumber}` : TypeGuard.TString(schema) ? `${acc}${exports.PatternString}` : TypeGuard.TLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : TypeGuard.TBoolean(schema) ? `${acc}${exports.PatternBoolean}` : Throw(`Unexpected Kind '${schema[exports.Kind]}'`);
    }
    function Create(kinds) {
      return `^${kinds.map((schema) => Visit(schema, "")).join("")}$`;
    }
    TemplateLiteralPattern2.Create = Create;
  })(TemplateLiteralPattern || (exports.TemplateLiteralPattern = TemplateLiteralPattern = {}));
  var TemplateLiteralResolver;
  (function(TemplateLiteralResolver2) {
    function Resolve(template) {
      const expression = TemplateLiteralParser.ParseExact(template.pattern);
      if (!TemplateLiteralFinite.Check(expression))
        return exports.Type.String();
      const literals = [...TemplateLiteralGenerator.Generate(expression)].map((value) => exports.Type.Literal(value));
      return exports.Type.Union(literals);
    }
    TemplateLiteralResolver2.Resolve = Resolve;
  })(TemplateLiteralResolver || (exports.TemplateLiteralResolver = TemplateLiteralResolver = {}));

  class TemplateLiteralParserError extends TypeBoxError {
  }
  exports.TemplateLiteralParserError = TemplateLiteralParserError;
  var TemplateLiteralParser;
  (function(TemplateLiteralParser2) {
    function IsNonEscaped(pattern, index, char) {
      return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
    }
    function IsOpenParen(pattern, index) {
      return IsNonEscaped(pattern, index, "(");
    }
    function IsCloseParen(pattern, index) {
      return IsNonEscaped(pattern, index, ")");
    }
    function IsSeparator(pattern, index) {
      return IsNonEscaped(pattern, index, "|");
    }
    function IsGroup(pattern) {
      if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
        return false;
      let count = 0;
      for (let index = 0;index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
          count += 1;
        if (IsCloseParen(pattern, index))
          count -= 1;
        if (count === 0 && index !== pattern.length - 1)
          return false;
      }
      return true;
    }
    function InGroup(pattern) {
      return pattern.slice(1, pattern.length - 1);
    }
    function IsPrecedenceOr(pattern) {
      let count = 0;
      for (let index = 0;index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
          count += 1;
        if (IsCloseParen(pattern, index))
          count -= 1;
        if (IsSeparator(pattern, index) && count === 0)
          return true;
      }
      return false;
    }
    function IsPrecedenceAnd(pattern) {
      for (let index = 0;index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
          return true;
      }
      return false;
    }
    function Or(pattern) {
      let [count, start] = [0, 0];
      const expressions = [];
      for (let index = 0;index < pattern.length; index++) {
        if (IsOpenParen(pattern, index))
          count += 1;
        if (IsCloseParen(pattern, index))
          count -= 1;
        if (IsSeparator(pattern, index) && count === 0) {
          const range2 = pattern.slice(start, index);
          if (range2.length > 0)
            expressions.push(Parse(range2));
          start = index + 1;
        }
      }
      const range = pattern.slice(start);
      if (range.length > 0)
        expressions.push(Parse(range));
      if (expressions.length === 0)
        return { type: "const", const: "" };
      if (expressions.length === 1)
        return expressions[0];
      return { type: "or", expr: expressions };
    }
    function And(pattern) {
      function Group(value, index) {
        if (!IsOpenParen(value, index))
          throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
        let count = 0;
        for (let scan = index;scan < value.length; scan++) {
          if (IsOpenParen(value, scan))
            count += 1;
          if (IsCloseParen(value, scan))
            count -= 1;
          if (count === 0)
            return [index, scan];
        }
        throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
      }
      function Range(pattern2, index) {
        for (let scan = index;scan < pattern2.length; scan++) {
          if (IsOpenParen(pattern2, scan))
            return [index, scan];
        }
        return [index, pattern2.length];
      }
      const expressions = [];
      for (let index = 0;index < pattern.length; index++) {
        if (IsOpenParen(pattern, index)) {
          const [start, end] = Group(pattern, index);
          const range = pattern.slice(start, end + 1);
          expressions.push(Parse(range));
          index = end;
        } else {
          const [start, end] = Range(pattern, index);
          const range = pattern.slice(start, end);
          if (range.length > 0)
            expressions.push(Parse(range));
          index = end - 1;
        }
      }
      return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
    }
    function Parse(pattern) {
      return IsGroup(pattern) ? Parse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: pattern };
    }
    TemplateLiteralParser2.Parse = Parse;
    function ParseExact(pattern) {
      return Parse(pattern.slice(1, pattern.length - 1));
    }
    TemplateLiteralParser2.ParseExact = ParseExact;
  })(TemplateLiteralParser || (exports.TemplateLiteralParser = TemplateLiteralParser = {}));

  class TemplateLiteralFiniteError extends TypeBoxError {
  }
  exports.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
  var TemplateLiteralFinite;
  (function(TemplateLiteralFinite2) {
    function Throw(message) {
      throw new TemplateLiteralFiniteError(message);
    }
    function IsNumber(expression) {
      return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
    }
    function IsBoolean(expression) {
      return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
    }
    function IsString(expression) {
      return expression.type === "const" && expression.const === ".*";
    }
    function Check(expression) {
      return IsBoolean(expression) ? true : IsNumber(expression) || IsString(expression) ? false : expression.type === "and" ? expression.expr.every((expr) => Check(expr)) : expression.type === "or" ? expression.expr.every((expr) => Check(expr)) : expression.type === "const" ? true : Throw(`Unknown expression type`);
    }
    TemplateLiteralFinite2.Check = Check;
  })(TemplateLiteralFinite || (exports.TemplateLiteralFinite = TemplateLiteralFinite = {}));

  class TemplateLiteralGeneratorError extends TypeBoxError {
  }
  exports.TemplateLiteralGeneratorError = TemplateLiteralGeneratorError;
  var TemplateLiteralGenerator;
  (function(TemplateLiteralGenerator2) {
    function* Reduce(buffer) {
      if (buffer.length === 1)
        return yield* buffer[0];
      for (const left of buffer[0]) {
        for (const right of Reduce(buffer.slice(1))) {
          yield `${left}${right}`;
        }
      }
    }
    function* And(expression) {
      return yield* Reduce(expression.expr.map((expr) => [...Generate(expr)]));
    }
    function* Or(expression) {
      for (const expr of expression.expr)
        yield* Generate(expr);
    }
    function* Const(expression) {
      return yield expression.const;
    }
    function* Generate(expression) {
      return expression.type === "and" ? yield* And(expression) : expression.type === "or" ? yield* Or(expression) : expression.type === "const" ? yield* Const(expression) : (() => {
        throw new TemplateLiteralGeneratorError("Unknown expression");
      })();
    }
    TemplateLiteralGenerator2.Generate = Generate;
  })(TemplateLiteralGenerator || (exports.TemplateLiteralGenerator = TemplateLiteralGenerator = {}));
  var TemplateLiteralDslParser;
  (function(TemplateLiteralDslParser2) {
    function* ParseUnion(template) {
      const trim = template.trim().replace(/"|'/g, "");
      return trim === "boolean" ? yield exports.Type.Boolean() : trim === "number" ? yield exports.Type.Number() : trim === "bigint" ? yield exports.Type.BigInt() : trim === "string" ? yield exports.Type.String() : yield (() => {
        const literals = trim.split("|").map((literal) => exports.Type.Literal(literal.trim()));
        return literals.length === 0 ? exports.Type.Never() : literals.length === 1 ? literals[0] : exports.Type.Union(literals);
      })();
    }
    function* ParseTerminal(template) {
      if (template[1] !== "{") {
        const L = exports.Type.Literal("$");
        const R = ParseLiteral(template.slice(1));
        return yield* [L, ...R];
      }
      for (let i = 2;i < template.length; i++) {
        if (template[i] === "}") {
          const L = ParseUnion(template.slice(2, i));
          const R = ParseLiteral(template.slice(i + 1));
          return yield* [...L, ...R];
        }
      }
      yield exports.Type.Literal(template);
    }
    function* ParseLiteral(template) {
      for (let i = 0;i < template.length; i++) {
        if (template[i] === "$") {
          const L = exports.Type.Literal(template.slice(0, i));
          const R = ParseTerminal(template.slice(i));
          return yield* [L, ...R];
        }
      }
      yield exports.Type.Literal(template);
    }
    function Parse(template_dsl) {
      return [...ParseLiteral(template_dsl)];
    }
    TemplateLiteralDslParser2.Parse = Parse;
  })(TemplateLiteralDslParser || (exports.TemplateLiteralDslParser = TemplateLiteralDslParser = {}));

  class TransformDecodeBuilder {
    constructor(schema) {
      this.schema = schema;
    }
    Decode(decode) {
      return new TransformEncodeBuilder(this.schema, decode);
    }
  }
  exports.TransformDecodeBuilder = TransformDecodeBuilder;

  class TransformEncodeBuilder {
    constructor(schema, decode) {
      this.schema = schema;
      this.decode = decode;
    }
    Encode(encode) {
      const schema = TypeClone.Type(this.schema);
      return TypeGuard.TTransform(schema) ? (() => {
        const Encode = (value) => schema[exports.Transform].Encode(encode(value));
        const Decode = (value) => this.decode(schema[exports.Transform].Decode(value));
        const Codec = { Encode, Decode };
        return { ...schema, [exports.Transform]: Codec };
      })() : (() => {
        const Codec = { Decode: this.decode, Encode: encode };
        return { ...schema, [exports.Transform]: Codec };
      })();
    }
  }
  exports.TransformEncodeBuilder = TransformEncodeBuilder;
  var TypeOrdinal = 0;

  class TypeBuilderError extends TypeBoxError {
  }
  exports.TypeBuilderError = TypeBuilderError;

  class TypeBuilder {
    Create(schema) {
      return schema;
    }
    Throw(message) {
      throw new TypeBuilderError(message);
    }
    Discard(record, keys) {
      return keys.reduce((acc, key) => {
        const { [key]: _, ...rest } = acc;
        return rest;
      }, record);
    }
    Strict(schema) {
      return JSON.parse(JSON.stringify(schema));
    }
  }
  exports.TypeBuilder = TypeBuilder;

  class JsonTypeBuilder extends TypeBuilder {
    ReadonlyOptional(schema) {
      return this.Readonly(this.Optional(schema));
    }
    Readonly(schema) {
      return { ...TypeClone.Type(schema), [exports.Readonly]: "Readonly" };
    }
    Optional(schema) {
      return { ...TypeClone.Type(schema), [exports.Optional]: "Optional" };
    }
    Any(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Any" });
    }
    Array(schema, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Array", type: "array", items: TypeClone.Type(schema) });
    }
    Boolean(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Boolean", type: "boolean" });
    }
    Capitalize(schema, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema), "Capitalize"), ...options };
    }
    Composite(objects, options) {
      const intersect = exports.Type.Intersect(objects, {});
      const keys = KeyResolver.ResolveKeys(intersect, { includePatterns: false });
      const properties = keys.reduce((acc, key) => ({ ...acc, [key]: exports.Type.Index(intersect, [key]) }), {});
      return exports.Type.Object(properties, options);
    }
    Enum(item, options = {}) {
      const values1 = Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
      const values2 = [...new Set(values1)];
      const anyOf = values2.map((value) => exports.Type.Literal(value));
      return this.Union(anyOf, { ...options, [exports.Hint]: "Enum" });
    }
    Extends(left, right, trueType, falseType, options = {}) {
      switch (TypeExtends.Extends(left, right)) {
        case TypeExtendsResult.Union:
          return this.Union([TypeClone.Type(trueType, options), TypeClone.Type(falseType, options)]);
        case TypeExtendsResult.True:
          return TypeClone.Type(trueType, options);
        case TypeExtendsResult.False:
          return TypeClone.Type(falseType, options);
      }
    }
    Exclude(unionType2, excludedMembers, options = {}) {
      return TypeGuard.TTemplateLiteral(unionType2) ? this.Exclude(TemplateLiteralResolver.Resolve(unionType2), excludedMembers, options) : TypeGuard.TTemplateLiteral(excludedMembers) ? this.Exclude(unionType2, TemplateLiteralResolver.Resolve(excludedMembers), options) : TypeGuard.TUnion(unionType2) ? (() => {
        const narrowed = unionType2.anyOf.filter((inner) => TypeExtends.Extends(inner, excludedMembers) === TypeExtendsResult.False);
        return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
      })() : TypeExtends.Extends(unionType2, excludedMembers) !== TypeExtendsResult.False ? this.Never(options) : TypeClone.Type(unionType2, options);
    }
    Extract(type, union, options = {}) {
      return TypeGuard.TTemplateLiteral(type) ? this.Extract(TemplateLiteralResolver.Resolve(type), union, options) : TypeGuard.TTemplateLiteral(union) ? this.Extract(type, TemplateLiteralResolver.Resolve(union), options) : TypeGuard.TUnion(type) ? (() => {
        const narrowed = type.anyOf.filter((inner) => TypeExtends.Extends(inner, union) !== TypeExtendsResult.False);
        return narrowed.length === 1 ? TypeClone.Type(narrowed[0], options) : this.Union(narrowed, options);
      })() : TypeExtends.Extends(type, union) !== TypeExtendsResult.False ? TypeClone.Type(type, options) : this.Never(options);
    }
    Index(schema, unresolved, options = {}) {
      return TypeGuard.TArray(schema) && TypeGuard.TNumber(unresolved) ? (() => {
        return TypeClone.Type(schema.items, options);
      })() : TypeGuard.TTuple(schema) && TypeGuard.TNumber(unresolved) ? (() => {
        const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
        const cloned = items.map((schema2) => TypeClone.Type(schema2));
        return this.Union(cloned, options);
      })() : (() => {
        const keys = KeyArrayResolver.Resolve(unresolved);
        const clone = TypeClone.Type(schema);
        return IndexedAccessor.Resolve(clone, keys, options);
      })();
    }
    Integer(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Integer", type: "integer" });
    }
    Intersect(allOf, options = {}) {
      if (allOf.length === 0)
        return exports.Type.Never();
      if (allOf.length === 1)
        return TypeClone.Type(allOf[0], options);
      if (allOf.some((schema) => TypeGuard.TTransform(schema)))
        this.Throw("Cannot intersect transform types");
      const objects = allOf.every((schema) => TypeGuard.TObject(schema));
      const cloned = TypeClone.Rest(allOf);
      const clonedUnevaluatedProperties = TypeGuard.TSchema(options.unevaluatedProperties) ? { unevaluatedProperties: TypeClone.Type(options.unevaluatedProperties) } : {};
      return options.unevaluatedProperties === false || TypeGuard.TSchema(options.unevaluatedProperties) || objects ? this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", type: "object", allOf: cloned }) : this.Create({ ...options, ...clonedUnevaluatedProperties, [exports.Kind]: "Intersect", allOf: cloned });
    }
    KeyOf(schema, options = {}) {
      return TypeGuard.TRecord(schema) ? (() => {
        const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
        return pattern === exports.PatternNumberExact ? this.Number(options) : pattern === exports.PatternStringExact ? this.String(options) : this.Throw("Unable to resolve key type from Record key pattern");
      })() : TypeGuard.TTuple(schema) ? (() => {
        const items = ValueGuard.IsUndefined(schema.items) ? [] : schema.items;
        const literals = items.map((_, index) => exports.Type.Literal(index.toString()));
        return this.Union(literals, options);
      })() : TypeGuard.TArray(schema) ? (() => {
        return this.Number(options);
      })() : (() => {
        const keys = KeyResolver.ResolveKeys(schema, { includePatterns: false });
        if (keys.length === 0)
          return this.Never(options);
        const literals = keys.map((key) => this.Literal(key));
        return this.Union(literals, options);
      })();
    }
    Literal(value, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Literal", const: value, type: typeof value });
    }
    Lowercase(schema, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema), "Lowercase"), ...options };
    }
    Never(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Never", not: {} });
    }
    Not(schema, options) {
      return this.Create({ ...options, [exports.Kind]: "Not", not: TypeClone.Type(schema) });
    }
    Null(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Null", type: "null" });
    }
    Number(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Number", type: "number" });
    }
    Object(properties, options = {}) {
      const propertyKeys = Object.getOwnPropertyNames(properties);
      const optionalKeys = propertyKeys.filter((key) => TypeGuard.TOptional(properties[key]));
      const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
      const clonedAdditionalProperties = TypeGuard.TSchema(options.additionalProperties) ? { additionalProperties: TypeClone.Type(options.additionalProperties) } : {};
      const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: TypeClone.Type(properties[key]) }), {});
      return requiredKeys.length > 0 ? this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys }) : this.Create({ ...options, ...clonedAdditionalProperties, [exports.Kind]: "Object", type: "object", properties: clonedProperties });
    }
    Omit(schema, unresolved, options = {}) {
      const keys = KeyArrayResolver.Resolve(unresolved);
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
        if (ValueGuard.IsArray(object.required)) {
          object.required = object.required.filter((key) => !keys.includes(key));
          if (object.required.length === 0)
            delete object.required;
        }
        for (const key of Object.getOwnPropertyNames(object.properties)) {
          if (keys.includes(key))
            delete object.properties[key];
        }
        return this.Create(object);
      }, options);
    }
    Partial(schema, options = {}) {
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
        const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
          return { ...acc, [key]: this.Optional(object.properties[key]) };
        }, {});
        return this.Object(properties, this.Discard(object, ["required"]));
      }, options);
    }
    Pick(schema, unresolved, options = {}) {
      const keys = KeyArrayResolver.Resolve(unresolved);
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
        if (ValueGuard.IsArray(object.required)) {
          object.required = object.required.filter((key) => keys.includes(key));
          if (object.required.length === 0)
            delete object.required;
        }
        for (const key of Object.getOwnPropertyNames(object.properties)) {
          if (!keys.includes(key))
            delete object.properties[key];
        }
        return this.Create(object);
      }, options);
    }
    Record(key, schema, options = {}) {
      return TypeGuard.TTemplateLiteral(key) ? (() => {
        const expression = TemplateLiteralParser.ParseExact(key.pattern);
        return TemplateLiteralFinite.Check(expression) ? this.Object([...TemplateLiteralGenerator.Generate(expression)].reduce((acc, key2) => ({ ...acc, [key2]: TypeClone.Type(schema) }), {}), options) : this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [key.pattern]: TypeClone.Type(schema) } });
      })() : TypeGuard.TUnion(key) ? (() => {
        const union = UnionResolver.Resolve(key);
        if (TypeGuard.TUnionLiteral(union)) {
          const properties = union.anyOf.reduce((acc, literal) => ({ ...acc, [literal.const]: TypeClone.Type(schema) }), {});
          return this.Object(properties, { ...options, [exports.Hint]: "Record" });
        } else
          this.Throw("Record key of type union contains non-literal types");
      })() : TypeGuard.TLiteral(key) ? (() => {
        return ValueGuard.IsString(key.const) || ValueGuard.IsNumber(key.const) ? this.Object({ [key.const]: TypeClone.Type(schema) }, options) : this.Throw("Record key of type literal is not of type string or number");
      })() : TypeGuard.TInteger(key) || TypeGuard.TNumber(key) ? (() => {
        return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [exports.PatternNumberExact]: TypeClone.Type(schema) } });
      })() : TypeGuard.TString(key) ? (() => {
        const pattern = ValueGuard.IsUndefined(key.pattern) ? exports.PatternStringExact : key.pattern;
        return this.Create({ ...options, [exports.Kind]: "Record", type: "object", patternProperties: { [pattern]: TypeClone.Type(schema) } });
      })() : this.Never();
    }
    Recursive(callback, options = {}) {
      if (ValueGuard.IsUndefined(options.$id))
        options.$id = `T${TypeOrdinal++}`;
      const thisType = callback({ [exports.Kind]: "This", $ref: `${options.$id}` });
      thisType.$id = options.$id;
      return this.Create({ ...options, [exports.Hint]: "Recursive", ...thisType });
    }
    Ref(unresolved, options = {}) {
      if (ValueGuard.IsString(unresolved))
        return this.Create({ ...options, [exports.Kind]: "Ref", $ref: unresolved });
      if (ValueGuard.IsUndefined(unresolved.$id))
        this.Throw("Reference target type must specify an $id");
      return this.Create({ ...options, [exports.Kind]: "Ref", $ref: unresolved.$id });
    }
    Required(schema, options = {}) {
      return ObjectMap.Map(this.Discard(TypeClone.Type(schema), ["$id", exports.Transform]), (object) => {
        const properties = Object.getOwnPropertyNames(object.properties).reduce((acc, key) => {
          return { ...acc, [key]: this.Discard(object.properties[key], [exports.Optional]) };
        }, {});
        return this.Object(properties, object);
      }, options);
    }
    Rest(schema) {
      return TypeGuard.TTuple(schema) && !ValueGuard.IsUndefined(schema.items) ? TypeClone.Rest(schema.items) : TypeGuard.TIntersect(schema) ? TypeClone.Rest(schema.allOf) : TypeGuard.TUnion(schema) ? TypeClone.Rest(schema.anyOf) : [];
    }
    String(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "String", type: "string" });
    }
    TemplateLiteral(unresolved, options = {}) {
      const pattern = ValueGuard.IsString(unresolved) ? TemplateLiteralPattern.Create(TemplateLiteralDslParser.Parse(unresolved)) : TemplateLiteralPattern.Create(unresolved);
      return this.Create({ ...options, [exports.Kind]: "TemplateLiteral", type: "string", pattern });
    }
    Transform(schema) {
      return new TransformDecodeBuilder(schema);
    }
    Tuple(items, options = {}) {
      const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
      const clonedItems = TypeClone.Rest(items);
      const schema = items.length > 0 ? { ...options, [exports.Kind]: "Tuple", type: "array", items: clonedItems, additionalItems, minItems, maxItems } : { ...options, [exports.Kind]: "Tuple", type: "array", minItems, maxItems };
      return this.Create(schema);
    }
    Uncapitalize(schema, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema), "Uncapitalize"), ...options };
    }
    Union(union, options = {}) {
      return TypeGuard.TTemplateLiteral(union) ? TemplateLiteralResolver.Resolve(union) : (() => {
        const anyOf = union;
        if (anyOf.length === 0)
          return this.Never(options);
        if (anyOf.length === 1)
          return this.Create(TypeClone.Type(anyOf[0], options));
        const clonedAnyOf = TypeClone.Rest(anyOf);
        return this.Create({ ...options, [exports.Kind]: "Union", anyOf: clonedAnyOf });
      })();
    }
    Unknown(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Unknown" });
    }
    Unsafe(options = {}) {
      return this.Create({ ...options, [exports.Kind]: options[exports.Kind] || "Unsafe" });
    }
    Uppercase(schema, options = {}) {
      return { ...Intrinsic.Map(TypeClone.Type(schema), "Uppercase"), ...options };
    }
  }
  exports.JsonTypeBuilder = JsonTypeBuilder;

  class JavaScriptTypeBuilder extends JsonTypeBuilder {
    AsyncIterator(items, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "AsyncIterator", type: "AsyncIterator", items: TypeClone.Type(items) });
    }
    Awaited(schema, options = {}) {
      const Unwrap = (rest) => rest.length > 0 ? (() => {
        const [L, ...R] = rest;
        return [this.Awaited(L), ...Unwrap(R)];
      })() : rest;
      return TypeGuard.TIntersect(schema) ? exports.Type.Intersect(Unwrap(schema.allOf)) : TypeGuard.TUnion(schema) ? exports.Type.Union(Unwrap(schema.anyOf)) : TypeGuard.TPromise(schema) ? this.Awaited(schema.item) : TypeClone.Type(schema, options);
    }
    BigInt(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "BigInt", type: "bigint" });
    }
    ConstructorParameters(schema, options = {}) {
      return this.Tuple([...schema.parameters], { ...options });
    }
    Constructor(parameters, returns, options) {
      const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
      return this.Create({ ...options, [exports.Kind]: "Constructor", type: "Constructor", parameters: clonedParameters, returns: clonedReturns });
    }
    Date(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Date", type: "Date" });
    }
    Function(parameters, returns, options) {
      const [clonedParameters, clonedReturns] = [TypeClone.Rest(parameters), TypeClone.Type(returns)];
      return this.Create({ ...options, [exports.Kind]: "Function", type: "Function", parameters: clonedParameters, returns: clonedReturns });
    }
    InstanceType(schema, options = {}) {
      return TypeClone.Type(schema.returns, options);
    }
    Iterator(items, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Iterator", type: "Iterator", items: TypeClone.Type(items) });
    }
    Parameters(schema, options = {}) {
      return this.Tuple(schema.parameters, { ...options });
    }
    Promise(item, options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Promise", type: "Promise", item: TypeClone.Type(item) });
    }
    RegExp(unresolved, options = {}) {
      const pattern = ValueGuard.IsString(unresolved) ? unresolved : unresolved.source;
      return this.Create({ ...options, [exports.Kind]: "String", type: "string", pattern });
    }
    RegEx(regex, options = {}) {
      return this.RegExp(regex, options);
    }
    ReturnType(schema, options = {}) {
      return TypeClone.Type(schema.returns, options);
    }
    Symbol(options) {
      return this.Create({ ...options, [exports.Kind]: "Symbol", type: "symbol" });
    }
    Undefined(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Undefined", type: "undefined" });
    }
    Uint8Array(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Uint8Array", type: "Uint8Array" });
    }
    Void(options = {}) {
      return this.Create({ ...options, [exports.Kind]: "Void", type: "void" });
    }
  }
  exports.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
  exports.JsonType = new JsonTypeBuilder;
  exports.Type = new JavaScriptTypeBuilder;
});

// node_modules/@libsql/hrana-client/lib-esm/enc
var require_guard = __commonJS((exports) => {
  var IsAsyncIterator = function(value) {
    return IsObject(value) && (Symbol.asyncIterator in value);
  };
  var IsIterator = function(value) {
    return IsObject(value) && (Symbol.iterator in value);
  };
  var IsTypedArray = function(value) {
    return ArrayBuffer.isView(value);
  };
  var IsPromise = function(value) {
    return value instanceof Promise;
  };
  var IsUint8Array = function(value) {
    return value instanceof Uint8Array;
  };
  var IsDate = function(value) {
    return value instanceof Date && Number.isFinite(value.getTime());
  };
  var HasPropertyKey = function(value, key) {
    return key in value;
  };
  var IsPlainObject = function(value) {
    return IsObject(value) && IsFunction(value.constructor) && value.constructor.name === "Object";
  };
  var IsObject = function(value) {
    return value !== null && typeof value === "object";
  };
  var IsArray = function(value) {
    return Array.isArray(value) && !ArrayBuffer.isView(value);
  };
  var IsUndefined = function(value) {
    return value === undefined;
  };
  var IsNull = function(value) {
    return value === null;
  };
  var IsBoolean = function(value) {
    return typeof value === "boolean";
  };
  var IsNumber = function(value) {
    return typeof value === "number";
  };
  var IsInteger = function(value) {
    return IsNumber(value) && Number.isInteger(value);
  };
  var IsBigInt = function(value) {
    return typeof value === "bigint";
  };
  var IsString = function(value) {
    return typeof value === "string";
  };
  var IsFunction = function(value) {
    return typeof value === "function";
  };
  var IsSymbol = function(value) {
    return typeof value === "symbol";
  };
  var IsValueType = function(value) {
    return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsValueType = exports.IsSymbol = exports.IsFunction = exports.IsString = exports.IsBigInt = exports.IsInteger = exports.IsNumber = exports.IsBoolean = exports.IsNull = exports.IsUndefined = exports.IsArray = exports.IsObject = exports.IsPlainObject = exports.HasPropertyKey = exports.IsDate = exports.IsUint8Array = exports.IsPromise = exports.IsTypedArray = exports.IsIterator = exports.IsAsyncIterator = undefined;
  exports.IsAsyncIterator = IsAsyncIterator;
  exports.IsIterator = IsIterator;
  exports.IsTypedArray = IsTypedArray;
  exports.IsPromise = IsPromise;
  exports.IsUint8Array = IsUint8Array;
  exports.IsDate = IsDate;
  exports.HasPropertyKey = HasPropertyKey;
  exports.IsPlainObject = IsPlainObject;
  exports.IsObject = IsObject;
  exports.IsArray = IsArray;
  exports.IsUndefined = IsUndefined;
  exports.IsNull = IsNull;
  exports.IsBoolean = IsBoolean;
  exports.IsNumber = IsNumber;
  exports.IsInteger = IsInteger;
  exports.IsBigInt = IsBigInt;
  exports.IsString = IsString;
  exports.IsFunction = IsFunction;
  exports.IsSymbol = IsSymbol;
  exports.IsValueType = IsValueType;
});

// node_modules/@libsql/hrana-client/lib-esm/encod
var require_system = __commonJS((exports) => {
  var DefaultErrorFunction = function(schema, errorType) {
    switch (errorType) {
      case errors_1.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case errors_1.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${schema.maxContains} matching values`;
      case errors_1.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${schema.minContains} matching values`;
      case errors_1.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${schema.maxItems}`;
      case errors_1.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${schema.minItems}`;
      case errors_1.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case errors_1.ValueErrorType.Array:
        return "Expected array";
      case errors_1.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case errors_1.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${schema.maximum}`;
      case errors_1.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${schema.minimum}`;
      case errors_1.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${schema.multipleOf}`;
      case errors_1.ValueErrorType.BigInt:
        return "Expected bigint";
      case errors_1.ValueErrorType.Boolean:
        return "Expected boolean";
      case errors_1.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${schema.exclusiveMinimumTimestamp}`;
      case errors_1.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${schema.exclusiveMaximumTimestamp}`;
      case errors_1.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${schema.minimumTimestamp}`;
      case errors_1.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${schema.maximumTimestamp}`;
      case errors_1.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${schema.multipleOfTimestamp}`;
      case errors_1.ValueErrorType.Date:
        return "Expected Date";
      case errors_1.ValueErrorType.Function:
        return "Expected function";
      case errors_1.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${schema.maximum}`;
      case errors_1.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${schema.minimum}`;
      case errors_1.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${schema.multipleOf}`;
      case errors_1.ValueErrorType.Integer:
        return "Expected integer";
      case errors_1.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case errors_1.ValueErrorType.Intersect:
        return "Expected all values to match";
      case errors_1.ValueErrorType.Iterator:
        return "Expected Iterator";
      case errors_1.ValueErrorType.Literal:
        return `Expected ${typeof schema.const === "string" ? `'${schema.const}'` : schema.const}`;
      case errors_1.ValueErrorType.Never:
        return "Never";
      case errors_1.ValueErrorType.Not:
        return "Value should not match";
      case errors_1.ValueErrorType.Null:
        return "Expected null";
      case errors_1.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${schema.maximum}`;
      case errors_1.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${schema.minimum}`;
      case errors_1.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${schema.multipleOf}`;
      case errors_1.ValueErrorType.Number:
        return "Expected number";
      case errors_1.ValueErrorType.Object:
        return "Expected object";
      case errors_1.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case errors_1.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${schema.maxProperties} properties`;
      case errors_1.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${schema.minProperties} properties`;
      case errors_1.ValueErrorType.ObjectRequiredProperty:
        return "Required property";
      case errors_1.ValueErrorType.Promise:
        return "Expected Promise";
      case errors_1.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${schema.format}'`;
      case errors_1.ValueErrorType.StringFormat:
        return `Expected string to match '${schema.format}' format`;
      case errors_1.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${schema.maxLength}`;
      case errors_1.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${schema.minLength}`;
      case errors_1.ValueErrorType.StringPattern:
        return `Expected string to match '${schema.pattern}'`;
      case errors_1.ValueErrorType.String:
        return "Expected string";
      case errors_1.ValueErrorType.Symbol:
        return "Expected symbol";
      case errors_1.ValueErrorType.TupleLength:
        return `Expected tuple to have ${schema.maxItems || 0} elements`;
      case errors_1.ValueErrorType.Tuple:
        return "Expected tuple";
      case errors_1.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${schema.maxByteLength}`;
      case errors_1.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${schema.minByteLength}`;
      case errors_1.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case errors_1.ValueErrorType.Undefined:
        return "Expected undefined";
      case errors_1.ValueErrorType.Union:
        return "Expected union value";
      case errors_1.ValueErrorType.Void:
        return "Expected void";
      case errors_1.ValueErrorType.Kind:
        return `Expected kind '${schema[Types.Kind]}'`;
      default:
        return "Unknown error type";
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DefaultErrorFunction = exports.TypeSystemPolicy = exports.TypeSystemErrorFunction = exports.TypeSystem = exports.TypeSystemDuplicateFormat = exports.TypeSystemDuplicateTypeKind = undefined;
  var guard_1 = require_guard();
  var errors_1 = require_errors();
  var Types = require_typebox();

  class TypeSystemDuplicateTypeKind extends Types.TypeBoxError {
    constructor(kind) {
      super(`Duplicate type kind '${kind}' detected`);
    }
  }
  exports.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;

  class TypeSystemDuplicateFormat extends Types.TypeBoxError {
    constructor(kind) {
      super(`Duplicate string format '${kind}' detected`);
    }
  }
  exports.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;
  var TypeSystem;
  (function(TypeSystem2) {
    function Type(kind, check) {
      if (Types.TypeRegistry.Has(kind))
        throw new TypeSystemDuplicateTypeKind(kind);
      Types.TypeRegistry.Set(kind, check);
      return (options = {}) => Types.Type.Unsafe({ ...options, [Types.Kind]: kind });
    }
    TypeSystem2.Type = Type;
    function Format(format2, check) {
      if (Types.FormatRegistry.Has(format2))
        throw new TypeSystemDuplicateFormat(format2);
      Types.FormatRegistry.Set(format2, check);
      return format2;
    }
    TypeSystem2.Format = Format;
  })(TypeSystem || (exports.TypeSystem = TypeSystem = {}));
  var TypeSystemErrorFunction;
  (function(TypeSystemErrorFunction2) {
    let errorMessageFunction = DefaultErrorFunction;
    function Reset() {
      errorMessageFunction = DefaultErrorFunction;
    }
    TypeSystemErrorFunction2.Reset = Reset;
    function Set2(callback) {
      errorMessageFunction = callback;
    }
    TypeSystemErrorFunction2.Set = Set2;
    function Get() {
      return errorMessageFunction;
    }
    TypeSystemErrorFunction2.Get = Get;
  })(TypeSystemErrorFunction || (exports.TypeSystemErrorFunction = TypeSystemErrorFunction = {}));
  var TypeSystemPolicy;
  (function(TypeSystemPolicy2) {
    TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
    TypeSystemPolicy2.AllowArrayObject = false;
    TypeSystemPolicy2.AllowNaN = false;
    TypeSystemPolicy2.AllowNullVoid = false;
    function IsExactOptionalProperty(value, key) {
      return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
    }
    TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
    function IsObjectLike(value) {
      const isObject = (0, guard_1.IsObject)(value);
      return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !(0, guard_1.IsArray)(value);
    }
    TypeSystemPolicy2.IsObjectLike = IsObjectLike;
    function IsRecordLike(value) {
      return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
    }
    TypeSystemPolicy2.IsRecordLike = IsRecordLike;
    function IsNumberLike(value) {
      const isNumber = (0, guard_1.IsNumber)(value);
      return TypeSystemPolicy2.AllowNaN ? isNumber : isNumber && Number.isFinite(value);
    }
    TypeSystemPolicy2.IsNumberLike = IsNumberLike;
    function IsVoidLike(value) {
      const isUndefined = (0, guard_1.IsUndefined)(value);
      return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
    }
    TypeSystemPolicy2.IsVoidLike = IsVoidLike;
  })(TypeSystemPolicy || (exports.TypeSystemPolicy = TypeSystemPolicy = {}));
  exports.DefaultErrorFunction = DefaultErrorFunction;
});

// node_modules/@libsql/hrana-client/lib-esm/enc
var require_deref = __commonJS((exports) => {
  var Deref = function(schema, references) {
    const index = references.findIndex((target) => target.$id === schema.$ref);
    if (index === -1)
      throw new TypeDereferenceError(schema);
    return references[index];
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Deref = exports.TypeDereferenceError = undefined;
  var typebox_1 = require_typebox();

  class TypeDereferenceError extends typebox_1.TypeBoxError {
    constructor(schema) {
      super(`Unable to dereference schema with \$id '${schema.$id}'`);
      this.schema = schema;
    }
  }
  exports.TypeDereferenceError = TypeDereferenceError;
  exports.Deref = Deref;
});

// node_modules/@libsql/hrana-client/lib-esm/en
var require_hash = __commonJS((exports) => {
  function* NumberToBytes(value) {
    const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
    for (let i = 0;i < byteCount; i++) {
      yield value >> 8 * (byteCount - 1 - i) & 255;
    }
  }
  var ArrayType = function(value) {
    FNV1A64(ByteMarker.Array);
    for (const item of value) {
      Visit(item);
    }
  };
  var BooleanType = function(value) {
    FNV1A64(ByteMarker.Boolean);
    FNV1A64(value ? 1 : 0);
  };
  var BigIntType = function(value) {
    FNV1A64(ByteMarker.BigInt);
    F64In.setBigInt64(0, value);
    for (const byte of F64Out) {
      FNV1A64(byte);
    }
  };
  var DateType = function(value) {
    FNV1A64(ByteMarker.Date);
    Visit(value.getTime());
  };
  var NullType = function(value) {
    FNV1A64(ByteMarker.Null);
  };
  var NumberType = function(value) {
    FNV1A64(ByteMarker.Number);
    F64In.setFloat64(0, value);
    for (const byte of F64Out) {
      FNV1A64(byte);
    }
  };
  var ObjectType = function(value) {
    FNV1A64(ByteMarker.Object);
    for (const key of globalThis.Object.keys(value).sort()) {
      Visit(key);
      Visit(value[key]);
    }
  };
  var StringType = function(value) {
    FNV1A64(ByteMarker.String);
    for (let i = 0;i < value.length; i++) {
      for (const byte of NumberToBytes(value.charCodeAt(i))) {
        FNV1A64(byte);
      }
    }
  };
  var SymbolType = function(value) {
    FNV1A64(ByteMarker.Symbol);
    Visit(value.description);
  };
  var Uint8ArrayType = function(value) {
    FNV1A64(ByteMarker.Uint8Array);
    for (let i = 0;i < value.length; i++) {
      FNV1A64(value[i]);
    }
  };
  var UndefinedType = function(value) {
    return FNV1A64(ByteMarker.Undefined);
  };
  var Visit = function(value) {
    if ((0, guard_1.IsArray)(value))
      return ArrayType(value);
    if ((0, guard_1.IsBoolean)(value))
      return BooleanType(value);
    if ((0, guard_1.IsBigInt)(value))
      return BigIntType(value);
    if ((0, guard_1.IsDate)(value))
      return DateType(value);
    if ((0, guard_1.IsNull)(value))
      return NullType(value);
    if ((0, guard_1.IsNumber)(value))
      return NumberType(value);
    if ((0, guard_1.IsPlainObject)(value))
      return ObjectType(value);
    if ((0, guard_1.IsString)(value))
      return StringType(value);
    if ((0, guard_1.IsSymbol)(value))
      return SymbolType(value);
    if ((0, guard_1.IsUint8Array)(value))
      return Uint8ArrayType(value);
    if ((0, guard_1.IsUndefined)(value))
      return UndefinedType(value);
    throw new ValueHashError(value);
  };
  var FNV1A64 = function(byte) {
    Accumulator = Accumulator ^ Bytes[byte];
    Accumulator = Accumulator * Prime % Size;
  };
  var Hash = function(value) {
    Accumulator = BigInt("14695981039346656037");
    Visit(value);
    return Accumulator;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Hash = exports.ByteMarker = exports.ValueHashError = undefined;
  var guard_1 = require_guard();

  class ValueHashError extends Error {
    constructor(value) {
      super(`Unable to hash value`);
      this.value = value;
    }
  }
  exports.ValueHashError = ValueHashError;
  var ByteMarker;
  (function(ByteMarker2) {
    ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
    ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
    ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
    ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
    ByteMarker2[ByteMarker2["String"] = 4] = "String";
    ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
    ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
    ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
    ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
    ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
    ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
  })(ByteMarker || (exports.ByteMarker = ByteMarker = {}));
  var Accumulator = BigInt("14695981039346656037");
  var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
  var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
  var F64 = new Float64Array(1);
  var F64In = new DataView(F64.buffer);
  var F64Out = new Uint8Array(F64.buffer);
  exports.Hash = Hash;
});

// node_modules/@libsql/hrana-client/lib-esm/encod
var require_errors = __commonJS((exports) => {
  var IsDefined = function(value) {
    return value !== undefined;
  };
  var Create = function(type, schema, path, value) {
    return { type, schema, path, value, message: system_1.TypeSystemErrorFunction.Get()(schema, type) };
  };
  function* TAny(schema, references, path, value) {
  }
  function* TArray(schema, references, path, value) {
    if (!(0, guard_1.IsArray)(value)) {
      return yield Create(ValueErrorType.Array, schema, path, value);
    }
    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
      yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
    }
    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
      yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
    }
    for (let i = 0;i < value.length; i++) {
      yield* Visit(schema.items, references, `${path}/${i}`, value[i]);
    }
    if (schema.uniqueItems === true && !function() {
      const set = new Set;
      for (const element of value) {
        const hashed = (0, hash_1.Hash)(element);
        if (set.has(hashed)) {
          return false;
        } else {
          set.add(hashed);
        }
      }
      return true;
    }()) {
      yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
    }
    if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
      return;
    }
    const containsSchema = IsDefined(schema.contains) ? schema.contains : Types.Type.Never();
    const containsCount = value.reduce((acc, value2, index) => Visit(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      yield Create(ValueErrorType.ArrayContains, schema, path, value);
    }
    if ((0, guard_1.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
      yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
    }
    if ((0, guard_1.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
      yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
    }
  }
  function* TAsyncIterator(schema, references, path, value) {
    if (!(0, guard_1.IsAsyncIterator)(value))
      yield Create(ValueErrorType.AsyncIterator, schema, path, value);
  }
  function* TBigInt(schema, references, path, value) {
    if (!(0, guard_1.IsBigInt)(value))
      return yield Create(ValueErrorType.BigInt, schema, path, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
      yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
    }
  }
  function* TBoolean(schema, references, path, value) {
    if (!(0, guard_1.IsBoolean)(value))
      yield Create(ValueErrorType.Boolean, schema, path, value);
  }
  function* TConstructor(schema, references, path, value) {
    yield* Visit(schema.returns, references, path, value.prototype);
  }
  function* TDate(schema, references, path, value) {
    if (!(0, guard_1.IsDate)(value))
      return yield Create(ValueErrorType.Date, schema, path, value);
    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
      yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
      yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
      yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
      yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
      yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
    }
  }
  function* TFunction(schema, references, path, value) {
    if (!(0, guard_1.IsFunction)(value))
      yield Create(ValueErrorType.Function, schema, path, value);
  }
  function* TInteger(schema, references, path, value) {
    if (!(0, guard_1.IsInteger)(value))
      return yield Create(ValueErrorType.Integer, schema, path, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
    }
  }
  function* TIntersect(schema, references, path, value) {
    for (const inner of schema.allOf) {
      const next = Visit(inner, references, path, value).next();
      if (!next.done) {
        yield Create(ValueErrorType.Intersect, schema, path, value);
        yield next.value;
      }
    }
    if (schema.unevaluatedProperties === false) {
      const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));
      for (const valueKey of Object.getOwnPropertyNames(value)) {
        if (!keyCheck.test(valueKey)) {
          yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
        }
      }
    }
    if (typeof schema.unevaluatedProperties === "object") {
      const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));
      for (const valueKey of Object.getOwnPropertyNames(value)) {
        if (!keyCheck.test(valueKey)) {
          const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
          if (!next.done)
            yield next.value;
        }
      }
    }
  }
  function* TIterator(schema, references, path, value) {
    if (!(0, guard_1.IsIterator)(value))
      yield Create(ValueErrorType.Iterator, schema, path, value);
  }
  function* TLiteral(schema, references, path, value) {
    if (!(value === schema.const))
      yield Create(ValueErrorType.Literal, schema, path, value);
  }
  function* TNever(schema, references, path, value) {
    yield Create(ValueErrorType.Never, schema, path, value);
  }
  function* TNot(schema, references, path, value) {
    if (Visit(schema.not, references, path, value).next().done === true)
      yield Create(ValueErrorType.Not, schema, path, value);
  }
  function* TNull(schema, references, path, value) {
    if (!(0, guard_1.IsNull)(value))
      yield Create(ValueErrorType.Null, schema, path, value);
  }
  function* TNumber(schema, references, path, value) {
    if (!system_1.TypeSystemPolicy.IsNumberLike(value))
      return yield Create(ValueErrorType.Number, schema, path, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      yield Create(ValueErrorType.NumberMaximum, schema, path, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      yield Create(ValueErrorType.NumberMinimum, schema, path, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
    }
  }
  function* TObject(schema, references, path, value) {
    if (!system_1.TypeSystemPolicy.IsObjectLike(value))
      return yield Create(ValueErrorType.Object, schema, path, value);
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
    }
    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    const unknownKeys = Object.getOwnPropertyNames(value);
    for (const requiredKey of requiredKeys) {
      if (unknownKeys.includes(requiredKey))
        continue;
      yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${requiredKey}`, undefined);
    }
    if (schema.additionalProperties === false) {
      for (const valueKey of unknownKeys) {
        if (!knownKeys.includes(valueKey)) {
          yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${valueKey}`, value[valueKey]);
        }
      }
    }
    if (typeof schema.additionalProperties === "object") {
      for (const valueKey of unknownKeys) {
        if (knownKeys.includes(valueKey))
          continue;
        yield* Visit(schema.additionalProperties, references, `${path}/${valueKey}`, value[valueKey]);
      }
    }
    for (const knownKey of knownKeys) {
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit(property, references, `${path}/${knownKey}`, value[knownKey]);
        if (Types.ExtendsUndefined.Check(schema) && !(knownKey in value)) {
          yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${knownKey}`, undefined);
        }
      } else {
        if (system_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
          yield* Visit(property, references, `${path}/${knownKey}`, value[knownKey]);
        }
      }
    }
  }
  function* TPromise(schema, references, path, value) {
    if (!(0, guard_1.IsPromise)(value))
      yield Create(ValueErrorType.Promise, schema, path, value);
  }
  function* TRecord(schema, references, path, value) {
    if (!system_1.TypeSystemPolicy.IsRecordLike(value))
      return yield Create(ValueErrorType.Object, schema, path, value);
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
    }
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const regex = new RegExp(patternKey);
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        yield* Visit(patternSchema, references, `${path}/${propertyKey}`, propertyValue);
    }
    if (typeof schema.additionalProperties === "object") {
      for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (!regex.test(propertyKey))
          yield* Visit(schema.additionalProperties, references, `${path}/${propertyKey}`, propertyValue);
      }
    }
    if (schema.additionalProperties === false) {
      for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (regex.test(propertyKey))
          continue;
        return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${propertyKey}`, propertyValue);
      }
    }
  }
  function* TRef(schema, references, path, value) {
    yield* Visit((0, deref_1.Deref)(schema, references), references, path, value);
  }
  function* TString(schema, references, path, value) {
    if (!(0, guard_1.IsString)(value))
      return yield Create(ValueErrorType.String, schema, path, value);
    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
      yield Create(ValueErrorType.StringMinLength, schema, path, value);
    }
    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
      yield Create(ValueErrorType.StringMaxLength, schema, path, value);
    }
    if ((0, guard_1.IsString)(schema.pattern)) {
      const regex = new RegExp(schema.pattern);
      if (!regex.test(value)) {
        yield Create(ValueErrorType.StringPattern, schema, path, value);
      }
    }
    if ((0, guard_1.IsString)(schema.format)) {
      if (!Types.FormatRegistry.Has(schema.format)) {
        yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
      } else {
        const format2 = Types.FormatRegistry.Get(schema.format);
        if (!format2(value)) {
          yield Create(ValueErrorType.StringFormat, schema, path, value);
        }
      }
    }
  }
  function* TSymbol(schema, references, path, value) {
    if (!(0, guard_1.IsSymbol)(value))
      yield Create(ValueErrorType.Symbol, schema, path, value);
  }
  function* TTemplateLiteral(schema, references, path, value) {
    if (!(0, guard_1.IsString)(value))
      return yield Create(ValueErrorType.String, schema, path, value);
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value);
    }
  }
  function* TThis(schema, references, path, value) {
    yield* Visit((0, deref_1.Deref)(schema, references), references, path, value);
  }
  function* TTuple(schema, references, path, value) {
    if (!(0, guard_1.IsArray)(value))
      return yield Create(ValueErrorType.Tuple, schema, path, value);
    if (schema.items === undefined && !(value.length === 0)) {
      return yield Create(ValueErrorType.TupleLength, schema, path, value);
    }
    if (!(value.length === schema.maxItems)) {
      return yield Create(ValueErrorType.TupleLength, schema, path, value);
    }
    if (!schema.items) {
      return;
    }
    for (let i = 0;i < schema.items.length; i++) {
      yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);
    }
  }
  function* TUndefined(schema, references, path, value) {
    if (!(0, guard_1.IsUndefined)(value))
      yield Create(ValueErrorType.Undefined, schema, path, value);
  }
  function* TUnion(schema, references, path, value) {
    let count = 0;
    for (const subschema of schema.anyOf) {
      const errors = [...Visit(subschema, references, path, value)];
      if (errors.length === 0)
        return;
      count += errors.length;
    }
    if (count > 0) {
      yield Create(ValueErrorType.Union, schema, path, value);
    }
  }
  function* TUint8Array(schema, references, path, value) {
    if (!(0, guard_1.IsUint8Array)(value))
      return yield Create(ValueErrorType.Uint8Array, schema, path, value);
    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
      yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
    }
    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
      yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
    }
  }
  function* TUnknown(schema, references, path, value) {
  }
  function* TVoid(schema, references, path, value) {
    if (!system_1.TypeSystemPolicy.IsVoidLike(value))
      yield Create(ValueErrorType.Void, schema, path, value);
  }
  function* TKind(schema, references, path, value) {
    const check = Types.TypeRegistry.Get(schema[Types.Kind]);
    if (!check(schema, value))
      yield Create(ValueErrorType.Kind, schema, path, value);
  }
  function* Visit(schema, references, path, value) {
    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[Types.Kind]) {
      case "Any":
        return yield* TAny(schema_, references_, path, value);
      case "Array":
        return yield* TArray(schema_, references_, path, value);
      case "AsyncIterator":
        return yield* TAsyncIterator(schema_, references_, path, value);
      case "BigInt":
        return yield* TBigInt(schema_, references_, path, value);
      case "Boolean":
        return yield* TBoolean(schema_, references_, path, value);
      case "Constructor":
        return yield* TConstructor(schema_, references_, path, value);
      case "Date":
        return yield* TDate(schema_, references_, path, value);
      case "Function":
        return yield* TFunction(schema_, references_, path, value);
      case "Integer":
        return yield* TInteger(schema_, references_, path, value);
      case "Intersect":
        return yield* TIntersect(schema_, references_, path, value);
      case "Iterator":
        return yield* TIterator(schema_, references_, path, value);
      case "Literal":
        return yield* TLiteral(schema_, references_, path, value);
      case "Never":
        return yield* TNever(schema_, references_, path, value);
      case "Not":
        return yield* TNot(schema_, references_, path, value);
      case "Null":
        return yield* TNull(schema_, references_, path, value);
      case "Number":
        return yield* TNumber(schema_, references_, path, value);
      case "Object":
        return yield* TObject(schema_, references_, path, value);
      case "Promise":
        return yield* TPromise(schema_, references_, path, value);
      case "Record":
        return yield* TRecord(schema_, references_, path, value);
      case "Ref":
        return yield* TRef(schema_, references_, path, value);
      case "String":
        return yield* TString(schema_, references_, path, value);
      case "Symbol":
        return yield* TSymbol(schema_, references_, path, value);
      case "TemplateLiteral":
        return yield* TTemplateLiteral(schema_, references_, path, value);
      case "This":
        return yield* TThis(schema_, references_, path, value);
      case "Tuple":
        return yield* TTuple(schema_, references_, path, value);
      case "Undefined":
        return yield* TUndefined(schema_, references_, path, value);
      case "Union":
        return yield* TUnion(schema_, references_, path, value);
      case "Uint8Array":
        return yield* TUint8Array(schema_, references_, path, value);
      case "Unknown":
        return yield* TUnknown(schema_, references_, path, value);
      case "Void":
        return yield* TVoid(schema_, references_, path, value);
      default:
        if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
          throw new ValueErrorsUnknownTypeError(schema);
        return yield* TKind(schema_, references_, path, value);
    }
  }
  var Errors = function(...args2) {
    const iterator = args2.length === 3 ? Visit(args2[0], args2[1], "", args2[2]) : Visit(args2[0], [], "", args2[1]);
    return new ValueErrorIterator(iterator);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Errors = exports.ValueErrorIterator = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = undefined;
  var guard_1 = require_guard();
  var system_1 = require_system();
  var deref_1 = require_deref();
  var hash_1 = require_hash();
  var Types = require_typebox();
  var ValueErrorType;
  (function(ValueErrorType2) {
    ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
    ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
    ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
    ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
    ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
    ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
    ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
    ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
    ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
    ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
    ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
    ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
    ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
    ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
    ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
    ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
    ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
    ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
    ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
    ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
    ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
    ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
    ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
    ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
    ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
    ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
    ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
    ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
    ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
    ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
    ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
    ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
    ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
    ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
    ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
    ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
    ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
    ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
    ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
    ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 48] = "StringFormatUnknown";
    ValueErrorType2[ValueErrorType2["StringFormat"] = 49] = "StringFormat";
    ValueErrorType2[ValueErrorType2["StringMaxLength"] = 50] = "StringMaxLength";
    ValueErrorType2[ValueErrorType2["StringMinLength"] = 51] = "StringMinLength";
    ValueErrorType2[ValueErrorType2["StringPattern"] = 52] = "StringPattern";
    ValueErrorType2[ValueErrorType2["String"] = 53] = "String";
    ValueErrorType2[ValueErrorType2["Symbol"] = 54] = "Symbol";
    ValueErrorType2[ValueErrorType2["TupleLength"] = 55] = "TupleLength";
    ValueErrorType2[ValueErrorType2["Tuple"] = 56] = "Tuple";
    ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 57] = "Uint8ArrayMaxByteLength";
    ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 58] = "Uint8ArrayMinByteLength";
    ValueErrorType2[ValueErrorType2["Uint8Array"] = 59] = "Uint8Array";
    ValueErrorType2[ValueErrorType2["Undefined"] = 60] = "Undefined";
    ValueErrorType2[ValueErrorType2["Union"] = 61] = "Union";
    ValueErrorType2[ValueErrorType2["Void"] = 62] = "Void";
  })(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));

  class ValueErrorsUnknownTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  exports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;

  class ValueErrorIterator {
    constructor(iterator) {
      this.iterator = iterator;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    First() {
      const next = this.iterator.next();
      return next.done ? undefined : next.value;
    }
  }
  exports.ValueErrorIterator = ValueErrorIterator;
  exports.Errors = Errors;
});

// node_modules/@libsql/hrana-client/lib-esm/enco
var require_errors2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_errors(), exports);
});

// node_modules/@libsql/hrana-client/lib-esm/encod
var require_pointer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValuePointer = exports.ValuePointerRootDeleteError = exports.ValuePointerRootSetError = undefined;

  class ValuePointerRootSetError extends Error {
    constructor(value, path, update) {
      super("Cannot set root value");
      this.value = value;
      this.path = path;
      this.update = update;
    }
  }
  exports.ValuePointerRootSetError = ValuePointerRootSetError;

  class ValuePointerRootDeleteError extends Error {
    constructor(value, path) {
      super("Cannot delete root value");
      this.value = value;
      this.path = path;
    }
  }
  exports.ValuePointerRootDeleteError = ValuePointerRootDeleteError;
  var ValuePointer;
  (function(ValuePointer2) {
    function Escape(component) {
      return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    function* Format(pointer) {
      if (pointer === "")
        return;
      let [start, end] = [0, 0];
      for (let i = 0;i < pointer.length; i++) {
        const char = pointer.charAt(i);
        if (char === "/") {
          if (i === 0) {
            start = i + 1;
          } else {
            end = i;
            yield Escape(pointer.slice(start, end));
            start = i + 1;
          }
        } else {
          end = i;
        }
      }
      yield Escape(pointer.slice(start));
    }
    ValuePointer2.Format = Format;
    function Set2(value, pointer, update) {
      if (pointer === "")
        throw new ValuePointerRootSetError(value, pointer, update);
      let [owner, next, key] = [null, value, ""];
      for (const component of Format(pointer)) {
        if (next[component] === undefined)
          next[component] = {};
        owner = next;
        next = next[component];
        key = component;
      }
      owner[key] = update;
    }
    ValuePointer2.Set = Set2;
    function Delete(value, pointer) {
      if (pointer === "")
        throw new ValuePointerRootDeleteError(value, pointer);
      let [owner, next, key] = [null, value, ""];
      for (const component of Format(pointer)) {
        if (next[component] === undefined || next[component] === null)
          return;
        owner = next;
        next = next[component];
        key = component;
      }
      if (Array.isArray(owner)) {
        const index = parseInt(key);
        owner.splice(index, 1);
      } else {
        delete owner[key];
      }
    }
    ValuePointer2.Delete = Delete;
    function Has(value, pointer) {
      if (pointer === "")
        return true;
      let [owner, next, key] = [null, value, ""];
      for (const component of Format(pointer)) {
        if (next[component] === undefined)
          return false;
        owner = next;
        next = next[component];
        key = component;
      }
      return Object.getOwnPropertyNames(owner).includes(key);
    }
    ValuePointer2.Has = Has;
    function Get(value, pointer) {
      if (pointer === "")
        return value;
      let current = value;
      for (const component of Format(pointer)) {
        if (current[component] === undefined)
          return;
        current = current[component];
      }
      return current;
    }
    ValuePointer2.Get = Get;
  })(ValuePointer || (exports.ValuePointer = ValuePointer = {}));
});

// node_modules/@libsql/hrana-client/lib-esm/enc
var require_clone = __commonJS((exports) => {
  var ObjectType = function(value) {
    const keys = [...Object.getOwnPropertyNames(value), ...Object.getOwnPropertySymbols(value)];
    return keys.reduce((acc, key) => ({ ...acc, [key]: Clone(value[key]) }), {});
  };
  var ArrayType = function(value) {
    return value.map((element) => Clone(element));
  };
  var TypedArrayType = function(value) {
    return value.slice();
  };
  var DateType = function(value) {
    return new Date(value.toISOString());
  };
  var ValueType = function(value) {
    return value;
  };
  var Clone = function(value) {
    if ((0, guard_1.IsArray)(value))
      return ArrayType(value);
    if ((0, guard_1.IsDate)(value))
      return DateType(value);
    if ((0, guard_1.IsPlainObject)(value))
      return ObjectType(value);
    if ((0, guard_1.IsTypedArray)(value))
      return TypedArrayType(value);
    if ((0, guard_1.IsValueType)(value))
      return ValueType(value);
    throw new Error("ValueClone: Unable to clone value");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Clone = undefined;
  var guard_1 = require_guard();
  exports.Clone = Clone;
});

// node_modules/@libsql/hrana-client/lib-esm/enc
var require_delta = __commonJS((exports) => {
  var CreateUpdate = function(path, value) {
    return { type: "update", path, value };
  };
  var CreateInsert = function(path, value) {
    return { type: "insert", path, value };
  };
  var CreateDelete = function(path) {
    return { type: "delete", path };
  };
  function* ObjectType(path, current, next) {
    if (!(0, guard_1.IsPlainObject)(next))
      return yield CreateUpdate(path, next);
    const currentKeys = [...Object.keys(current), ...Object.getOwnPropertySymbols(current)];
    const nextKeys = [...Object.keys(next), ...Object.getOwnPropertySymbols(next)];
    for (const key of currentKeys) {
      if ((0, guard_1.IsSymbol)(key))
        throw new ValueDeltaObjectWithSymbolKeyError(key);
      if ((0, guard_1.IsUndefined)(next[key]) && nextKeys.includes(key))
        yield CreateUpdate(`${path}/${String(key)}`, undefined);
    }
    for (const key of nextKeys) {
      if ((0, guard_1.IsUndefined)(current[key]) || (0, guard_1.IsUndefined)(next[key]))
        continue;
      if ((0, guard_1.IsSymbol)(key))
        throw new ValueDeltaObjectWithSymbolKeyError(key);
      yield* Visit(`${path}/${String(key)}`, current[key], next[key]);
    }
    for (const key of nextKeys) {
      if ((0, guard_1.IsSymbol)(key))
        throw new ValueDeltaObjectWithSymbolKeyError(key);
      if ((0, guard_1.IsUndefined)(current[key]))
        yield CreateInsert(`${path}/${String(key)}`, next[key]);
    }
    for (const key of currentKeys.reverse()) {
      if ((0, guard_1.IsSymbol)(key))
        throw new ValueDeltaObjectWithSymbolKeyError(key);
      if ((0, guard_1.IsUndefined)(next[key]) && !nextKeys.includes(key))
        yield CreateDelete(`${path}/${String(key)}`);
    }
  }
  function* ArrayType(path, current, next) {
    if (!(0, guard_1.IsArray)(next))
      return yield CreateUpdate(path, next);
    for (let i = 0;i < Math.min(current.length, next.length); i++) {
      yield* Visit(`${path}/${i}`, current[i], next[i]);
    }
    for (let i = 0;i < next.length; i++) {
      if (i < current.length)
        continue;
      yield CreateInsert(`${path}/${i}`, next[i]);
    }
    for (let i = current.length - 1;i >= 0; i--) {
      if (i < next.length)
        continue;
      yield CreateDelete(`${path}/${i}`);
    }
  }
  function* TypedArrayType(path, current, next) {
    if (!(0, guard_1.IsTypedArray)(next) || current.length !== next.length || Object.getPrototypeOf(current).constructor.name !== Object.getPrototypeOf(next).constructor.name)
      return yield CreateUpdate(path, next);
    for (let i = 0;i < Math.min(current.length, next.length); i++) {
      yield* Visit(`${path}/${i}`, current[i], next[i]);
    }
  }
  function* ValueType(path, current, next) {
    if (current === next)
      return;
    yield CreateUpdate(path, next);
  }
  function* Visit(path, current, next) {
    if ((0, guard_1.IsPlainObject)(current))
      return yield* ObjectType(path, current, next);
    if ((0, guard_1.IsArray)(current))
      return yield* ArrayType(path, current, next);
    if ((0, guard_1.IsTypedArray)(current))
      return yield* TypedArrayType(path, current, next);
    if ((0, guard_1.IsValueType)(current))
      return yield* ValueType(path, current, next);
    throw new ValueDeltaUnableToDiffUnknownValue(current);
  }
  var Diff = function(current, next) {
    return [...Visit("", current, next)];
  };
  var IsRootUpdate = function(edits) {
    return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
  };
  var IsIdentity = function(edits) {
    return edits.length === 0;
  };
  var Patch = function(current, edits) {
    if (IsRootUpdate(edits)) {
      return (0, clone_1.Clone)(edits[0].value);
    }
    if (IsIdentity(edits)) {
      return (0, clone_1.Clone)(current);
    }
    const clone = (0, clone_1.Clone)(current);
    for (const edit of edits) {
      switch (edit.type) {
        case "insert": {
          pointer_1.ValuePointer.Set(clone, edit.path, edit.value);
          break;
        }
        case "update": {
          pointer_1.ValuePointer.Set(clone, edit.path, edit.value);
          break;
        }
        case "delete": {
          pointer_1.ValuePointer.Delete(clone, edit.path);
          break;
        }
      }
    }
    return clone;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Patch = exports.Diff = exports.ValueDeltaUnableToDiffUnknownValue = exports.ValueDeltaObjectWithSymbolKeyError = exports.Edit = exports.Delete = exports.Update = exports.Insert = undefined;
  var guard_1 = require_guard();
  var typebox_1 = require_typebox();
  var pointer_1 = require_pointer();
  var clone_1 = require_clone();
  exports.Insert = typebox_1.Type.Object({
    type: typebox_1.Type.Literal("insert"),
    path: typebox_1.Type.String(),
    value: typebox_1.Type.Unknown()
  });
  exports.Update = typebox_1.Type.Object({
    type: typebox_1.Type.Literal("update"),
    path: typebox_1.Type.String(),
    value: typebox_1.Type.Unknown()
  });
  exports.Delete = typebox_1.Type.Object({
    type: typebox_1.Type.Literal("delete"),
    path: typebox_1.Type.String()
  });
  exports.Edit = typebox_1.Type.Union([exports.Insert, exports.Update, exports.Delete]);

  class ValueDeltaObjectWithSymbolKeyError extends Error {
    constructor(key) {
      super("Cannot diff objects with symbol keys");
      this.key = key;
    }
  }
  exports.ValueDeltaObjectWithSymbolKeyError = ValueDeltaObjectWithSymbolKeyError;

  class ValueDeltaUnableToDiffUnknownValue extends Error {
    constructor(value) {
      super("Unable to create diff edits for unknown value");
      this.value = value;
    }
  }
  exports.ValueDeltaUnableToDiffUnknownValue = ValueDeltaUnableToDiffUnknownValue;
  exports.Diff = Diff;
  exports.Patch = Patch;
});

// node_modules/@libsql/hrana-client/lib-esm/enco
var require_mutate = __commonJS((exports) => {
  var ObjectType = function(root, path, current, next) {
    if (!(0, guard_1.IsPlainObject)(current)) {
      pointer_1.ValuePointer.Set(root, path, (0, clone_1.Clone)(next));
    } else {
      const currentKeys = Object.keys(current);
      const nextKeys = Object.keys(next);
      for (const currentKey of currentKeys) {
        if (!nextKeys.includes(currentKey)) {
          delete current[currentKey];
        }
      }
      for (const nextKey of nextKeys) {
        if (!currentKeys.includes(nextKey)) {
          current[nextKey] = null;
        }
      }
      for (const nextKey of nextKeys) {
        Visit(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
      }
    }
  };
  var ArrayType = function(root, path, current, next) {
    if (!(0, guard_1.IsArray)(current)) {
      pointer_1.ValuePointer.Set(root, path, (0, clone_1.Clone)(next));
    } else {
      for (let index = 0;index < next.length; index++) {
        Visit(root, `${path}/${index}`, current[index], next[index]);
      }
      current.splice(next.length);
    }
  };
  var TypedArrayType = function(root, path, current, next) {
    if ((0, guard_1.IsTypedArray)(current) && current.length === next.length) {
      for (let i = 0;i < current.length; i++) {
        current[i] = next[i];
      }
    } else {
      pointer_1.ValuePointer.Set(root, path, (0, clone_1.Clone)(next));
    }
  };
  var ValueType = function(root, path, current, next) {
    if (current === next)
      return;
    pointer_1.ValuePointer.Set(root, path, next);
  };
  var Visit = function(root, path, current, next) {
    if ((0, guard_1.IsArray)(next))
      return ArrayType(root, path, current, next);
    if ((0, guard_1.IsTypedArray)(next))
      return TypedArrayType(root, path, current, next);
    if ((0, guard_1.IsPlainObject)(next))
      return ObjectType(root, path, current, next);
    if ((0, guard_1.IsValueType)(next))
      return ValueType(root, path, current, next);
  };
  var IsNonMutableValue = function(value) {
    return (0, guard_1.IsTypedArray)(value) || (0, guard_1.IsValueType)(value);
  };
  var IsMismatchedValue = function(current, next) {
    return (0, guard_1.IsPlainObject)(current) && (0, guard_1.IsArray)(next) || (0, guard_1.IsArray)(current) && (0, guard_1.IsPlainObject)(next);
  };
  var Mutate = function(current, next) {
    if (IsNonMutableValue(current) || IsNonMutableValue(next))
      throw new ValueMutateInvalidRootMutationError;
    if (IsMismatchedValue(current, next))
      throw new ValueMutateTypeMismatchError;
    Visit(current, "", current, next);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Mutate = exports.ValueMutateInvalidRootMutationError = exports.ValueMutateTypeMismatchError = undefined;
  var guard_1 = require_guard();
  var pointer_1 = require_pointer();
  var clone_1 = require_clone();

  class ValueMutateTypeMismatchError extends Error {
    constructor() {
      super("Cannot assign due type mismatch of assignable values");
    }
  }
  exports.ValueMutateTypeMismatchError = ValueMutateTypeMismatchError;

  class ValueMutateInvalidRootMutationError extends Error {
    constructor() {
      super("Only object and array types can be mutated at the root level");
    }
  }
  exports.ValueMutateInvalidRootMutationError = ValueMutateInvalidRootMutationError;
  exports.Mutate = Mutate;
});

// node_modules/@libsql/hrana-client/lib-esm/enc
var require_equal = __commonJS((exports) => {
  var ObjectType = function(left, right) {
    if (!(0, guard_1.IsPlainObject)(right))
      return false;
    const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
    const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
    if (leftKeys.length !== rightKeys.length)
      return false;
    return leftKeys.every((key) => Equal(left[key], right[key]));
  };
  var DateType = function(left, right) {
    return (0, guard_1.IsDate)(right) && left.getTime() === right.getTime();
  };
  var ArrayType = function(left, right) {
    if (!(0, guard_1.IsArray)(right) || left.length !== right.length)
      return false;
    return left.every((value, index) => Equal(value, right[index]));
  };
  var TypedArrayType = function(left, right) {
    if (!(0, guard_1.IsTypedArray)(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
      return false;
    return left.every((value, index) => Equal(value, right[index]));
  };
  var ValueType = function(left, right) {
    return left === right;
  };
  var Equal = function(left, right) {
    if ((0, guard_1.IsPlainObject)(left))
      return ObjectType(left, right);
    if ((0, guard_1.IsDate)(left))
      return DateType(left, right);
    if ((0, guard_1.IsTypedArray)(left))
      return TypedArrayType(left, right);
    if ((0, guard_1.IsArray)(left))
      return ArrayType(left, right);
    if ((0, guard_1.IsValueType)(left))
      return ValueType(left, right);
    throw new Error("ValueEquals: Unable to compare value");
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Equal = undefined;
  var guard_1 = require_guard();
  exports.Equal = Equal;
});

// node_modules/@libsql/hrana-client/lib-esm/enco
var require_system2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueErrorType = undefined;
  var errors_1 = require_errors();
  Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
    return errors_1.ValueErrorType;
  } });
  __exportStar(require_system(), exports);
});

// node_modules/@libsql/hrana-client/lib-esm/enc
var require_check = __commonJS((exports) => {
  var IsAnyOrUnknown = function(schema) {
    return schema[Types.Kind] === "Any" || schema[Types.Kind] === "Unknown";
  };
  var IsDefined = function(value) {
    return value !== undefined;
  };
  var TAny = function(schema, references, value) {
    return true;
  };
  var TArray = function(schema, references, value) {
    if (!(0, guard_1.IsArray)(value))
      return false;
    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
      return false;
    }
    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
      return false;
    }
    if (!value.every((value2) => Visit(schema.items, references, value2))) {
      return false;
    }
    if (schema.uniqueItems === true && !function() {
      const set = new Set;
      for (const element of value) {
        const hashed = (0, hash_1.Hash)(element);
        if (set.has(hashed)) {
          return false;
        } else {
          set.add(hashed);
        }
      }
      return true;
    }()) {
      return false;
    }
    if (!(IsDefined(schema.contains) || (0, guard_1.IsNumber)(schema.minContains) || (0, guard_1.IsNumber)(schema.maxContains))) {
      return true;
    }
    const containsSchema = IsDefined(schema.contains) ? schema.contains : Types.Type.Never();
    const containsCount = value.reduce((acc, value2) => Visit(containsSchema, references, value2) ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      return false;
    }
    if ((0, guard_1.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
      return false;
    }
    if ((0, guard_1.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
      return false;
    }
    return true;
  };
  var TAsyncIterator = function(schema, references, value) {
    return (0, guard_1.IsAsyncIterator)(value);
  };
  var TBigInt = function(schema, references, value) {
    if (!(0, guard_1.IsBigInt)(value))
      return false;
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      return false;
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      return false;
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
      return false;
    }
    return true;
  };
  var TBoolean = function(schema, references, value) {
    return (0, guard_1.IsBoolean)(value);
  };
  var TConstructor = function(schema, references, value) {
    return Visit(schema.returns, references, value.prototype);
  };
  var TDate = function(schema, references, value) {
    if (!(0, guard_1.IsDate)(value))
      return false;
    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
      return false;
    }
    return true;
  };
  var TFunction = function(schema, references, value) {
    return (0, guard_1.IsFunction)(value);
  };
  var TInteger = function(schema, references, value) {
    if (!(0, guard_1.IsInteger)(value)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      return false;
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      return false;
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      return false;
    }
    return true;
  };
  var TIntersect = function(schema, references, value) {
    const check1 = schema.allOf.every((schema2) => Visit(schema2, references, value));
    if (schema.unevaluatedProperties === false) {
      const keyPattern = new RegExp(Types.KeyResolver.ResolvePattern(schema));
      const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
      return check1 && check2;
    } else if (Types.TypeGuard.TSchema(schema.unevaluatedProperties)) {
      const keyCheck = new RegExp(Types.KeyResolver.ResolvePattern(schema));
      const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit(schema.unevaluatedProperties, references, value[key]));
      return check1 && check2;
    } else {
      return check1;
    }
  };
  var TIterator = function(schema, references, value) {
    return (0, guard_1.IsIterator)(value);
  };
  var TLiteral = function(schema, references, value) {
    return value === schema.const;
  };
  var TNever = function(schema, references, value) {
    return false;
  };
  var TNot = function(schema, references, value) {
    return !Visit(schema.not, references, value);
  };
  var TNull = function(schema, references, value) {
    return (0, guard_1.IsNull)(value);
  };
  var TNumber = function(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsNumberLike(value))
      return false;
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      return false;
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      return false;
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      return false;
    }
    return true;
  };
  var TObject = function(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsObjectLike(value))
      return false;
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      return false;
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      return false;
    }
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        if (!Visit(property, references, value[knownKey])) {
          return false;
        }
        if ((Types.ExtendsUndefined.Check(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
          return false;
        }
      } else {
        if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit(property, references, value[knownKey])) {
          return false;
        }
      }
    }
    if (schema.additionalProperties === false) {
      const valueKeys = Object.getOwnPropertyNames(value);
      if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
        return true;
      } else {
        return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
      }
    } else if (typeof schema.additionalProperties === "object") {
      const valueKeys = Object.getOwnPropertyNames(value);
      return valueKeys.every((key) => knownKeys.includes(key) || Visit(schema.additionalProperties, references, value[key]));
    } else {
      return true;
    }
  };
  var TPromise = function(schema, references, value) {
    return (0, guard_1.IsPromise)(value);
  };
  var TRecord = function(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsRecordLike(value)) {
      return false;
    }
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      return false;
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      return false;
    }
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const regex = new RegExp(patternKey);
    const check1 = Object.entries(value).every(([key, value2]) => {
      return regex.test(key) ? Visit(patternSchema, references, value2) : true;
    });
    const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
      return !regex.test(key) ? Visit(schema.additionalProperties, references, value2) : true;
    }) : true;
    const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
      return regex.test(key);
    }) : true;
    return check1 && check2 && check3;
  };
  var TRef = function(schema, references, value) {
    return Visit((0, deref_1.Deref)(schema, references), references, value);
  };
  var TString = function(schema, references, value) {
    if (!(0, guard_1.IsString)(value)) {
      return false;
    }
    if (IsDefined(schema.minLength)) {
      if (!(value.length >= schema.minLength))
        return false;
    }
    if (IsDefined(schema.maxLength)) {
      if (!(value.length <= schema.maxLength))
        return false;
    }
    if (IsDefined(schema.pattern)) {
      const regex = new RegExp(schema.pattern);
      if (!regex.test(value))
        return false;
    }
    if (IsDefined(schema.format)) {
      if (!Types.FormatRegistry.Has(schema.format))
        return false;
      const func = Types.FormatRegistry.Get(schema.format);
      return func(value);
    }
    return true;
  };
  var TSymbol = function(schema, references, value) {
    return (0, guard_1.IsSymbol)(value);
  };
  var TTemplateLiteral = function(schema, references, value) {
    return (0, guard_1.IsString)(value) && new RegExp(schema.pattern).test(value);
  };
  var TThis = function(schema, references, value) {
    return Visit((0, deref_1.Deref)(schema, references), references, value);
  };
  var TTuple = function(schema, references, value) {
    if (!(0, guard_1.IsArray)(value)) {
      return false;
    }
    if (schema.items === undefined && !(value.length === 0)) {
      return false;
    }
    if (!(value.length === schema.maxItems)) {
      return false;
    }
    if (!schema.items) {
      return true;
    }
    for (let i = 0;i < schema.items.length; i++) {
      if (!Visit(schema.items[i], references, value[i]))
        return false;
    }
    return true;
  };
  var TUndefined = function(schema, references, value) {
    return (0, guard_1.IsUndefined)(value);
  };
  var TUnion = function(schema, references, value) {
    return schema.anyOf.some((inner) => Visit(inner, references, value));
  };
  var TUint8Array = function(schema, references, value) {
    if (!(0, guard_1.IsUint8Array)(value)) {
      return false;
    }
    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
      return false;
    }
    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
      return false;
    }
    return true;
  };
  var TUnknown = function(schema, references, value) {
    return true;
  };
  var TVoid = function(schema, references, value) {
    return index_1.TypeSystemPolicy.IsVoidLike(value);
  };
  var TKind = function(schema, references, value) {
    if (!Types.TypeRegistry.Has(schema[Types.Kind]))
      return false;
    const func = Types.TypeRegistry.Get(schema[Types.Kind]);
    return func(schema, value);
  };
  var Visit = function(schema, references, value) {
    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[Types.Kind]) {
      case "Any":
        return TAny(schema_, references_, value);
      case "Array":
        return TArray(schema_, references_, value);
      case "AsyncIterator":
        return TAsyncIterator(schema_, references_, value);
      case "BigInt":
        return TBigInt(schema_, references_, value);
      case "Boolean":
        return TBoolean(schema_, references_, value);
      case "Constructor":
        return TConstructor(schema_, references_, value);
      case "Date":
        return TDate(schema_, references_, value);
      case "Function":
        return TFunction(schema_, references_, value);
      case "Integer":
        return TInteger(schema_, references_, value);
      case "Intersect":
        return TIntersect(schema_, references_, value);
      case "Iterator":
        return TIterator(schema_, references_, value);
      case "Literal":
        return TLiteral(schema_, references_, value);
      case "Never":
        return TNever(schema_, references_, value);
      case "Not":
        return TNot(schema_, references_, value);
      case "Null":
        return TNull(schema_, references_, value);
      case "Number":
        return TNumber(schema_, references_, value);
      case "Object":
        return TObject(schema_, references_, value);
      case "Promise":
        return TPromise(schema_, references_, value);
      case "Record":
        return TRecord(schema_, references_, value);
      case "Ref":
        return TRef(schema_, references_, value);
      case "String":
        return TString(schema_, references_, value);
      case "Symbol":
        return TSymbol(schema_, references_, value);
      case "TemplateLiteral":
        return TTemplateLiteral(schema_, references_, value);
      case "This":
        return TThis(schema_, references_, value);
      case "Tuple":
        return TTuple(schema_, references_, value);
      case "Undefined":
        return TUndefined(schema_, references_, value);
      case "Union":
        return TUnion(schema_, references_, value);
      case "Uint8Array":
        return TUint8Array(schema_, references_, value);
      case "Unknown":
        return TUnknown(schema_, references_, value);
      case "Void":
        return TVoid(schema_, references_, value);
      default:
        if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
          throw new ValueCheckUnknownTypeError(schema_);
        return TKind(schema_, references_, value);
    }
  };
  var Check = function(...args2) {
    return args2.length === 3 ? Visit(args2[0], args2[1], args2[2]) : Visit(args2[0], [], args2[1]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Check = exports.ValueCheckUnknownTypeError = undefined;
  var guard_1 = require_guard();
  var index_1 = require_system2();
  var deref_1 = require_deref();
  var hash_1 = require_hash();
  var Types = require_typebox();

  class ValueCheckUnknownTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super(`Unknown type`);
      this.schema = schema;
    }
  }
  exports.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError;
  exports.Check = Check;
});

// node_modules/@libsql/hrana-client/lib-esm/enco
var require_create = __commonJS((exports) => {
  var TAny = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return {};
    }
  };
  var TArray = function(schema, references) {
    if (schema.uniqueItems === true && !(0, guard_1.HasPropertyKey)(schema, "default")) {
      throw new Error("ValueCreate.Array: Array with the uniqueItems constraint requires a default value");
    } else if (("contains" in schema) && !(0, guard_1.HasPropertyKey)(schema, "default")) {
      throw new Error("ValueCreate.Array: Array with the contains constraint requires a default value");
    } else if ("default" in schema) {
      return schema.default;
    } else if (schema.minItems !== undefined) {
      return Array.from({ length: schema.minItems }).map((item) => {
        return Visit(schema.items, references);
      });
    } else {
      return [];
    }
  };
  var TAsyncIterator = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return async function* () {
      }();
    }
  };
  var TBigInt = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return BigInt(0);
    }
  };
  var TBoolean = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return false;
    }
  };
  var TConstructor = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      const value = Visit(schema.returns, references);
      if (typeof value === "object" && !Array.isArray(value)) {
        return class {
          constructor() {
            for (const [key, val] of Object.entries(value)) {
              const self2 = this;
              self2[key] = val;
            }
          }
        };
      } else {
        return class {
        };
      }
    }
  };
  var TDate = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else if (schema.minimumTimestamp !== undefined) {
      return new Date(schema.minimumTimestamp);
    } else {
      return new Date(0);
    }
  };
  var TFunction = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return () => Visit(schema.returns, references);
    }
  };
  var TInteger = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else if (schema.minimum !== undefined) {
      return schema.minimum;
    } else {
      return 0;
    }
  };
  var TIntersect = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      const value = schema.allOf.reduce((acc, schema2) => {
        const next = Visit(schema2, references);
        return typeof next === "object" ? { ...acc, ...next } : next;
      }, {});
      if (!(0, check_1.Check)(schema, references, value))
        throw new ValueCreateIntersectTypeError(schema);
      return value;
    }
  };
  var TIterator = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return function* () {
      }();
    }
  };
  var TLiteral = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return schema.const;
    }
  };
  var TNever = function(schema, references) {
    throw new ValueCreateNeverTypeError(schema);
  };
  var TNot = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      throw new ValueCreateNotTypeError(schema);
    }
  };
  var TNull = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return null;
    }
  };
  var TNumber = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else if (schema.minimum !== undefined) {
      return schema.minimum;
    } else {
      return 0;
    }
  };
  var TObject = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      const required = new Set(schema.required);
      return schema.default || Object.entries(schema.properties).reduce((acc, [key, schema2]) => {
        return required.has(key) ? { ...acc, [key]: Visit(schema2, references) } : { ...acc };
      }, {});
    }
  };
  var TPromise = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return Promise.resolve(Visit(schema.item, references));
    }
  };
  var TRecord = function(schema, references) {
    const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else if (!(keyPattern === Types.PatternStringExact || keyPattern === Types.PatternNumberExact)) {
      const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
      return propertyKeys.reduce((acc, key) => {
        return { ...acc, [key]: Visit(valueSchema, references) };
      }, {});
    } else {
      return {};
    }
  };
  var TRef = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return Visit((0, deref_1.Deref)(schema, references), references);
    }
  };
  var TString = function(schema, references) {
    if (schema.pattern !== undefined) {
      if (!(0, guard_1.HasPropertyKey)(schema, "default")) {
        throw new Error("ValueCreate.String: String types with patterns must specify a default value");
      } else {
        return schema.default;
      }
    } else if (schema.format !== undefined) {
      if (!(0, guard_1.HasPropertyKey)(schema, "default")) {
        throw new Error("ValueCreate.String: String types with formats must specify a default value");
      } else {
        return schema.default;
      }
    } else {
      if ((0, guard_1.HasPropertyKey)(schema, "default")) {
        return schema.default;
      } else if (schema.minLength !== undefined) {
        return Array.from({ length: schema.minLength }).map(() => ".").join("");
      } else {
        return "";
      }
    }
  };
  var TSymbol = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else if ("value" in schema) {
      return Symbol.for(schema.value);
    } else {
      return Symbol();
    }
  };
  var TTemplateLiteral = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    }
    const expression = Types.TemplateLiteralParser.ParseExact(schema.pattern);
    if (!Types.TemplateLiteralFinite.Check(expression))
      throw new ValueCreateTempateLiteralTypeError(schema);
    const sequence = Types.TemplateLiteralGenerator.Generate(expression);
    return sequence.next().value;
  };
  var TThis = function(schema, references) {
    if (recursiveDepth++ > recursiveMaxDepth)
      throw new ValueCreateRecursiveInstantiationError(schema, recursiveMaxDepth);
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return Visit((0, deref_1.Deref)(schema, references), references);
    }
  };
  var TTuple = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    }
    if (schema.items === undefined) {
      return [];
    } else {
      return Array.from({ length: schema.minItems }).map((_, index) => Visit(schema.items[index], references));
    }
  };
  var TUndefined = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return;
    }
  };
  var TUnion = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else if (schema.anyOf.length === 0) {
      throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
    } else {
      return Visit(schema.anyOf[0], references);
    }
  };
  var TUint8Array = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else if (schema.minByteLength !== undefined) {
      return new Uint8Array(schema.minByteLength);
    } else {
      return new Uint8Array(0);
    }
  };
  var TUnknown = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return {};
    }
  };
  var TVoid = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      return;
    }
  };
  var TKind = function(schema, references) {
    if ((0, guard_1.HasPropertyKey)(schema, "default")) {
      return schema.default;
    } else {
      throw new Error("User defined types must specify a default value");
    }
  };
  var Visit = function(schema, references) {
    const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[Types.Kind]) {
      case "Any":
        return TAny(schema_, references_);
      case "Array":
        return TArray(schema_, references_);
      case "AsyncIterator":
        return TAsyncIterator(schema_, references_);
      case "BigInt":
        return TBigInt(schema_, references_);
      case "Boolean":
        return TBoolean(schema_, references_);
      case "Constructor":
        return TConstructor(schema_, references_);
      case "Date":
        return TDate(schema_, references_);
      case "Function":
        return TFunction(schema_, references_);
      case "Integer":
        return TInteger(schema_, references_);
      case "Intersect":
        return TIntersect(schema_, references_);
      case "Iterator":
        return TIterator(schema_, references_);
      case "Literal":
        return TLiteral(schema_, references_);
      case "Never":
        return TNever(schema_, references_);
      case "Not":
        return TNot(schema_, references_);
      case "Null":
        return TNull(schema_, references_);
      case "Number":
        return TNumber(schema_, references_);
      case "Object":
        return TObject(schema_, references_);
      case "Promise":
        return TPromise(schema_, references_);
      case "Record":
        return TRecord(schema_, references_);
      case "Ref":
        return TRef(schema_, references_);
      case "String":
        return TString(schema_, references_);
      case "Symbol":
        return TSymbol(schema_, references_);
      case "TemplateLiteral":
        return TTemplateLiteral(schema_, references_);
      case "This":
        return TThis(schema_, references_);
      case "Tuple":
        return TTuple(schema_, references_);
      case "Undefined":
        return TUndefined(schema_, references_);
      case "Union":
        return TUnion(schema_, references_);
      case "Uint8Array":
        return TUint8Array(schema_, references_);
      case "Unknown":
        return TUnknown(schema_, references_);
      case "Void":
        return TVoid(schema_, references_);
      default:
        if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
          throw new ValueCreateUnknownTypeError(schema_);
        return TKind(schema_, references_);
    }
  };
  var Create = function(...args2) {
    recursiveDepth = 0;
    return args2.length === 2 ? Visit(args2[0], args2[1]) : Visit(args2[0], []);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Create = exports.ValueCreateRecursiveInstantiationError = exports.ValueCreateTempateLiteralTypeError = exports.ValueCreateIntersectTypeError = exports.ValueCreateNotTypeError = exports.ValueCreateNeverTypeError = exports.ValueCreateUnknownTypeError = undefined;
  var guard_1 = require_guard();
  var check_1 = require_check();
  var deref_1 = require_deref();
  var Types = require_typebox();

  class ValueCreateUnknownTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  exports.ValueCreateUnknownTypeError = ValueCreateUnknownTypeError;

  class ValueCreateNeverTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Never types cannot be created");
      this.schema = schema;
    }
  }
  exports.ValueCreateNeverTypeError = ValueCreateNeverTypeError;

  class ValueCreateNotTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Not types must have a default value");
      this.schema = schema;
    }
  }
  exports.ValueCreateNotTypeError = ValueCreateNotTypeError;

  class ValueCreateIntersectTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Intersect produced invalid value. Consider using a default value.");
      this.schema = schema;
    }
  }
  exports.ValueCreateIntersectTypeError = ValueCreateIntersectTypeError;

  class ValueCreateTempateLiteralTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Can only create template literal values from patterns that produce finite sequences. Consider using a default value.");
      this.schema = schema;
    }
  }
  exports.ValueCreateTempateLiteralTypeError = ValueCreateTempateLiteralTypeError;

  class ValueCreateRecursiveInstantiationError extends Types.TypeBoxError {
    constructor(schema, recursiveMaxDepth2) {
      super("Value cannot be created as recursive type may produce value of infinite size. Consider using a default.");
      this.schema = schema;
      this.recursiveMaxDepth = recursiveMaxDepth2;
    }
  }
  exports.ValueCreateRecursiveInstantiationError = ValueCreateRecursiveInstantiationError;
  var recursiveMaxDepth = 512;
  var recursiveDepth = 0;
  exports.Create = Create;
});

// node_modules/@libsql/hrana-client/lib-esm/en
var require_cast = __commonJS((exports) => {
  var DefaultClone = function(schema, references, value) {
    return (0, check_1.Check)(schema, references, value) ? (0, clone_1.Clone)(value) : (0, create_1.Create)(schema, references);
  };
  var Default = function(schema, references, value) {
    return (0, check_1.Check)(schema, references, value) ? value : (0, create_1.Create)(schema, references);
  };
  var TArray = function(schema, references, value) {
    if ((0, check_1.Check)(schema, references, value))
      return (0, clone_1.Clone)(value);
    const created = (0, guard_1.IsArray)(value) ? (0, clone_1.Clone)(value) : (0, create_1.Create)(schema, references);
    const minimum = (0, guard_1.IsNumber)(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
    const maximum = (0, guard_1.IsNumber)(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
    const casted = maximum.map((value2) => Visit(schema.items, references, value2));
    if (schema.uniqueItems !== true)
      return casted;
    const unique = [...new Set(casted)];
    if (!(0, check_1.Check)(schema, references, unique))
      throw new ValueCastArrayUniqueItemsTypeError(schema, unique);
    return unique;
  };
  var TConstructor = function(schema, references, value) {
    if ((0, check_1.Check)(schema, references, value))
      return (0, create_1.Create)(schema, references);
    const required = new Set(schema.returns.required || []);
    const result = function() {
    };
    for (const [key, property] of Object.entries(schema.returns.properties)) {
      if (!required.has(key) && value.prototype[key] === undefined)
        continue;
      result.prototype[key] = Visit(property, references, value.prototype[key]);
    }
    return result;
  };
  var TIntersect = function(schema, references, value) {
    const created = (0, create_1.Create)(schema, references);
    const mapped = (0, guard_1.IsPlainObject)(created) && (0, guard_1.IsPlainObject)(value) ? { ...created, ...value } : value;
    return (0, check_1.Check)(schema, references, mapped) ? mapped : (0, create_1.Create)(schema, references);
  };
  var TNever = function(schema, references, value) {
    throw new ValueCastNeverTypeError(schema);
  };
  var TObject = function(schema, references, value) {
    if ((0, check_1.Check)(schema, references, value))
      return value;
    if (value === null || typeof value !== "object")
      return (0, create_1.Create)(schema, references);
    const required = new Set(schema.required || []);
    const result = {};
    for (const [key, property] of Object.entries(schema.properties)) {
      if (!required.has(key) && value[key] === undefined)
        continue;
      result[key] = Visit(property, references, value[key]);
    }
    if (typeof schema.additionalProperties === "object") {
      const propertyNames = Object.getOwnPropertyNames(schema.properties);
      for (const propertyName of Object.getOwnPropertyNames(value)) {
        if (propertyNames.includes(propertyName))
          continue;
        result[propertyName] = Visit(schema.additionalProperties, references, value[propertyName]);
      }
    }
    return result;
  };
  var TRecord = function(schema, references, value) {
    if ((0, check_1.Check)(schema, references, value))
      return (0, clone_1.Clone)(value);
    if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
      return (0, create_1.Create)(schema, references);
    const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const subschema = schema.patternProperties[subschemaPropertyName];
    const result = {};
    for (const [propKey, propValue] of Object.entries(value)) {
      result[propKey] = Visit(subschema, references, propValue);
    }
    return result;
  };
  var TRef = function(schema, references, value) {
    return Visit((0, deref_1.Deref)(schema, references), references, value);
  };
  var TThis = function(schema, references, value) {
    return Visit((0, deref_1.Deref)(schema, references), references, value);
  };
  var TTuple = function(schema, references, value) {
    if ((0, check_1.Check)(schema, references, value))
      return (0, clone_1.Clone)(value);
    if (!(0, guard_1.IsArray)(value))
      return (0, create_1.Create)(schema, references);
    if (schema.items === undefined)
      return [];
    return schema.items.map((schema2, index) => Visit(schema2, references, value[index]));
  };
  var TUnion = function(schema, references, value) {
    return (0, check_1.Check)(schema, references, value) ? (0, clone_1.Clone)(value) : UnionCastCreate.Create(schema, references, value);
  };
  var Visit = function(schema, references, value) {
    const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[Types.Kind]) {
      case "Array":
        return TArray(schema_, references_, value);
      case "Constructor":
        return TConstructor(schema_, references_, value);
      case "Intersect":
        return TIntersect(schema_, references_, value);
      case "Never":
        return TNever(schema_, references_, value);
      case "Object":
        return TObject(schema_, references_, value);
      case "Record":
        return TRecord(schema_, references_, value);
      case "Ref":
        return TRef(schema_, references_, value);
      case "This":
        return TThis(schema_, references_, value);
      case "Tuple":
        return TTuple(schema_, references_, value);
      case "Union":
        return TUnion(schema_, references_, value);
      case "Date":
      case "Symbol":
      case "Uint8Array":
        return DefaultClone(schema, references, value);
      case "Any":
      case "AsyncIterator":
      case "BigInt":
      case "Boolean":
      case "Function":
      case "Integer":
      case "Iterator":
      case "Literal":
      case "Not":
      case "Null":
      case "Number":
      case "Promise":
      case "String":
      case "TemplateLiteral":
      case "Undefined":
      case "Unknown":
      case "Void":
        return Default(schema_, references_, value);
      default:
        if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
          throw new ValueCastUnknownTypeError(schema_);
        return Default(schema_, references_, value);
    }
  };
  var Cast = function(...args2) {
    return args2.length === 3 ? Visit(args2[0], args2[1], args2[2]) : Visit(args2[0], [], args2[1]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Cast = exports.Default = exports.DefaultClone = exports.ValueCastUnknownTypeError = exports.ValueCastRecursiveTypeError = exports.ValueCastNeverTypeError = exports.ValueCastArrayUniqueItemsTypeError = undefined;
  var guard_1 = require_guard();
  var create_1 = require_create();
  var check_1 = require_check();
  var clone_1 = require_clone();
  var deref_1 = require_deref();
  var Types = require_typebox();

  class ValueCastArrayUniqueItemsTypeError extends Types.TypeBoxError {
    constructor(schema, value) {
      super("Array cast produced invalid data due to uniqueItems constraint");
      this.schema = schema;
      this.value = value;
    }
  }
  exports.ValueCastArrayUniqueItemsTypeError = ValueCastArrayUniqueItemsTypeError;

  class ValueCastNeverTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Never types cannot be cast");
      this.schema = schema;
    }
  }
  exports.ValueCastNeverTypeError = ValueCastNeverTypeError;

  class ValueCastRecursiveTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Cannot cast recursive schemas");
      this.schema = schema;
    }
  }
  exports.ValueCastRecursiveTypeError = ValueCastRecursiveTypeError;

  class ValueCastUnknownTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  exports.ValueCastUnknownTypeError = ValueCastUnknownTypeError;
  var UnionCastCreate;
  (function(UnionCastCreate2) {
    function Score(schema, references, value) {
      if (schema[Types.Kind] === "Object" && typeof value === "object" && !(0, guard_1.IsNull)(value)) {
        const object = schema;
        const keys = Object.getOwnPropertyNames(value);
        const entries = Object.entries(object.properties);
        const [point, max] = [1 / entries.length, entries.length];
        return entries.reduce((acc, [key, schema2]) => {
          const literal = schema2[Types.Kind] === "Literal" && schema2.const === value[key] ? max : 0;
          const checks = (0, check_1.Check)(schema2, references, value[key]) ? point : 0;
          const exists = keys.includes(key) ? point : 0;
          return acc + (literal + checks + exists);
        }, 0);
      } else {
        return (0, check_1.Check)(schema, references, value) ? 1 : 0;
      }
    }
    function Select(union, references, value) {
      let [select, best] = [union.anyOf[0], 0];
      for (const schema of union.anyOf) {
        const score = Score(schema, references, value);
        if (score > best) {
          select = schema;
          best = score;
        }
      }
      return select;
    }
    function Create(union, references, value) {
      if ("default" in union) {
        return union.default;
      } else {
        const schema = Select(union, references, value);
        return Cast(schema, references, value);
      }
    }
    UnionCastCreate2.Create = Create;
  })(UnionCastCreate || (UnionCastCreate = {}));
  exports.DefaultClone = DefaultClone;
  exports.Default = Default;
  exports.Cast = Cast;
});

// node_modules/@libsql/hrana-client/lib-esm/encod
var require_convert = __commonJS((exports) => {
  var IsStringNumeric = function(value) {
    return (0, guard_1.IsString)(value) && !isNaN(value) && !isNaN(parseFloat(value));
  };
  var IsValueToString = function(value) {
    return (0, guard_1.IsBigInt)(value) || (0, guard_1.IsBoolean)(value) || (0, guard_1.IsNumber)(value);
  };
  var IsValueTrue = function(value) {
    return value === true || (0, guard_1.IsNumber)(value) && value === 1 || (0, guard_1.IsBigInt)(value) && value === BigInt("1") || (0, guard_1.IsString)(value) && (value.toLowerCase() === "true" || value === "1");
  };
  var IsValueFalse = function(value) {
    return value === false || (0, guard_1.IsNumber)(value) && (value === 0 || Object.is(value, -0)) || (0, guard_1.IsBigInt)(value) && value === BigInt("0") || (0, guard_1.IsString)(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
  };
  var IsTimeStringWithTimeZone = function(value) {
    return (0, guard_1.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
  };
  var IsTimeStringWithoutTimeZone = function(value) {
    return (0, guard_1.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
  };
  var IsDateTimeStringWithTimeZone = function(value) {
    return (0, guard_1.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
  };
  var IsDateTimeStringWithoutTimeZone = function(value) {
    return (0, guard_1.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
  };
  var IsDateString = function(value) {
    return (0, guard_1.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
  };
  var TryConvertLiteralString = function(value, target) {
    const conversion = TryConvertString(value);
    return conversion === target ? conversion : value;
  };
  var TryConvertLiteralNumber = function(value, target) {
    const conversion = TryConvertNumber(value);
    return conversion === target ? conversion : value;
  };
  var TryConvertLiteralBoolean = function(value, target) {
    const conversion = TryConvertBoolean(value);
    return conversion === target ? conversion : value;
  };
  var TryConvertLiteral = function(schema, value) {
    if (typeof schema.const === "string") {
      return TryConvertLiteralString(value, schema.const);
    } else if (typeof schema.const === "number") {
      return TryConvertLiteralNumber(value, schema.const);
    } else if (typeof schema.const === "boolean") {
      return TryConvertLiteralBoolean(value, schema.const);
    } else {
      return (0, clone_1.Clone)(value);
    }
  };
  var TryConvertBoolean = function(value) {
    return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
  };
  var TryConvertBigInt = function(value) {
    return IsStringNumeric(value) ? BigInt(parseInt(value)) : (0, guard_1.IsNumber)(value) ? BigInt(value | 0) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
  };
  var TryConvertString = function(value) {
    return IsValueToString(value) ? value.toString() : (0, guard_1.IsSymbol)(value) && value.description !== undefined ? value.description.toString() : value;
  };
  var TryConvertNumber = function(value) {
    return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
  };
  var TryConvertInteger = function(value) {
    return IsStringNumeric(value) ? parseInt(value) : (0, guard_1.IsNumber)(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
  };
  var TryConvertNull = function(value) {
    return (0, guard_1.IsString)(value) && value.toLowerCase() === "null" ? null : value;
  };
  var TryConvertUndefined = function(value) {
    return (0, guard_1.IsString)(value) && value === "undefined" ? undefined : value;
  };
  var TryConvertDate = function(value) {
    return (0, guard_1.IsDate)(value) ? value : (0, guard_1.IsNumber)(value) ? new Date(value) : IsValueTrue(value) ? new Date(1) : IsValueFalse(value) ? new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) : value;
  };
  var Default = function(value) {
    return value;
  };
  var TArray = function(schema, references, value) {
    if ((0, guard_1.IsArray)(value)) {
      return value.map((value2) => Visit(schema.items, references, value2));
    }
    return value;
  };
  var TBigInt = function(schema, references, value) {
    return TryConvertBigInt(value);
  };
  var TBoolean = function(schema, references, value) {
    return TryConvertBoolean(value);
  };
  var TDate = function(schema, references, value) {
    return TryConvertDate(value);
  };
  var TInteger = function(schema, references, value) {
    return TryConvertInteger(value);
  };
  var TIntersect = function(schema, references, value) {
    return schema.allOf.every((schema2) => Types.TypeGuard.TObject(schema2)) ? Visit(Types.Type.Composite(schema.allOf), references, value) : Visit(schema.allOf[0], references, value);
  };
  var TLiteral = function(schema, references, value) {
    return TryConvertLiteral(schema, value);
  };
  var TNull = function(schema, references, value) {
    return TryConvertNull(value);
  };
  var TNumber = function(schema, references, value) {
    return TryConvertNumber(value);
  };
  var TObject = function(schema, references, value) {
    if ((0, guard_1.IsObject)(value))
      return Object.getOwnPropertyNames(schema.properties).reduce((acc, key) => {
        return value[key] !== undefined ? { ...acc, [key]: Visit(schema.properties[key], references, value[key]) } : { ...acc };
      }, value);
    return value;
  };
  var TRecord = function(schema, references, value) {
    const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const property = schema.patternProperties[propertyKey];
    const result = {};
    for (const [propKey, propValue] of Object.entries(value)) {
      result[propKey] = Visit(property, references, propValue);
    }
    return result;
  };
  var TRef = function(schema, references, value) {
    return Visit((0, deref_1.Deref)(schema, references), references, value);
  };
  var TString = function(schema, references, value) {
    return TryConvertString(value);
  };
  var TSymbol = function(schema, references, value) {
    return (0, guard_1.IsString)(value) || (0, guard_1.IsNumber)(value) ? Symbol(value) : value;
  };
  var TThis = function(schema, references, value) {
    return Visit((0, deref_1.Deref)(schema, references), references, value);
  };
  var TTuple = function(schema, references, value) {
    if ((0, guard_1.IsArray)(value) && !(0, guard_1.IsUndefined)(schema.items)) {
      return value.map((value2, index) => {
        return index < schema.items.length ? Visit(schema.items[index], references, value2) : value2;
      });
    }
    return value;
  };
  var TUndefined = function(schema, references, value) {
    return TryConvertUndefined(value);
  };
  var TUnion = function(schema, references, value) {
    for (const subschema of schema.anyOf) {
      const converted = Visit(subschema, references, value);
      if ((0, check_1.Check)(subschema, references, converted)) {
        return converted;
      }
    }
    return value;
  };
  var Visit = function(schema, references, value) {
    const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[Types.Kind]) {
      case "Array":
        return TArray(schema_, references_, value);
      case "BigInt":
        return TBigInt(schema_, references_, value);
      case "Boolean":
        return TBoolean(schema_, references_, value);
      case "Date":
        return TDate(schema_, references_, value);
      case "Integer":
        return TInteger(schema_, references_, value);
      case "Intersect":
        return TIntersect(schema_, references_, value);
      case "Literal":
        return TLiteral(schema_, references_, value);
      case "Null":
        return TNull(schema_, references_, value);
      case "Number":
        return TNumber(schema_, references_, value);
      case "Object":
        return TObject(schema_, references_, value);
      case "Record":
        return TRecord(schema_, references_, value);
      case "Ref":
        return TRef(schema_, references_, value);
      case "String":
        return TString(schema_, references_, value);
      case "Symbol":
        return TSymbol(schema_, references_, value);
      case "This":
        return TThis(schema_, references_, value);
      case "Tuple":
        return TTuple(schema_, references_, value);
      case "Undefined":
        return TUndefined(schema_, references_, value);
      case "Union":
        return TUnion(schema_, references_, value);
      case "Any":
      case "AsyncIterator":
      case "Constructor":
      case "Function":
      case "Iterator":
      case "Never":
      case "Promise":
      case "TemplateLiteral":
      case "Uint8Array":
      case "Unknown":
      case "Void":
        return Default(value);
      default:
        if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
          throw new ValueConvertUnknownTypeError(schema_);
        return Default(value);
    }
  };
  var Convert = function(...args2) {
    return args2.length === 3 ? Visit(args2[0], args2[1], args2[2]) : Visit(args2[0], [], args2[1]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Convert = exports.Default = exports.ValueConvertUnknownTypeError = undefined;
  var guard_1 = require_guard();
  var clone_1 = require_clone();
  var check_1 = require_check();
  var deref_1 = require_deref();
  var Types = require_typebox();

  class ValueConvertUnknownTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  exports.ValueConvertUnknownTypeError = ValueConvertUnknownTypeError;
  exports.Default = Default;
  exports.Convert = Convert;
});

// node_modules/@libsql/hrana-client/lib-esm/encodin
var require_transform = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EncodeTransform = exports.DecodeTransform = exports.HasTransform = exports.TransformEncodeError = exports.TransformDecodeError = exports.TransformEncodeCheckError = exports.TransformDecodeCheckError = exports.TransformUnknownTypeError = undefined;
  var guard_1 = require_guard();
  var deref_1 = require_deref();
  var Types = require_typebox();

  class TransformUnknownTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super(`Unknown type`);
      this.schema = schema;
    }
  }
  exports.TransformUnknownTypeError = TransformUnknownTypeError;

  class TransformDecodeCheckError extends Types.TypeBoxError {
    constructor(schema, value, error5) {
      super(`Unable to decode due to invalid value`);
      this.schema = schema;
      this.value = value;
      this.error = error5;
    }
  }
  exports.TransformDecodeCheckError = TransformDecodeCheckError;

  class TransformEncodeCheckError extends Types.TypeBoxError {
    constructor(schema, value, error5) {
      super(`Unable to encode due to invalid value`);
      this.schema = schema;
      this.value = value;
      this.error = error5;
    }
  }
  exports.TransformEncodeCheckError = TransformEncodeCheckError;

  class TransformDecodeError extends Types.TypeBoxError {
    constructor(schema, value, error5) {
      super(`${error5 instanceof Error ? error5.message : "Unknown error"}`);
      this.schema = schema;
      this.value = value;
    }
  }
  exports.TransformDecodeError = TransformDecodeError;

  class TransformEncodeError extends Types.TypeBoxError {
    constructor(schema, value, error5) {
      super(`${error5 instanceof Error ? error5.message : "Unknown error"}`);
      this.schema = schema;
      this.value = value;
    }
  }
  exports.TransformEncodeError = TransformEncodeError;
  var HasTransform;
  (function(HasTransform2) {
    function TArray(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Visit(schema.items, references);
    }
    function TAsyncIterator(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Visit(schema.items, references);
    }
    function TConstructor(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Visit(schema.returns, references) || schema.parameters.some((schema2) => Visit(schema2, references));
    }
    function TFunction(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Visit(schema.returns, references) || schema.parameters.some((schema2) => Visit(schema2, references));
    }
    function TIntersect(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Types.TypeGuard.TTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit(schema2, references));
    }
    function TIterator(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Visit(schema.items, references);
    }
    function TNot(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Visit(schema.not, references);
    }
    function TObject(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Object.values(schema.properties).some((schema2) => Visit(schema2, references)) || Types.TypeGuard.TSchema(schema.additionalProperties) && Visit(schema.additionalProperties, references);
    }
    function TPromise(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Visit(schema.item, references);
    }
    function TRecord(schema, references) {
      const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
      const property = schema.patternProperties[pattern];
      return Types.TypeGuard.TTransform(schema) || Visit(property, references) || Types.TypeGuard.TSchema(schema.additionalProperties) && Types.TypeGuard.TTransform(schema.additionalProperties);
    }
    function TRef(schema, references) {
      if (Types.TypeGuard.TTransform(schema))
        return true;
      return Visit((0, deref_1.Deref)(schema, references), references);
    }
    function TThis(schema, references) {
      if (Types.TypeGuard.TTransform(schema))
        return true;
      return Visit((0, deref_1.Deref)(schema, references), references);
    }
    function TTuple(schema, references) {
      return Types.TypeGuard.TTransform(schema) || Types.TypeGuard.TSchema(schema.items) && schema.items.some((schema2) => Visit(schema2, references));
    }
    function TUnion(schema, references) {
      return Types.TypeGuard.TTransform(schema) || schema.anyOf.some((schema2) => Visit(schema2, references));
    }
    function Visit(schema, references) {
      const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;
      const schema_ = schema;
      if (schema.$id && visited.has(schema.$id))
        return false;
      if (schema.$id)
        visited.add(schema.$id);
      switch (schema[Types.Kind]) {
        case "Array":
          return TArray(schema_, references_);
        case "AsyncIterator":
          return TAsyncIterator(schema_, references_);
        case "Constructor":
          return TConstructor(schema_, references_);
        case "Function":
          return TFunction(schema_, references_);
        case "Intersect":
          return TIntersect(schema_, references_);
        case "Iterator":
          return TIterator(schema_, references_);
        case "Not":
          return TNot(schema_, references_);
        case "Object":
          return TObject(schema_, references_);
        case "Promise":
          return TPromise(schema_, references_);
        case "Record":
          return TRecord(schema_, references_);
        case "Ref":
          return TRef(schema_, references_);
        case "This":
          return TThis(schema_, references_);
        case "Tuple":
          return TTuple(schema_, references_);
        case "Union":
          return TUnion(schema_, references_);
        case "Any":
        case "BigInt":
        case "Boolean":
        case "Date":
        case "Integer":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "String":
        case "Symbol":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Types.TypeGuard.TTransform(schema);
        default:
          if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
            throw new TransformUnknownTypeError(schema_);
          return Types.TypeGuard.TTransform(schema);
      }
    }
    const visited = new Set;
    function Has(schema, references) {
      visited.clear();
      return Visit(schema, references);
    }
    HasTransform2.Has = Has;
  })(HasTransform || (exports.HasTransform = HasTransform = {}));
  var DecodeTransform;
  (function(DecodeTransform2) {
    function Default(schema, value) {
      try {
        return Types.TypeGuard.TTransform(schema) ? schema[Types.Transform].Decode(value) : value;
      } catch (error5) {
        throw new TransformDecodeError(schema, value, error5);
      }
    }
    function TArray(schema, references, value) {
      const elements1 = value.map((value2) => Visit(schema.items, references, value2));
      return Default(schema, elements1);
    }
    function TIntersect(schema, references, value) {
      if (!(0, guard_1.IsPlainObject)(value) || (0, guard_1.IsValueType)(value))
        return Default(schema, value);
      const keys = Types.KeyResolver.ResolveKeys(schema, { includePatterns: false });
      const properties1 = Object.entries(value).reduce((acc, [key, value2]) => {
        return !keys.includes(key) ? { ...acc, [key]: value2 } : { ...acc, [key]: Default(Types.IndexedAccessor.Resolve(schema, [key]), value2) };
      }, {});
      if (!Types.TypeGuard.TTransform(schema.unevaluatedProperties))
        return Default(schema, properties1);
      const properties2 = Object.entries(properties1).reduce((acc, [key, value2]) => {
        return keys.includes(key) ? { ...acc, [key]: value2 } : { ...acc, [key]: Default(schema.unevaluatedProperties, value2) };
      }, {});
      return Default(schema, properties2);
    }
    function TNot(schema, references, value) {
      const value1 = Visit(schema.not, references, value);
      return Default(schema, value1);
    }
    function TObject(schema, references, value) {
      if (!(0, guard_1.IsPlainObject)(value))
        return Default(schema, value);
      const properties1 = Object.entries(value).reduce((acc, [key, value2]) => {
        return !(key in schema.properties) ? { ...acc, [key]: value2 } : { ...acc, [key]: Visit(schema.properties[key], references, value2) };
      }, {});
      if (!Types.TypeGuard.TSchema(schema.additionalProperties))
        return Default(schema, properties1);
      const additionalProperties = schema.additionalProperties;
      const properties2 = Object.entries(properties1).reduce((acc, [key, value2]) => {
        return key in schema.properties ? { ...acc, [key]: value2 } : { ...acc, [key]: Visit(additionalProperties, references, value2) };
      }, {});
      return Default(schema, properties2);
    }
    function TRecord(schema, references, value) {
      if (!(0, guard_1.IsPlainObject)(value))
        return Default(schema, value);
      const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
      const property = schema.patternProperties[pattern];
      const regex = new RegExp(pattern);
      const properties1 = Object.entries(value).reduce((acc, [key, value2]) => {
        return !regex.test(key) ? { ...acc, [key]: value2 } : { ...acc, [key]: Visit(property, references, value2) };
      }, {});
      if (!Types.TypeGuard.TSchema(schema.additionalProperties))
        return Default(schema, properties1);
      const additionalProperties = schema.additionalProperties;
      const properties2 = Object.entries(properties1).reduce((acc, [key, value2]) => {
        return regex.test(key) ? { ...acc, [key]: value2 } : { ...acc, [key]: Visit(additionalProperties, references, value2) };
      }, {});
      return Default(schema, properties2);
    }
    function TRef(schema, references, value) {
      const target = (0, deref_1.Deref)(schema, references);
      const resolved = Visit(target, references, value);
      return Default(schema, resolved);
    }
    function TThis(schema, references, value) {
      const target = (0, deref_1.Deref)(schema, references);
      const resolved = Visit(target, references, value);
      return Default(schema, resolved);
    }
    function TTuple(schema, references, value) {
      const value1 = (0, guard_1.IsArray)(schema.items) ? schema.items.map((schema2, index) => Visit(schema2, references, value[index])) : [];
      return Default(schema, value1);
    }
    function TUnion(schema, references, value) {
      const value1 = Default(schema, value);
      for (const subschema of schema.anyOf) {
        if (!checkFunction(subschema, references, value1))
          continue;
        return Visit(subschema, references, value1);
      }
      return value1;
    }
    function Visit(schema, references, value) {
      const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
      const schema_ = schema;
      switch (schema[Types.Kind]) {
        case "Array":
          return TArray(schema_, references_, value);
        case "Intersect":
          return TIntersect(schema_, references_, value);
        case "Not":
          return TNot(schema_, references_, value);
        case "Object":
          return TObject(schema_, references_, value);
        case "Record":
          return TRecord(schema_, references_, value);
        case "Ref":
          return TRef(schema_, references_, value);
        case "Symbol":
          return Default(schema_, value);
        case "This":
          return TThis(schema_, references_, value);
        case "Tuple":
          return TTuple(schema_, references_, value);
        case "Union":
          return TUnion(schema_, references_, value);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Constructor":
        case "Date":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Default(schema_, value);
        default:
          if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
            throw new TransformUnknownTypeError(schema_);
          return Default(schema_, value);
      }
    }
    let checkFunction = () => false;
    function Decode(schema, references, value, check) {
      checkFunction = check;
      return Visit(schema, references, value);
    }
    DecodeTransform2.Decode = Decode;
  })(DecodeTransform || (exports.DecodeTransform = DecodeTransform = {}));
  var EncodeTransform;
  (function(EncodeTransform2) {
    function Default(schema, value) {
      try {
        return Types.TypeGuard.TTransform(schema) ? schema[Types.Transform].Encode(value) : value;
      } catch (error5) {
        throw new TransformEncodeError(schema, value, error5);
      }
    }
    function TArray(schema, references, value) {
      const elements1 = Default(schema, value);
      return elements1.map((value2) => Visit(schema.items, references, value2));
    }
    function TIntersect(schema, references, value) {
      const properties1 = Default(schema, value);
      if (!(0, guard_1.IsPlainObject)(value) || (0, guard_1.IsValueType)(value))
        return properties1;
      const keys = Types.KeyResolver.ResolveKeys(schema, { includePatterns: false });
      const properties2 = Object.entries(properties1).reduce((acc, [key, value2]) => {
        return !keys.includes(key) ? { ...acc, [key]: value2 } : { ...acc, [key]: Default(Types.IndexedAccessor.Resolve(schema, [key]), value2) };
      }, {});
      if (!Types.TypeGuard.TTransform(schema.unevaluatedProperties))
        return Default(schema, properties2);
      return Object.entries(properties2).reduce((acc, [key, value2]) => {
        return keys.includes(key) ? { ...acc, [key]: value2 } : { ...acc, [key]: Default(schema.unevaluatedProperties, value2) };
      }, {});
    }
    function TNot(schema, references, value) {
      const value1 = Default(schema, value);
      return Default(schema.not, value1);
    }
    function TObject(schema, references, value) {
      const properties1 = Default(schema, value);
      if (!(0, guard_1.IsPlainObject)(value))
        return properties1;
      const properties2 = Object.entries(properties1).reduce((acc, [key, value2]) => {
        return !(key in schema.properties) ? { ...acc, [key]: value2 } : { ...acc, [key]: Visit(schema.properties[key], references, value2) };
      }, {});
      if (!Types.TypeGuard.TSchema(schema.additionalProperties))
        return properties2;
      const additionalProperties = schema.additionalProperties;
      return Object.entries(properties2).reduce((acc, [key, value2]) => {
        return key in schema.properties ? { ...acc, [key]: value2 } : { ...acc, [key]: Visit(additionalProperties, references, value2) };
      }, {});
    }
    function TRecord(schema, references, value) {
      const properties1 = Default(schema, value);
      if (!(0, guard_1.IsPlainObject)(value))
        return properties1;
      const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
      const property = schema.patternProperties[pattern];
      const regex = new RegExp(pattern);
      const properties2 = Object.entries(properties1).reduce((acc, [key, value2]) => {
        return !regex.test(key) ? { ...acc, [key]: value2 } : { ...acc, [key]: Visit(property, references, value2) };
      }, {});
      if (!Types.TypeGuard.TSchema(schema.additionalProperties))
        return Default(schema, properties2);
      const additionalProperties = schema.additionalProperties;
      return Object.entries(properties2).reduce((acc, [key, value2]) => {
        return regex.test(key) ? { ...acc, [key]: value2 } : { ...acc, [key]: Visit(additionalProperties, references, value2) };
      }, {});
    }
    function TRef(schema, references, value) {
      const target = (0, deref_1.Deref)(schema, references);
      const resolved = Visit(target, references, value);
      return Default(schema, resolved);
    }
    function TThis(schema, references, value) {
      const target = (0, deref_1.Deref)(schema, references);
      const resolved = Visit(target, references, value);
      return Default(schema, resolved);
    }
    function TTuple(schema, references, value) {
      const value1 = Default(schema, value);
      return (0, guard_1.IsArray)(schema.items) ? schema.items.map((schema2, index) => Visit(schema2, references, value1[index])) : [];
    }
    function TUnion(schema, references, value) {
      for (const subschema of schema.anyOf) {
        if (!checkFunction(subschema, references, value))
          continue;
        const value1 = Visit(subschema, references, value);
        return Default(schema, value1);
      }
      return Default(schema, value);
    }
    function Visit(schema, references, value) {
      const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
      const schema_ = schema;
      switch (schema[Types.Kind]) {
        case "Array":
          return TArray(schema_, references_, value);
        case "Intersect":
          return TIntersect(schema_, references_, value);
        case "Not":
          return TNot(schema_, references_, value);
        case "Object":
          return TObject(schema_, references_, value);
        case "Record":
          return TRecord(schema_, references_, value);
        case "Ref":
          return TRef(schema_, references_, value);
        case "This":
          return TThis(schema_, references_, value);
        case "Tuple":
          return TTuple(schema_, references_, value);
        case "Union":
          return TUnion(schema_, references_, value);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Constructor":
        case "Date":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "Symbol":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Default(schema_, value);
        default:
          if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
            throw new TransformUnknownTypeError(schema_);
          return Default(schema_, value);
      }
    }
    let checkFunction = () => false;
    function Encode(schema, references, value, check) {
      checkFunction = check;
      return Visit(schema, references, value);
    }
    EncodeTransform2.Encode = Encode;
  })(EncodeTransform || (exports.EncodeTransform = EncodeTransform = {}));
});

// node_modules/@libsql/hrana-client/lib-esm/enc
var require_value = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Value = undefined;
  var ValueErrors = require_errors2();
  var ValueMutate = require_mutate();
  var ValueHash = require_hash();
  var ValueEqual = require_equal();
  var ValueCast = require_cast();
  var ValueClone = require_clone();
  var ValueConvert = require_convert();
  var ValueCreate = require_create();
  var ValueCheck = require_check();
  var ValueDelta = require_delta();
  var ValueTransform = require_transform();
  var Value;
  (function(Value2) {
    function Cast(...args2) {
      return ValueCast.Cast.apply(ValueCast, args2);
    }
    Value2.Cast = Cast;
    function Create(...args2) {
      return ValueCreate.Create.apply(ValueCreate, args2);
    }
    Value2.Create = Create;
    function Check(...args2) {
      return ValueCheck.Check.apply(ValueCheck, args2);
    }
    Value2.Check = Check;
    function Convert(...args2) {
      return ValueConvert.Convert.apply(ValueConvert, args2);
    }
    Value2.Convert = Convert;
    function Clone(value) {
      return ValueClone.Clone(value);
    }
    Value2.Clone = Clone;
    function Decode(...args2) {
      const [schema, references, value] = args2.length === 3 ? [args2[0], args2[1], args2[2]] : [args2[0], [], args2[1]];
      if (!Check(schema, references, value))
        throw new ValueTransform.TransformDecodeCheckError(schema, value, Errors(schema, references, value).First());
      return ValueTransform.DecodeTransform.Decode(schema, references, value, ValueCheck.Check);
    }
    Value2.Decode = Decode;
    function Encode(...args2) {
      const [schema, references, value] = args2.length === 3 ? [args2[0], args2[1], args2[2]] : [args2[0], [], args2[1]];
      const encoded = ValueTransform.EncodeTransform.Encode(schema, references, value, ValueCheck.Check);
      if (!Check(schema, references, encoded))
        throw new ValueTransform.TransformEncodeCheckError(schema, value, Errors(schema, references, value).First());
      return encoded;
    }
    Value2.Encode = Encode;
    function Errors(...args2) {
      return ValueErrors.Errors.apply(ValueErrors, args2);
    }
    Value2.Errors = Errors;
    function Equal(left, right) {
      return ValueEqual.Equal(left, right);
    }
    Value2.Equal = Equal;
    function Diff(current, next) {
      return ValueDelta.Diff(current, next);
    }
    Value2.Diff = Diff;
    function Hash(value) {
      return ValueHash.Hash(value);
    }
    Value2.Hash = Hash;
    function Patch(current, edits) {
      return ValueDelta.Patch(current, edits);
    }
    Value2.Patch = Patch;
    function Mutate(current, next) {
      ValueMutate.Mutate(current, next);
    }
    Value2.Mutate = Mutate;
  })(Value || (exports.Value = Value = {}));
});

// node_modules/@libsql/hrana-client/lib-esm/enc
var require_value2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Value = exports.ValuePointer = exports.Delete = exports.Update = exports.Insert = exports.Edit = exports.ValueErrorIterator = exports.ValueErrorType = undefined;
  var index_1 = require_errors2();
  Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
    return index_1.ValueErrorType;
  } });
  Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
    return index_1.ValueErrorIterator;
  } });
  var delta_1 = require_delta();
  Object.defineProperty(exports, "Edit", { enumerable: true, get: function() {
    return delta_1.Edit;
  } });
  Object.defineProperty(exports, "Insert", { enumerable: true, get: function() {
    return delta_1.Insert;
  } });
  Object.defineProperty(exports, "Update", { enumerable: true, get: function() {
    return delta_1.Update;
  } });
  Object.defineProperty(exports, "Delete", { enumerable: true, get: function() {
    return delta_1.Delete;
  } });
  var pointer_1 = require_pointer();
  Object.defineProperty(exports, "ValuePointer", { enumerable: true, get: function() {
    return pointer_1.ValuePointer;
  } });
  var value_1 = require_value();
  Object.defineProperty(exports, "Value", { enumerable: true, get: function() {
    return value_1.Value;
  } });
});

// node_modules/@libsql/hrana-client/lib-esm/encoding/
var require_compiler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeCompiler = exports.Policy = exports.TypeCompilerTypeGuardError = exports.TypeCompilerUnknownTypeError = exports.TypeCheck = undefined;
  var transform_1 = require_transform();
  var guard_1 = require_guard();
  var errors_1 = require_errors();
  var index_1 = require_system2();
  var deref_1 = require_deref();
  var hash_1 = require_hash();
  var Types = require_typebox();

  class TypeCheck {
    constructor(schema, references, checkFunc, code) {
      this.schema = schema;
      this.references = references;
      this.checkFunc = checkFunc;
      this.code = code;
      this.hasTransform = transform_1.HasTransform.Has(schema, references);
    }
    Code() {
      return this.code;
    }
    Errors(value) {
      return (0, errors_1.Errors)(this.schema, this.references, value);
    }
    Check(value) {
      return this.checkFunc(value);
    }
    Decode(value) {
      if (!this.checkFunc(value))
        throw new transform_1.TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
      return this.hasTransform ? transform_1.DecodeTransform.Decode(this.schema, this.references, value, (_, __, value2) => this.Check(value2)) : value;
    }
    Encode(value) {
      const encoded = this.hasTransform ? transform_1.EncodeTransform.Encode(this.schema, this.references, value, (_, __, value2) => this.Check(value2)) : value;
      if (!this.checkFunc(encoded))
        throw new transform_1.TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
      return encoded;
    }
  }
  exports.TypeCheck = TypeCheck;
  var Character;
  (function(Character2) {
    function DollarSign(code) {
      return code === 36;
    }
    Character2.DollarSign = DollarSign;
    function IsUnderscore(code) {
      return code === 95;
    }
    Character2.IsUnderscore = IsUnderscore;
    function IsAlpha(code) {
      return code >= 65 && code <= 90 || code >= 97 && code <= 122;
    }
    Character2.IsAlpha = IsAlpha;
    function IsNumeric(code) {
      return code >= 48 && code <= 57;
    }
    Character2.IsNumeric = IsNumeric;
  })(Character || (Character = {}));
  var MemberExpression;
  (function(MemberExpression2) {
    function IsFirstCharacterNumeric(value) {
      if (value.length === 0)
        return false;
      return Character.IsNumeric(value.charCodeAt(0));
    }
    function IsAccessor(value) {
      if (IsFirstCharacterNumeric(value))
        return false;
      for (let i = 0;i < value.length; i++) {
        const code = value.charCodeAt(i);
        const check = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
        if (!check)
          return false;
      }
      return true;
    }
    function EscapeHyphen(key) {
      return key.replace(/'/g, "\\'");
    }
    function Encode(object, key) {
      return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
    }
    MemberExpression2.Encode = Encode;
  })(MemberExpression || (MemberExpression = {}));
  var Identifier;
  (function(Identifier2) {
    function Encode($id) {
      const buffer = [];
      for (let i = 0;i < $id.length; i++) {
        const code = $id.charCodeAt(i);
        if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
          buffer.push($id.charAt(i));
        } else {
          buffer.push(`_${code}_`);
        }
      }
      return buffer.join("").replace(/__/g, "_");
    }
    Identifier2.Encode = Encode;
  })(Identifier || (Identifier = {}));
  var LiteralString;
  (function(LiteralString2) {
    function Escape(content) {
      return content.replace(/'/g, "\\'");
    }
    LiteralString2.Escape = Escape;
  })(LiteralString || (LiteralString = {}));

  class TypeCompilerUnknownTypeError extends Types.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  exports.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError;

  class TypeCompilerTypeGuardError extends Types.TypeBoxError {
    constructor(schema) {
      super("Preflight validation check failed to guard for the given schema");
      this.schema = schema;
    }
  }
  exports.TypeCompilerTypeGuardError = TypeCompilerTypeGuardError;
  var Policy;
  (function(Policy2) {
    function IsExactOptionalProperty(value, key, expression) {
      return index_1.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
    }
    Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
    function IsObjectLike(value) {
      return !index_1.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
    }
    Policy2.IsObjectLike = IsObjectLike;
    function IsRecordLike(value) {
      return !index_1.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
    }
    Policy2.IsRecordLike = IsRecordLike;
    function IsNumberLike(value) {
      return !index_1.TypeSystemPolicy.AllowNaN ? `(typeof ${value} === 'number' && Number.isFinite(${value}))` : `typeof ${value} === 'number'`;
    }
    Policy2.IsNumberLike = IsNumberLike;
    function IsVoidLike(value) {
      return index_1.TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
    }
    Policy2.IsVoidLike = IsVoidLike;
  })(Policy || (exports.Policy = Policy = {}));
  var TypeCompiler;
  (function(TypeCompiler2) {
    function IsAnyOrUnknown(schema) {
      return schema[Types.Kind] === "Any" || schema[Types.Kind] === "Unknown";
    }
    function* TAny(schema, references, value) {
      yield "true";
    }
    function* TArray(schema, references, value) {
      yield `Array.isArray(${value})`;
      const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
      if ((0, guard_1.IsNumber)(schema.maxItems))
        yield `${value}.length <= ${schema.maxItems}`;
      if ((0, guard_1.IsNumber)(schema.minItems))
        yield `${value}.length >= ${schema.minItems}`;
      const elementExpression = CreateExpression(schema.items, references, "value");
      yield `${value}.every((${parameter}) => ${elementExpression})`;
      if (Types.TypeGuard.TSchema(schema.contains) || (0, guard_1.IsNumber)(schema.minContains) || (0, guard_1.IsNumber)(schema.maxContains)) {
        const containsSchema = Types.TypeGuard.TSchema(schema.contains) ? schema.contains : Types.Type.Never();
        const checkExpression = CreateExpression(containsSchema, references, "value");
        const checkMinContains = (0, guard_1.IsNumber)(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
        const checkMaxContains = (0, guard_1.IsNumber)(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
        const checkCount = `const count = ${value}.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
        const check = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
        yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;
      }
      if (schema.uniqueItems === true) {
        const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
        const block = `const set = new Set(); for(const element of value) { ${check} }`;
        yield `((${parameter}) => { ${block} )(${value})`;
      }
    }
    function* TAsyncIterator(schema, references, value) {
      yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
    }
    function* TBigInt(schema, references, value) {
      yield `(typeof ${value} === 'bigint')`;
      if ((0, guard_1.IsBigInt)(schema.exclusiveMaximum))
        yield `${value} < BigInt(${schema.exclusiveMaximum})`;
      if ((0, guard_1.IsBigInt)(schema.exclusiveMinimum))
        yield `${value} > BigInt(${schema.exclusiveMinimum})`;
      if ((0, guard_1.IsBigInt)(schema.maximum))
        yield `${value} <= BigInt(${schema.maximum})`;
      if ((0, guard_1.IsBigInt)(schema.minimum))
        yield `${value} >= BigInt(${schema.minimum})`;
      if ((0, guard_1.IsBigInt)(schema.multipleOf))
        yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
    }
    function* TBoolean(schema, references, value) {
      yield `(typeof ${value} === 'boolean')`;
    }
    function* TConstructor(schema, references, value) {
      yield* Visit(schema.returns, references, `${value}.prototype`);
    }
    function* TDate(schema, references, value) {
      yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
      if ((0, guard_1.IsNumber)(schema.exclusiveMaximumTimestamp))
        yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
      if ((0, guard_1.IsNumber)(schema.exclusiveMinimumTimestamp))
        yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
      if ((0, guard_1.IsNumber)(schema.maximumTimestamp))
        yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
      if ((0, guard_1.IsNumber)(schema.minimumTimestamp))
        yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
      if ((0, guard_1.IsNumber)(schema.multipleOfTimestamp))
        yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
    }
    function* TFunction(schema, references, value) {
      yield `(typeof ${value} === 'function')`;
    }
    function* TInteger(schema, references, value) {
      yield `(typeof ${value} === 'number' && Number.isInteger(${value}))`;
      if ((0, guard_1.IsNumber)(schema.exclusiveMaximum))
        yield `${value} < ${schema.exclusiveMaximum}`;
      if ((0, guard_1.IsNumber)(schema.exclusiveMinimum))
        yield `${value} > ${schema.exclusiveMinimum}`;
      if ((0, guard_1.IsNumber)(schema.maximum))
        yield `${value} <= ${schema.maximum}`;
      if ((0, guard_1.IsNumber)(schema.minimum))
        yield `${value} >= ${schema.minimum}`;
      if ((0, guard_1.IsNumber)(schema.multipleOf))
        yield `(${value} % ${schema.multipleOf}) === 0`;
    }
    function* TIntersect(schema, references, value) {
      const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value)).join(" && ");
      if (schema.unevaluatedProperties === false) {
        const keyCheck = CreateVariable(`${new RegExp(Types.KeyResolver.ResolvePattern(schema))};`);
        const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
        yield `(${check1} && ${check2})`;
      } else if (Types.TypeGuard.TSchema(schema.unevaluatedProperties)) {
        const keyCheck = CreateVariable(`${new RegExp(Types.KeyResolver.ResolvePattern(schema))};`);
        const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
        yield `(${check1} && ${check2})`;
      } else {
        yield `(${check1})`;
      }
    }
    function* TIterator(schema, references, value) {
      yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
    }
    function* TLiteral(schema, references, value) {
      if (typeof schema.const === "number" || typeof schema.const === "boolean") {
        yield `(${value} === ${schema.const})`;
      } else {
        yield `(${value} === '${LiteralString.Escape(schema.const)}')`;
      }
    }
    function* TNever(schema, references, value) {
      yield `false`;
    }
    function* TNot(schema, references, value) {
      const expression = CreateExpression(schema.not, references, value);
      yield `(!${expression})`;
    }
    function* TNull(schema, references, value) {
      yield `(${value} === null)`;
    }
    function* TNumber(schema, references, value) {
      yield Policy.IsNumberLike(value);
      if ((0, guard_1.IsNumber)(schema.exclusiveMaximum))
        yield `${value} < ${schema.exclusiveMaximum}`;
      if ((0, guard_1.IsNumber)(schema.exclusiveMinimum))
        yield `${value} > ${schema.exclusiveMinimum}`;
      if ((0, guard_1.IsNumber)(schema.maximum))
        yield `${value} <= ${schema.maximum}`;
      if ((0, guard_1.IsNumber)(schema.minimum))
        yield `${value} >= ${schema.minimum}`;
      if ((0, guard_1.IsNumber)(schema.multipleOf))
        yield `(${value} % ${schema.multipleOf}) === 0`;
    }
    function* TObject(schema, references, value) {
      yield Policy.IsObjectLike(value);
      if ((0, guard_1.IsNumber)(schema.minProperties))
        yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
      if ((0, guard_1.IsNumber)(schema.maxProperties))
        yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
      const knownKeys = Object.getOwnPropertyNames(schema.properties);
      for (const knownKey of knownKeys) {
        const memberExpression = MemberExpression.Encode(value, knownKey);
        const property = schema.properties[knownKey];
        if (schema.required && schema.required.includes(knownKey)) {
          yield* Visit(property, references, memberExpression);
          if (Types.ExtendsUndefined.Check(property) || IsAnyOrUnknown(property))
            yield `('${knownKey}' in ${value})`;
        } else {
          const expression = CreateExpression(property, references, memberExpression);
          yield Policy.IsExactOptionalProperty(value, knownKey, expression);
        }
      }
      if (schema.additionalProperties === false) {
        if (schema.required && schema.required.length === knownKeys.length) {
          yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
        } else {
          const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
          yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
        }
      }
      if (typeof schema.additionalProperties === "object") {
        const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
      }
    }
    function* TPromise(schema, references, value) {
      yield `(typeof value === 'object' && typeof ${value}.then === 'function')`;
    }
    function* TRecord(schema, references, value) {
      yield Policy.IsRecordLike(value);
      if ((0, guard_1.IsNumber)(schema.minProperties))
        yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
      if ((0, guard_1.IsNumber)(schema.maxProperties))
        yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
      const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
      const variable = CreateVariable(`${new RegExp(patternKey)}`);
      const check1 = CreateExpression(patternSchema, references, "value");
      const check2 = Types.TypeGuard.TSchema(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? "false" : "true";
      const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
      yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
    }
    function* TRef(schema, references, value) {
      const target = (0, deref_1.Deref)(schema, references);
      if (state.functions.has(schema.$ref))
        return yield `${CreateFunctionName(schema.$ref)}(${value})`;
      yield* Visit(target, references, value);
    }
    function* TString(schema, references, value) {
      yield `(typeof ${value} === 'string')`;
      if ((0, guard_1.IsNumber)(schema.maxLength))
        yield `${value}.length <= ${schema.maxLength}`;
      if ((0, guard_1.IsNumber)(schema.minLength))
        yield `${value}.length >= ${schema.minLength}`;
      if (schema.pattern !== undefined) {
        const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
        yield `${variable}.test(${value})`;
      }
      if (schema.format !== undefined) {
        yield `format('${schema.format}', ${value})`;
      }
    }
    function* TSymbol(schema, references, value) {
      yield `(typeof ${value} === 'symbol')`;
    }
    function* TTemplateLiteral(schema, references, value) {
      yield `(typeof ${value} === 'string')`;
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value})`;
    }
    function* TThis(schema, references, value) {
      yield `${CreateFunctionName(schema.$ref)}(${value})`;
    }
    function* TTuple(schema, references, value) {
      yield `Array.isArray(${value})`;
      if (schema.items === undefined)
        return yield `${value}.length === 0`;
      yield `(${value}.length === ${schema.maxItems})`;
      for (let i = 0;i < schema.items.length; i++) {
        const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);
        yield `${expression}`;
      }
    }
    function* TUndefined(schema, references, value) {
      yield `${value} === undefined`;
    }
    function* TUnion(schema, references, value) {
      const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value));
      yield `(${expressions.join(" || ")})`;
    }
    function* TUint8Array(schema, references, value) {
      yield `${value} instanceof Uint8Array`;
      if ((0, guard_1.IsNumber)(schema.maxByteLength))
        yield `(${value}.length <= ${schema.maxByteLength})`;
      if ((0, guard_1.IsNumber)(schema.minByteLength))
        yield `(${value}.length >= ${schema.minByteLength})`;
    }
    function* TUnknown(schema, references, value) {
      yield "true";
    }
    function* TVoid(schema, references, value) {
      yield Policy.IsVoidLike(value);
    }
    function* TKind(schema, references, value) {
      const instance = state.instances.size;
      state.instances.set(instance, schema);
      yield `kind('${schema[Types.Kind]}', ${instance}, ${value})`;
    }
    function* Visit(schema, references, value, useHoisting = true) {
      const references_ = (0, guard_1.IsString)(schema.$id) ? [...references, schema] : references;
      const schema_ = schema;
      if (useHoisting && (0, guard_1.IsString)(schema.$id)) {
        const functionName = CreateFunctionName(schema.$id);
        if (state.functions.has(functionName)) {
          return yield `${functionName}(${value})`;
        } else {
          const functionCode = CreateFunction(functionName, schema, references, "value", false);
          state.functions.set(functionName, functionCode);
          return yield `${functionName}(${value})`;
        }
      }
      switch (schema_[Types.Kind]) {
        case "Any":
          return yield* TAny(schema_, references_, value);
        case "Array":
          return yield* TArray(schema_, references_, value);
        case "AsyncIterator":
          return yield* TAsyncIterator(schema_, references_, value);
        case "BigInt":
          return yield* TBigInt(schema_, references_, value);
        case "Boolean":
          return yield* TBoolean(schema_, references_, value);
        case "Constructor":
          return yield* TConstructor(schema_, references_, value);
        case "Date":
          return yield* TDate(schema_, references_, value);
        case "Function":
          return yield* TFunction(schema_, references_, value);
        case "Integer":
          return yield* TInteger(schema_, references_, value);
        case "Intersect":
          return yield* TIntersect(schema_, references_, value);
        case "Iterator":
          return yield* TIterator(schema_, references_, value);
        case "Literal":
          return yield* TLiteral(schema_, references_, value);
        case "Never":
          return yield* TNever(schema_, references_, value);
        case "Not":
          return yield* TNot(schema_, references_, value);
        case "Null":
          return yield* TNull(schema_, references_, value);
        case "Number":
          return yield* TNumber(schema_, references_, value);
        case "Object":
          return yield* TObject(schema_, references_, value);
        case "Promise":
          return yield* TPromise(schema_, references_, value);
        case "Record":
          return yield* TRecord(schema_, references_, value);
        case "Ref":
          return yield* TRef(schema_, references_, value);
        case "String":
          return yield* TString(schema_, references_, value);
        case "Symbol":
          return yield* TSymbol(schema_, references_, value);
        case "TemplateLiteral":
          return yield* TTemplateLiteral(schema_, references_, value);
        case "This":
          return yield* TThis(schema_, references_, value);
        case "Tuple":
          return yield* TTuple(schema_, references_, value);
        case "Undefined":
          return yield* TUndefined(schema_, references_, value);
        case "Union":
          return yield* TUnion(schema_, references_, value);
        case "Uint8Array":
          return yield* TUint8Array(schema_, references_, value);
        case "Unknown":
          return yield* TUnknown(schema_, references_, value);
        case "Void":
          return yield* TVoid(schema_, references_, value);
        default:
          if (!Types.TypeRegistry.Has(schema_[Types.Kind]))
            throw new TypeCompilerUnknownTypeError(schema);
          return yield* TKind(schema_, references_, value);
      }
    }
    const state = {
      language: "javascript",
      functions: new Map,
      variables: new Map,
      instances: new Map
    };
    function CreateExpression(schema, references, value, useHoisting = true) {
      return `(${[...Visit(schema, references, value, useHoisting)].join(" && ")})`;
    }
    function CreateFunctionName($id) {
      return `check_${Identifier.Encode($id)}`;
    }
    function CreateVariable(expression) {
      const variableName = `local_${state.variables.size}`;
      state.variables.set(variableName, `const ${variableName} = ${expression}`);
      return variableName;
    }
    function CreateFunction(name, schema, references, value, useHoisting = true) {
      const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
      const parameter = CreateParameter("value", "any");
      const returns = CreateReturns("boolean");
      const expression = [...Visit(schema, references, value, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
      return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\n}`;
    }
    function CreateParameter(name, type) {
      const annotation = state.language === "typescript" ? `: ${type}` : "";
      return `${name}${annotation}`;
    }
    function CreateReturns(type) {
      return state.language === "typescript" ? `: ${type}` : "";
    }
    function Build(schema, references, options) {
      const functionCode = CreateFunction("check", schema, references, "value");
      const parameter = CreateParameter("value", "any");
      const returns = CreateReturns("boolean");
      const functions = [...state.functions.values()];
      const variables = [...state.variables.values()];
      const checkFunction = (0, guard_1.IsString)(schema.$id) ? `return function check(${parameter})${returns} {\n  return ${CreateFunctionName(schema.$id)}(value)\n}` : `return ${functionCode}`;
      return [...variables, ...functions, checkFunction].join("\n");
    }
    function Code(...args2) {
      const defaults = { language: "javascript" };
      const [schema, references, options] = args2.length === 2 && (0, guard_1.IsArray)(args2[1]) ? [args2[0], args2[1], defaults] : args2.length === 2 && !(0, guard_1.IsArray)(args2[1]) ? [args2[0], [], args2[1]] : args2.length === 3 ? [args2[0], args2[1], args2[2]] : args2.length === 1 ? [args2[0], [], defaults] : [null, [], defaults];
      state.language = options.language;
      state.variables.clear();
      state.functions.clear();
      state.instances.clear();
      if (!Types.TypeGuard.TSchema(schema))
        throw new TypeCompilerTypeGuardError(schema);
      for (const schema2 of references)
        if (!Types.TypeGuard.TSchema(schema2))
          throw new TypeCompilerTypeGuardError(schema2);
      return Build(schema, references, options);
    }
    TypeCompiler2.Code = Code;
    function Compile(schema, references = []) {
      const generatedCode = Code(schema, references, { language: "javascript" });
      const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
      const instances = new Map(state.instances);
      function typeRegistryFunction(kind, instance, value) {
        if (!Types.TypeRegistry.Has(kind) || !instances.has(instance))
          return false;
        const checkFunc = Types.TypeRegistry.Get(kind);
        const schema2 = instances.get(instance);
        return checkFunc(schema2, value);
      }
      function formatRegistryFunction(format2, value) {
        if (!Types.FormatRegistry.Has(format2))
          return false;
        const checkFunc = Types.FormatRegistry.Get(format2);
        return checkFunc(value);
      }
      function hashFunction(value) {
        return (0, hash_1.Hash)(value);
      }
      const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
      return new TypeCheck(schema, references, checkFunction, generatedCode);
    }
    TypeCompiler2.Compile = Compile;
  })(TypeCompiler || (exports.TypeCompiler = TypeCompiler = {}));
});

// node_modules/@libsql/hrana-client/lib-esm/encodi
var require_compiler2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueErrorIterator = exports.ValueErrorType = undefined;
  var index_1 = require_errors2();
  Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
    return index_1.ValueErrorType;
  } });
  Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
    return index_1.ValueErrorIterator;
  } });
  __exportStar(require_compiler(), exports);
});

// node_modules/@libsql/hrana-client/lib-es
var require_dist = __commonJS((exports) => {
  var currentTarget = function() {
    let os2 = null;
    switch (process.platform) {
      case "android":
        switch (process.arch) {
          case "arm":
            return "android-arm-eabi";
          case "arm64":
            return "android-arm64";
        }
        os2 = "Android";
        break;
      case "win32":
        switch (process.arch) {
          case "x64":
            return "win32-x64-msvc";
          case "arm64":
            return "win32-arm64-msvc";
          case "ia32":
            return "win32-ia32-msvc";
        }
        os2 = "Windows";
        break;
      case "darwin":
        switch (process.arch) {
          case "x64":
            return "darwin-x64";
          case "arm64":
            return "darwin-arm64";
        }
        os2 = "macOS";
        break;
      case "linux":
        switch (process.arch) {
          case "x64":
          case "arm64":
            return isGlibc() ? `linux-${process.arch}-gnu` : `linux-${process.arch}-musl`;
          case "arm":
            return "linux-arm-gnueabihf";
        }
        os2 = "Linux";
        break;
      case "freebsd":
        if (process.arch === "x64") {
          return "freebsd-x64";
        }
        os2 = "FreeBSD";
        break;
    }
    if (os2) {
      throw new Error(`Neon: unsupported ${os2} architecture: ${process.arch}`);
    }
    throw new Error(`Neon: unsupported system: ${process.platform}`);
  };
  var isGlibc = function() {
    const report = process.report?.getReport();
    if (typeof report !== "object" || !report || !("header" in report)) {
      return false;
    }
    const header = report.header;
    return typeof header === "object" && !!header && ("glibcVersionRuntime" in header);
  };
  var load = function(dirname) {
    const m = path.join(dirname, "index.node");
    return fs.existsSync(m) ? import.meta.require(m) : null;
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.load = exports.currentTarget = undefined;
  var path = __importStar(import.meta.require("path"));
  var fs = __importStar(import.meta.require("fs"));
  exports.currentTarget = currentTarget;
  exports.load = load;
});

// node_modules/@libsql/hrana-client/l
var require_sqlite_error = __commonJS((exports, module) => {
  var SqliteError = function(message, code, rawCode) {
    if (new.target !== SqliteError) {
      return new SqliteError(message, code);
    }
    if (typeof code !== "string") {
      throw new TypeError("Expected second argument to be a string");
    }
    Error.call(this, message);
    descriptor.value = "" + message;
    Object.defineProperty(this, "message", descriptor);
    Error.captureStackTrace(this, SqliteError);
    this.code = code;
    this.rawCode = rawCode;
  };
  var descriptor = { value: "SqliteError", writable: true, enumerable: false, configurable: true };
  Object.setPrototypeOf(SqliteError, Error);
  Object.setPrototypeOf(SqliteError.prototype, Error.prototype);
  Object.defineProperty(SqliteError.prototype, "name", descriptor);
  module.exports = SqliteError;
});

// node_modules/@libsql/hrana-c
var require_libsql = __commonJS((exports, module) => {
  var __dirname = "/workspaces/hermes/node_modules/libsql";
  var { load, currentTarget } = require_dist();
  var { familySync, GLIBC } = import.meta.require("detect-libc");
  if (0) {
  }
  var target = currentTarget();
  if (familySync() == GLIBC) {
    switch (target) {
      case "linux-x64-musl":
        target = "linux-x64-gnu";
        break;
      case "linux-arm64-musl":
        target = "linux-arm64-gnu";
        break;
    }
  }
  var {
    databaseOpen,
    databaseOpenWithRpcSync,
    databaseInTransaction,
    databaseClose,
    databaseSyncSync,
    databaseExecSync,
    databasePrepareSync,
    databaseDefaultSafeIntegers,
    statementRaw,
    statementGet,
    statementRun,
    statementRowsSync,
    statementColumns,
    statementSafeIntegers,
    rowsNext
  } = load(__dirname) || import.meta.require(`@libsql/${target}`);
  var SqliteError = require_sqlite_error();

  class Database2 {
    constructor(path, opts) {
      if (opts && opts.syncUrl) {
        var authToken = "";
        if (opts.syncAuth) {
          console.warn("Warning: The `syncAuth` option is deprecated, please use `authToken` option instead.");
          authToken = opts.syncAuth;
        } else if (opts.authToken) {
          authToken = opts.authToken;
        }
        this.db = databaseOpenWithRpcSync(path, opts.syncUrl, authToken);
      } else {
        const authToken2 = opts?.authToken ?? "";
        this.db = databaseOpen(path, authToken2);
      }
      this.memory = path === ":memory:";
      this.readonly = false;
      this.name = "";
      this.open = true;
      const db = this.db;
      Object.defineProperties(this, {
        inTransaction: {
          get() {
            return databaseInTransaction(db);
          }
        }
      });
    }
    sync() {
      databaseSyncSync.call(this.db);
    }
    prepare(sql) {
      try {
        const stmt = databasePrepareSync.call(this.db, sql);
        return new Statement(stmt);
      } catch (err) {
        throw new SqliteError(err.message, err.code, err.rawCode);
      }
    }
    transaction(fn) {
      if (typeof fn !== "function")
        throw new TypeError("Expected first argument to be a function");
      return (...bindParameters) => {
        this.exec("BEGIN");
        try {
          const result = fn(...bindParameters);
          this.exec("COMMIT");
          return result;
        } catch (err) {
          this.exec("ROLLBACK");
          throw err;
        }
      };
    }
    pragma(source, options) {
      throw new Error("not implemented");
    }
    backup(filename, options) {
      throw new Error("not implemented");
    }
    serialize(options) {
      throw new Error("not implemented");
    }
    function(name, options, fn) {
      if (options == null)
        options = {};
      if (typeof options === "function") {
        fn = options;
        options = {};
      }
      if (typeof name !== "string")
        throw new TypeError("Expected first argument to be a string");
      if (typeof fn !== "function")
        throw new TypeError("Expected last argument to be a function");
      if (typeof options !== "object")
        throw new TypeError("Expected second argument to be an options object");
      if (!name)
        throw new TypeError("User-defined function name cannot be an empty string");
      throw new Error("not implemented");
    }
    aggregate(name, options) {
      if (typeof name !== "string")
        throw new TypeError("Expected first argument to be a string");
      if (typeof options !== "object" || options === null)
        throw new TypeError("Expected second argument to be an options object");
      if (!name)
        throw new TypeError("User-defined function name cannot be an empty string");
      throw new Error("not implemented");
    }
    table(name, factory) {
      if (typeof name !== "string")
        throw new TypeError("Expected first argument to be a string");
      if (!name)
        throw new TypeError("Virtual table module name cannot be an empty string");
      throw new Error("not implemented");
    }
    loadExtension(...args2) {
      throw new Error("not implemented");
    }
    exec(sql) {
      try {
        databaseExecSync.call(this.db, sql);
      } catch (err) {
        throw new SqliteError(err.message, err.code, err.rawCode);
      }
    }
    close() {
      databaseClose.call(this.db);
      this.open = false;
    }
    defaultSafeIntegers(toggle) {
      databaseDefaultSafeIntegers.call(this.db, toggle || true);
      return this;
    }
    unsafeMode(...args2) {
      throw new Error("not implemented");
    }
  }

  class Statement {
    constructor(stmt) {
      this.stmt = stmt;
    }
    raw(raw) {
      statementRaw.call(this.stmt, raw || true);
      return this;
    }
    run(...bindParameters) {
      try {
        if (bindParameters.length == 1 && typeof bindParameters[0] === "object") {
          return statementRun.call(this.stmt, bindParameters[0]);
        } else {
          return statementRun.call(this.stmt, bindParameters.flat());
        }
      } catch (err) {
        throw new SqliteError(err.message, err.code, err.rawCode);
      }
    }
    get(...bindParameters) {
      if (bindParameters.length == 1 && typeof bindParameters[0] === "object") {
        return statementGet.call(this.stmt, bindParameters[0]);
      } else {
        return statementGet.call(this.stmt, bindParameters.flat());
      }
    }
    iterate(...bindParameters) {
      var rows = undefined;
      if (bindParameters.length == 1 && typeof bindParameters[0] === "object") {
        rows = statementRowsSync.call(this.stmt, bindParameters[0]);
      } else {
        rows = statementRowsSync.call(this.stmt, bindParameters.flat());
      }
      const iter = {
        next() {
          const row = rowsNext.call(rows);
          if (!row) {
            return { done: true };
          }
          return { value: row, done: false };
        },
        [Symbol.iterator]() {
          return this;
        }
      };
      return iter;
    }
    all(...bindParameters) {
      const result = [];
      for (const row of this.iterate(...bindParameters)) {
        result.push(row);
      }
      return result;
    }
    columns() {
      return statementColumns.call(this.stmt);
    }
    safeIntegers(toggle) {
      statementSafeIntegers.call(this.stmt, toggle || true);
      return this;
    }
  }
  module.exports = Database2;
  module.exports.SqliteError = SqliteError;
});

// node_modules/@libsql/hrana-client/lib-esm/e
import {readdir, stat} from "fs/promises";
import {resolve, resolve as resolveFn, join} from "path";
var getFiles = async (dir) => {
  const files = await readdir(dir);
  const all = await Promise.all(files.map(async (name) => {
    const file = dir + "/" + name;
    const stats = await stat(file);
    return stats && stats.isDirectory() ? await getFiles(file) : [resolve(dir, file)];
  }));
  return all.flat();
};
var staticPlugin = async ({ assets = "public", prefix = "/public", staticLimit = 1024, alwaysStatic = false, ignorePatterns = [".DS_Store", ".git", ".env"], noExtension = false, resolve: resolve2 = resolveFn } = {
  assets: "public",
  prefix: "/public",
  staticLimit: 1024,
  alwaysStatic: false,
  ignorePatterns: [],
  noExtension: false,
  resolve: resolveFn
}) => {
  const files = await getFiles(resolveFn(assets));
  if (prefix === "/")
    prefix = "";
  const shouldIgnore = (file) => {
    if (!ignorePatterns.length)
      return false;
    return ignorePatterns.find((pattern) => {
      if (typeof pattern === "string")
        return pattern.includes(file);
      else
        return pattern.test(file);
    });
  };
  return (app) => {
    if (alwaysStatic || process.env.ENV === "production" && files.length <= staticLimit)
      for (let i = 0;i < files.length; i++) {
        const file = files[i];
        if (shouldIgnore(file))
          continue;
        const response = () => new Response(Bun.file(file));
        let fileName = file.replace(resolve2(), "").replace(`${assets}/`, "");
        if (noExtension) {
          const temp = fileName.split(".");
          temp.splice(-1);
          fileName = temp.join(".");
        }
        app.get(join(prefix, fileName), response);
      }
    else {
      if (!app.routes.find(({ method, path }) => path === `${prefix}/*` && method === "GET"))
        app.get(`${prefix}/*`, (c) => {
          const file = `${assets}/${c.params["*"]}`;
          if (shouldIgnore(file))
            return new Response("NOT_FOUND", {
              status: 404
            });
          return stat(file).then((status) => new Response(Bun.file(file))).catch((error) => new Response("NOT_FOUND", {
            status: 404
          }));
        });
    }
    return app;
  };
};

// node_modules/@libsql/hrana-client/lib
var eW = Object.create;
var { defineProperty: S6, getPrototypeOf: $X, getOwnPropertyNames: YX } = Object;
var WX = Object.prototype.hasOwnProperty;
var X1 = ($, Y, W) => {
  W = $ != null ? eW($X($)) : {};
  const X = Y || !$ || !$.__esModule ? S6(W, "default", { value: $, enumerable: true }) : W;
  for (let Z of YX($))
    if (!WX.call(X, Z))
      S6(X, Z, { get: () => $[Z], enumerable: true });
  return X;
};
var J0 = ($, Y) => () => (Y || $((Y = { exports: {} }).exports, Y), Y.exports);
var b6 = J0((O7, a$) => {
  var r1 = function() {
  }, QX = function($, Y, W) {
    this.fn = $, this.context = Y, this.once = W || false;
  }, I6 = function($, Y, W, X, Z) {
    if (typeof W !== "function")
      throw new TypeError("The listener must be a function");
    var Q = new QX(W, X || $, Z), J = _0 ? _0 + Y : Y;
    if (!$._events[J])
      $._events[J] = Q, $._eventsCount++;
    else if (!$._events[J].fn)
      $._events[J].push(Q);
    else
      $._events[J] = [$._events[J], Q];
    return $;
  }, K$ = function($, Y) {
    if (--$._eventsCount === 0)
      $._events = new r1;
    else
      delete $._events[Y];
  }, b0 = function() {
    this._events = new r1, this._eventsCount = 0;
  }, ZX = Object.prototype.hasOwnProperty, _0 = "~";
  if (Object.create) {
    if (r1.prototype = Object.create(null), !new r1().__proto__)
      _0 = false;
  }
  b0.prototype.eventNames = function $() {
    var Y = [], W, X;
    if (this._eventsCount === 0)
      return Y;
    for (X in W = this._events)
      if (ZX.call(W, X))
        Y.push(_0 ? X.slice(1) : X);
    if (Object.getOwnPropertySymbols)
      return Y.concat(Object.getOwnPropertySymbols(W));
    return Y;
  };
  b0.prototype.listeners = function $(Y) {
    var W = _0 ? _0 + Y : Y, X = this._events[W];
    if (!X)
      return [];
    if (X.fn)
      return [X.fn];
    for (var Z = 0, Q = X.length, J = new Array(Q);Z < Q; Z++)
      J[Z] = X[Z].fn;
    return J;
  };
  b0.prototype.listenerCount = function $(Y) {
    var W = _0 ? _0 + Y : Y, X = this._events[W];
    if (!X)
      return 0;
    if (X.fn)
      return 1;
    return X.length;
  };
  b0.prototype.emit = function $(Y, W, X, Z, Q, J) {
    var q = _0 ? _0 + Y : Y;
    if (!this._events[q])
      return false;
    var F = this._events[q], D = arguments.length, K, A;
    if (F.fn) {
      if (F.once)
        this.removeListener(Y, F.fn, undefined, true);
      switch (D) {
        case 1:
          return F.fn.call(F.context), true;
        case 2:
          return F.fn.call(F.context, W), true;
        case 3:
          return F.fn.call(F.context, W, X), true;
        case 4:
          return F.fn.call(F.context, W, X, Z), true;
        case 5:
          return F.fn.call(F.context, W, X, Z, Q), true;
        case 6:
          return F.fn.call(F.context, W, X, Z, Q, J), true;
      }
      for (A = 1, K = new Array(D - 1);A < D; A++)
        K[A - 1] = arguments[A];
      F.fn.apply(F.context, K);
    } else {
      var I = F.length, j;
      for (A = 0;A < I; A++) {
        if (F[A].once)
          this.removeListener(Y, F[A].fn, undefined, true);
        switch (D) {
          case 1:
            F[A].fn.call(F[A].context);
            break;
          case 2:
            F[A].fn.call(F[A].context, W);
            break;
          case 3:
            F[A].fn.call(F[A].context, W, X);
            break;
          case 4:
            F[A].fn.call(F[A].context, W, X, Z);
            break;
          default:
            if (!K)
              for (j = 1, K = new Array(D - 1);j < D; j++)
                K[j - 1] = arguments[j];
            F[A].fn.apply(F[A].context, K);
        }
      }
    }
    return true;
  };
  b0.prototype.on = function $(Y, W, X) {
    return I6(this, Y, W, X, false);
  };
  b0.prototype.once = function $(Y, W, X) {
    return I6(this, Y, W, X, true);
  };
  b0.prototype.removeListener = function $(Y, W, X, Z) {
    var Q = _0 ? _0 + Y : Y;
    if (!this._events[Q])
      return this;
    if (!W)
      return K$(this, Q), this;
    var J = this._events[Q];
    if (J.fn) {
      if (J.fn === W && (!Z || J.once) && (!X || J.context === X))
        K$(this, Q);
    } else {
      for (var q = 0, F = [], D = J.length;q < D; q++)
        if (J[q].fn !== W || Z && !J[q].once || X && J[q].context !== X)
          F.push(J[q]);
      if (F.length)
        this._events[Q] = F.length === 1 ? F[0] : F;
      else
        K$(this, Q);
    }
    return this;
  };
  b0.prototype.removeAllListeners = function $(Y) {
    var W;
    if (Y) {
      if (W = _0 ? _0 + Y : Y, this._events[W])
        K$(this, W);
    } else
      this._events = new r1, this._eventsCount = 0;
    return this;
  };
  b0.prototype.off = b0.prototype.removeListener;
  b0.prototype.addListener = b0.prototype.on;
  b0.prefixed = _0;
  b0.EventEmitter = b0;
  if (typeof a$ !== "undefined")
    a$.exports = b0;
});
var V0 = J0((d6) => {
  var JX = function($) {
    return j$($) && (Symbol.asyncIterator in $);
  }, zX = function($) {
    return j$($) && (Symbol.iterator in $);
  }, HX = function($) {
    return ArrayBuffer.isView($);
  }, qX = function($) {
    return $ instanceof Promise;
  }, NX = function($) {
    return $ instanceof Uint8Array;
  }, MX = function($) {
    return $ instanceof Date && Number.isFinite($.getTime());
  }, UX = function($, Y) {
    return Y in $;
  }, FX = function($) {
    return j$($) && f6($.constructor) && $.constructor.name === "Object";
  }, j$ = function($) {
    return $ !== null && typeof $ === "object";
  }, BX = function($) {
    return Array.isArray($) && !ArrayBuffer.isView($);
  }, E6 = function($) {
    return $ === undefined;
  }, V6 = function($) {
    return $ === null;
  }, x6 = function($) {
    return typeof $ === "boolean";
  }, e$ = function($) {
    return typeof $ === "number";
  }, AX = function($) {
    return e$($) && Number.isInteger($);
  }, k6 = function($) {
    return typeof $ === "bigint";
  }, g6 = function($) {
    return typeof $ === "string";
  }, f6 = function($) {
    return typeof $ === "function";
  }, T6 = function($) {
    return typeof $ === "symbol";
  }, DX = function($) {
    return k6($) || x6($) || V6($) || e$($) || g6($) || T6($) || E6($);
  };
  Object.defineProperty(d6, "__esModule", { value: true });
  d6.IsValueType = d6.IsSymbol = d6.IsFunction = d6.IsString = d6.IsBigInt = d6.IsInteger = d6.IsNumber = d6.IsBoolean = d6.IsNull = d6.IsUndefined = d6.IsArray = d6.IsObject = d6.IsPlainObject = d6.HasPropertyKey = d6.IsDate = d6.IsUint8Array = d6.IsPromise = d6.IsTypedArray = d6.IsIterator = d6.IsAsyncIterator = undefined;
  d6.IsAsyncIterator = JX;
  d6.IsIterator = zX;
  d6.IsTypedArray = HX;
  d6.IsPromise = qX;
  d6.IsUint8Array = NX;
  d6.IsDate = MX;
  d6.HasPropertyKey = UX;
  d6.IsPlainObject = FX;
  d6.IsObject = j$;
  d6.IsArray = BX;
  d6.IsUndefined = E6;
  d6.IsNull = V6;
  d6.IsBoolean = x6;
  d6.IsNumber = e$;
  d6.IsInteger = AX;
  d6.IsBigInt = k6;
  d6.IsString = g6;
  d6.IsFunction = f6;
  d6.IsSymbol = T6;
  d6.IsValueType = DX;
});
var f0 = J0((m6) => {
  Object.defineProperty(m6, "__esModule", { value: true });
  m6.Type = m6.JsonType = m6.JavaScriptTypeBuilder = m6.JsonTypeBuilder = m6.TypeBuilder = m6.TypeBuilderError = m6.TransformEncodeBuilder = m6.TransformDecodeBuilder = m6.TemplateLiteralDslParser = m6.TemplateLiteralGenerator = m6.TemplateLiteralGeneratorError = m6.TemplateLiteralFinite = m6.TemplateLiteralFiniteError = m6.TemplateLiteralParser = m6.TemplateLiteralParserError = m6.TemplateLiteralResolver = m6.TemplateLiteralPattern = m6.TemplateLiteralPatternError = m6.UnionResolver = m6.KeyArrayResolver = m6.KeyArrayResolverError = m6.KeyResolver = m6.ObjectMap = m6.Intrinsic = m6.IndexedAccessor = m6.TypeClone = m6.TypeExtends = m6.TypeExtendsResult = m6.TypeExtendsError = m6.ExtendsUndefined = m6.TypeGuard = m6.TypeGuardUnknownTypeError = m6.ValueGuard = m6.FormatRegistry = m6.TypeBoxError = m6.TypeRegistry = m6.PatternStringExact = m6.PatternNumberExact = m6.PatternBooleanExact = m6.PatternString = m6.PatternNumber = m6.PatternBoolean = m6.Kind = m6.Hint = m6.Optional = m6.Readonly = m6.Transform = undefined;
  m6.Transform = Symbol.for("TypeBox.Transform");
  m6.Readonly = Symbol.for("TypeBox.Readonly");
  m6.Optional = Symbol.for("TypeBox.Optional");
  m6.Hint = Symbol.for("TypeBox.Hint");
  m6.Kind = Symbol.for("TypeBox.Kind");
  m6.PatternBoolean = "(true|false)";
  m6.PatternNumber = "(0|[1-9][0-9]*)";
  m6.PatternString = "(.*)";
  m6.PatternBooleanExact = `^${m6.PatternBoolean}$`;
  m6.PatternNumberExact = `^${m6.PatternNumber}$`;
  m6.PatternStringExact = `^${m6.PatternString}$`;
  var $8;
  (function($) {
    const Y = new Map;
    function W() {
      return new Map(Y);
    }
    $.Entries = W;
    function X() {
      return Y.clear();
    }
    $.Clear = X;
    function Z(F) {
      return Y.delete(F);
    }
    $.Delete = Z;
    function Q(F) {
      return Y.has(F);
    }
    $.Has = Q;
    function J(F, D) {
      Y.set(F, D);
    }
    $.Set = J;
    function q(F) {
      return Y.get(F);
    }
    $.Get = q;
  })($8 || (m6.TypeRegistry = $8 = {}));

  class e0 extends Error {
    constructor($) {
      super($);
    }
  }
  m6.TypeBoxError = e0;
  var v6;
  (function($) {
    const Y = new Map;
    function W() {
      return new Map(Y);
    }
    $.Entries = W;
    function X() {
      return Y.clear();
    }
    $.Clear = X;
    function Z(F) {
      return Y.delete(F);
    }
    $.Delete = Z;
    function Q(F) {
      return Y.has(F);
    }
    $.Has = Q;
    function J(F, D) {
      Y.set(F, D);
    }
    $.Set = J;
    function q(F) {
      return Y.get(F);
    }
    $.Get = q;
  })(v6 || (m6.FormatRegistry = v6 = {}));
  var x;
  (function($) {
    function Y(D) {
      return Array.isArray(D);
    }
    $.IsArray = Y;
    function W(D) {
      return typeof D === "bigint";
    }
    $.IsBigInt = W;
    function X(D) {
      return typeof D === "boolean";
    }
    $.IsBoolean = X;
    function Z(D) {
      return D === null;
    }
    $.IsNull = Z;
    function Q(D) {
      return typeof D === "number";
    }
    $.IsNumber = Q;
    function J(D) {
      return typeof D === "object" && D !== null;
    }
    $.IsObject = J;
    function q(D) {
      return typeof D === "string";
    }
    $.IsString = q;
    function F(D) {
      return D === undefined;
    }
    $.IsUndefined = F;
  })(x || (m6.ValueGuard = x = {}));

  class i6 extends e0 {
  }
  m6.TypeGuardUnknownTypeError = i6;
  var B;
  (function($) {
    function Y(N) {
      try {
        return new RegExp(N), true;
      } catch {
        return false;
      }
    }
    function W(N) {
      if (!x.IsString(N))
        return false;
      for (let l = 0;l < N.length; l++) {
        const S0 = N.charCodeAt(l);
        if (S0 >= 7 && S0 <= 13 || S0 === 27 || S0 === 127)
          return false;
      }
      return true;
    }
    function X(N) {
      return J(N) || X0(N);
    }
    function Z(N) {
      return x.IsUndefined(N) || x.IsBigInt(N);
    }
    function Q(N) {
      return x.IsUndefined(N) || x.IsNumber(N);
    }
    function J(N) {
      return x.IsUndefined(N) || x.IsBoolean(N);
    }
    function q(N) {
      return x.IsUndefined(N) || x.IsString(N);
    }
    function F(N) {
      return x.IsUndefined(N) || x.IsString(N) && W(N) && Y(N);
    }
    function D(N) {
      return x.IsUndefined(N) || x.IsString(N) && W(N);
    }
    function K(N) {
      return x.IsUndefined(N) || X0(N);
    }
    function A(N) {
      return G(N, "Any") && q(N.$id);
    }
    $.TAny = A;
    function I(N) {
      return G(N, "Array") && N.type === "array" && q(N.$id) && X0(N.items) && Q(N.minItems) && Q(N.maxItems) && J(N.uniqueItems) && K(N.contains) && Q(N.minContains) && Q(N.maxContains);
    }
    $.TArray = I;
    function j(N) {
      return G(N, "AsyncIterator") && N.type === "AsyncIterator" && q(N.$id) && X0(N.items);
    }
    $.TAsyncIterator = j;
    function M(N) {
      return G(N, "BigInt") && N.type === "bigint" && q(N.$id) && Z(N.exclusiveMaximum) && Z(N.exclusiveMinimum) && Z(N.maximum) && Z(N.minimum) && Z(N.multipleOf);
    }
    $.TBigInt = M;
    function L(N) {
      return G(N, "Boolean") && N.type === "boolean" && q(N.$id);
    }
    $.TBoolean = L;
    function O(N) {
      return G(N, "Constructor") && N.type === "Constructor" && q(N.$id) && x.IsArray(N.parameters) && N.parameters.every((l) => X0(l)) && X0(N.returns);
    }
    $.TConstructor = O;
    function U(N) {
      return G(N, "Date") && N.type === "Date" && q(N.$id) && Q(N.exclusiveMaximumTimestamp) && Q(N.exclusiveMinimumTimestamp) && Q(N.maximumTimestamp) && Q(N.minimumTimestamp) && Q(N.multipleOfTimestamp);
    }
    $.TDate = U;
    function w(N) {
      return G(N, "Function") && N.type === "Function" && q(N.$id) && x.IsArray(N.parameters) && N.parameters.every((l) => X0(l)) && X0(N.returns);
    }
    $.TFunction = w;
    function b(N) {
      return G(N, "Integer") && N.type === "integer" && q(N.$id) && Q(N.exclusiveMaximum) && Q(N.exclusiveMinimum) && Q(N.maximum) && Q(N.minimum) && Q(N.multipleOf);
    }
    $.TInteger = b;
    function R(N) {
      return G(N, "Intersect") && (x.IsString(N.type) && N.type !== "object" ? false : true) && x.IsArray(N.allOf) && N.allOf.every((l) => X0(l) && !D0(l)) && q(N.type) && (J(N.unevaluatedProperties) || K(N.unevaluatedProperties)) && q(N.$id);
    }
    $.TIntersect = R;
    function V(N) {
      return G(N, "Iterator") && N.type === "Iterator" && q(N.$id) && X0(N.items);
    }
    $.TIterator = V;
    function G(N, l) {
      return h(N) && N[m6.Kind] === l;
    }
    $.TKindOf = G;
    function h(N) {
      return x.IsObject(N) && (m6.Kind in N) && x.IsString(N[m6.Kind]);
    }
    $.TKind = h;
    function o(N) {
      return w0(N) && x.IsString(N.const);
    }
    $.TLiteralString = o;
    function $0(N) {
      return w0(N) && x.IsNumber(N.const);
    }
    $.TLiteralNumber = $0;
    function n0(N) {
      return w0(N) && x.IsBoolean(N.const);
    }
    $.TLiteralBoolean = n0;
    function w0(N) {
      return G(N, "Literal") && q(N.$id) && (x.IsBoolean(N.const) || x.IsNumber(N.const) || x.IsString(N.const));
    }
    $.TLiteral = w0;
    function k0(N) {
      return G(N, "Never") && x.IsObject(N.not) && Object.getOwnPropertyNames(N.not).length === 0;
    }
    $.TNever = k0;
    function F0(N) {
      return G(N, "Not") && X0(N.not);
    }
    $.TNot = F0;
    function v0(N) {
      return G(N, "Null") && N.type === "null" && q(N.$id);
    }
    $.TNull = v0;
    function z0(N) {
      return G(N, "Number") && N.type === "number" && q(N.$id) && Q(N.exclusiveMaximum) && Q(N.exclusiveMinimum) && Q(N.maximum) && Q(N.minimum) && Q(N.multipleOf);
    }
    $.TNumber = z0;
    function p0(N) {
      return G(N, "Object") && N.type === "object" && q(N.$id) && x.IsObject(N.properties) && X(N.additionalProperties) && Q(N.minProperties) && Q(N.maxProperties) && Object.entries(N.properties).every(([l, S0]) => W(l) && X0(S0));
    }
    $.TObject = p0;
    function g0(N) {
      return G(N, "Promise") && N.type === "Promise" && q(N.$id) && X0(N.item);
    }
    $.TPromise = g0;
    function N0(N) {
      return G(N, "Record") && N.type === "object" && q(N.$id) && X(N.additionalProperties) && x.IsObject(N.patternProperties) && ((l) => {
        const S0 = Object.getOwnPropertyNames(l.patternProperties);
        return S0.length === 1 && Y(S0[0]) && x.IsObject(l.patternProperties) && X0(l.patternProperties[S0[0]]);
      })(N);
    }
    $.TRecord = N0;
    function E(N) {
      return x.IsObject(N) && (m6.Hint in N) && N[m6.Hint] === "Recursive";
    }
    $.TRecursive = E;
    function d(N) {
      return G(N, "Ref") && q(N.$id) && x.IsString(N.$ref);
    }
    $.TRef = d;
    function u(N) {
      return G(N, "String") && N.type === "string" && q(N.$id) && Q(N.minLength) && Q(N.maxLength) && F(N.pattern) && D(N.format);
    }
    $.TString = u;
    function t(N) {
      return G(N, "Symbol") && N.type === "symbol" && q(N.$id);
    }
    $.TSymbol = t;
    function H0(N) {
      return G(N, "TemplateLiteral") && N.type === "string" && x.IsString(N.pattern) && N.pattern[0] === "^" && N.pattern[N.pattern.length - 1] === "$";
    }
    $.TTemplateLiteral = H0;
    function E0(N) {
      return G(N, "This") && q(N.$id) && x.IsString(N.$ref);
    }
    $.TThis = E0;
    function D0(N) {
      return x.IsObject(N) && (m6.Transform in N);
    }
    $.TTransform = D0;
    function a(N) {
      return G(N, "Tuple") && N.type === "array" && q(N.$id) && x.IsNumber(N.minItems) && x.IsNumber(N.maxItems) && N.minItems === N.maxItems && (x.IsUndefined(N.items) && x.IsUndefined(N.additionalItems) && N.minItems === 0 || x.IsArray(N.items) && N.items.every((l) => X0(l)));
    }
    $.TTuple = a;
    function A1(N) {
      return G(N, "Undefined") && N.type === "undefined" && q(N.$id);
    }
    $.TUndefined = A1;
    function P(N) {
      return _(N) && N.anyOf.every((l) => o(l) || $0(l));
    }
    $.TUnionLiteral = P;
    function _(N) {
      return G(N, "Union") && q(N.$id) && x.IsObject(N) && x.IsArray(N.anyOf) && N.anyOf.every((l) => X0(l));
    }
    $.TUnion = _;
    function S(N) {
      return G(N, "Uint8Array") && N.type === "Uint8Array" && q(N.$id) && Q(N.minByteLength) && Q(N.maxByteLength);
    }
    $.TUint8Array = S;
    function p(N) {
      return G(N, "Unknown") && q(N.$id);
    }
    $.TUnknown = p;
    function f(N) {
      return G(N, "Unsafe");
    }
    $.TUnsafe = f;
    function T(N) {
      return G(N, "Void") && N.type === "void" && q(N.$id);
    }
    $.TVoid = T;
    function W0(N) {
      return x.IsObject(N) && N[m6.Readonly] === "Readonly";
    }
    $.TReadonly = W0;
    function K0(N) {
      return x.IsObject(N) && N[m6.Optional] === "Optional";
    }
    $.TOptional = K0;
    function X0(N) {
      return x.IsObject(N) && (A(N) || I(N) || L(N) || M(N) || j(N) || O(N) || U(N) || w(N) || b(N) || R(N) || V(N) || w0(N) || k0(N) || F0(N) || v0(N) || z0(N) || p0(N) || g0(N) || N0(N) || d(N) || u(N) || t(N) || H0(N) || E0(N) || a(N) || A1(N) || _(N) || S(N) || p(N) || f(N) || T(N) || h(N) && $8.Has(N[m6.Kind]));
    }
    $.TSchema = X0;
  })(B || (m6.TypeGuard = B = {}));
  var p6;
  (function($) {
    function Y(W) {
      return W[m6.Kind] === "Intersect" ? W.allOf.every((X) => Y(X)) : W[m6.Kind] === "Union" ? W.anyOf.some((X) => Y(X)) : W[m6.Kind] === "Undefined" ? true : W[m6.Kind] === "Not" ? !Y(W.not) : false;
    }
    $.Check = Y;
  })(p6 || (m6.ExtendsUndefined = p6 = {}));

  class Z8 extends e0 {
  }
  m6.TypeExtendsError = Z8;
  var C;
  (function($) {
    $[$.Union = 0] = "Union", $[$.True = 1] = "True", $[$.False = 2] = "False";
  })(C || (m6.TypeExtendsResult = C = {}));
  var j1;
  (function($) {
    function Y(z) {
      return z === C.False ? z : C.True;
    }
    function W(z) {
      throw new Z8(z);
    }
    function X(z) {
      return B.TNever(z) || B.TIntersect(z) || B.TUnion(z) || B.TUnknown(z) || B.TAny(z);
    }
    function Z(z, H) {
      return B.TNever(H) ? G(z, H) : B.TIntersect(H) ? w(z, H) : B.TUnion(H) ? s$(z, H) : B.TUnknown(H) ? O6(z, H) : B.TAny(H) ? Q(z, H) : W("StructuralRight");
    }
    function Q(z, H) {
      return C.True;
    }
    function J(z, H) {
      return B.TIntersect(H) ? w(z, H) : B.TUnion(H) && H.anyOf.some((Y0) => B.TAny(Y0) || B.TUnknown(Y0)) ? C.True : B.TUnion(H) ? C.Union : B.TUnknown(H) ? C.True : B.TAny(H) ? C.True : C.Union;
    }
    function q(z, H) {
      return B.TUnknown(z) ? C.False : B.TAny(z) ? C.Union : B.TNever(z) ? C.True : C.False;
    }
    function F(z, H) {
      return B.TObject(H) && H0(H) ? C.True : X(H) ? Z(z, H) : !B.TArray(H) ? C.False : Y(Q0(z.items, H.items));
    }
    function D(z, H) {
      return X(H) ? Z(z, H) : !B.TAsyncIterator(H) ? C.False : Y(Q0(z.items, H.items));
    }
    function K(z, H) {
      return X(H) ? Z(z, H) : B.TObject(H) ? a(z, H) : B.TRecord(H) ? p(z, H) : B.TBigInt(H) ? C.True : C.False;
    }
    function A(z, H) {
      return B.TLiteral(z) && x.IsBoolean(z.const) ? C.True : B.TBoolean(z) ? C.True : C.False;
    }
    function I(z, H) {
      return X(H) ? Z(z, H) : B.TObject(H) ? a(z, H) : B.TRecord(H) ? p(z, H) : B.TBoolean(H) ? C.True : C.False;
    }
    function j(z, H) {
      return X(H) ? Z(z, H) : B.TObject(H) ? a(z, H) : !B.TConstructor(H) ? C.False : z.parameters.length > H.parameters.length ? C.False : !z.parameters.every((Y0, h0) => Y(Q0(H.parameters[h0], Y0)) === C.True) ? C.False : Y(Q0(z.returns, H.returns));
    }
    function M(z, H) {
      return X(H) ? Z(z, H) : B.TObject(H) ? a(z, H) : B.TRecord(H) ? p(z, H) : B.TDate(H) ? C.True : C.False;
    }
    function L(z, H) {
      return X(H) ? Z(z, H) : B.TObject(H) ? a(z, H) : !B.TFunction(H) ? C.False : z.parameters.length > H.parameters.length ? C.False : !z.parameters.every((Y0, h0) => Y(Q0(H.parameters[h0], Y0)) === C.True) ? C.False : Y(Q0(z.returns, H.returns));
    }
    function O(z, H) {
      return B.TLiteral(z) && x.IsNumber(z.const) ? C.True : B.TNumber(z) || B.TInteger(z) ? C.True : C.False;
    }
    function U(z, H) {
      return B.TInteger(H) || B.TNumber(H) ? C.True : X(H) ? Z(z, H) : B.TObject(H) ? a(z, H) : B.TRecord(H) ? p(z, H) : C.False;
    }
    function w(z, H) {
      return H.allOf.every((Y0) => Q0(z, Y0) === C.True) ? C.True : C.False;
    }
    function b(z, H) {
      return z.allOf.some((Y0) => Q0(Y0, H) === C.True) ? C.True : C.False;
    }
    function R(z, H) {
      return X(H) ? Z(z, H) : !B.TIterator(H) ? C.False : Y(Q0(z.items, H.items));
    }
    function V(z, H) {
      return B.TLiteral(H) && H.const === z.const ? C.True : X(H) ? Z(z, H) : B.TObject(H) ? a(z, H) : B.TRecord(H) ? p(z, H) : B.TString(H) ? T(z, H) : B.TNumber(H) ? w0(z, H) : B.TInteger(H) ? O(z, H) : B.TBoolean(H) ? A(z, H) : C.False;
    }
    function G(z, H) {
      return C.False;
    }
    function h(z, H) {
      return C.True;
    }
    function o(z) {
      let [H, Y0] = [z, 0];
      while (true) {
        if (!B.TNot(H))
          break;
        H = H.not, Y0 += 1;
      }
      return Y0 % 2 === 0 ? H : m6.Type.Unknown();
    }
    function $0(z, H) {
      return B.TNot(z) ? Q0(o(z), H) : B.TNot(H) ? Q0(z, o(H)) : W("Invalid fallthrough for Not");
    }
    function n0(z, H) {
      return X(H) ? Z(z, H) : B.TObject(H) ? a(z, H) : B.TRecord(H) ? p(z, H) : B.TNull(H) ? C.True : C.False;
    }
    function w0(z, H) {
      return B.TLiteralNumber(z) ? C.True : B.TNumber(z) || B.TInteger(z) ? C.True : C.False;
    }
    function k0(z, H) {
      return X(H) ? Z(z, H) : B.TObject(H) ? a(z, H) : B.TRecord(H) ? p(z, H) : B.TInteger(H) || B.TNumber(H) ? C.True : C.False;
    }
    function F0(z, H) {
      return Object.getOwnPropertyNames(z.properties).length === H;
    }
    function v0(z) {
      return H0(z);
    }
    function z0(z) {
      return F0(z, 0) || F0(z, 1) && ("description" in z.properties) && B.TUnion(z.properties.description) && z.properties.description.anyOf.length === 2 && (B.TString(z.properties.description.anyOf[0]) && B.TUndefined(z.properties.description.anyOf[1]) || B.TString(z.properties.description.anyOf[1]) && B.TUndefined(z.properties.description.anyOf[0]));
    }
    function p0(z) {
      return F0(z, 0);
    }
    function g0(z) {
      return F0(z, 0);
    }
    function N0(z) {
      return F0(z, 0);
    }
    function E(z) {
      return F0(z, 0);
    }
    function d(z) {
      return H0(z);
    }
    function u(z) {
      const H = m6.Type.Number();
      return F0(z, 0) || F0(z, 1) && ("length" in z.properties) && Y(Q0(z.properties.length, H)) === C.True;
    }
    function t(z) {
      return F0(z, 0);
    }
    function H0(z) {
      const H = m6.Type.Number();
      return F0(z, 0) || F0(z, 1) && ("length" in z.properties) && Y(Q0(z.properties.length, H)) === C.True;
    }
    function E0(z) {
      const H = m6.Type.Function([m6.Type.Any()], m6.Type.Any());
      return F0(z, 0) || F0(z, 1) && ("then" in z.properties) && Y(Q0(z.properties.then, H)) === C.True;
    }
    function D0(z, H) {
      return Q0(z, H) === C.False ? C.False : B.TOptional(z) && !B.TOptional(H) ? C.False : C.True;
    }
    function a(z, H) {
      return B.TUnknown(z) ? C.False : B.TAny(z) ? C.Union : B.TNever(z) || B.TLiteralString(z) && v0(H) || B.TLiteralNumber(z) && p0(H) || B.TLiteralBoolean(z) && g0(H) || B.TSymbol(z) && z0(H) || B.TBigInt(z) && N0(H) || B.TString(z) && v0(H) || B.TSymbol(z) && z0(H) || B.TNumber(z) && p0(H) || B.TInteger(z) && p0(H) || B.TBoolean(z) && g0(H) || B.TUint8Array(z) && d(H) || B.TDate(z) && E(H) || B.TConstructor(z) && t(H) || B.TFunction(z) && u(H) ? C.True : B.TRecord(z) && B.TString(_(z)) ? (() => {
        return H[m6.Hint] === "Record" ? C.True : C.False;
      })() : B.TRecord(z) && B.TNumber(_(z)) ? (() => {
        return F0(H, 0) ? C.True : C.False;
      })() : C.False;
    }
    function A1(z, H) {
      return X(H) ? Z(z, H) : B.TRecord(H) ? p(z, H) : !B.TObject(H) ? C.False : (() => {
        for (let Y0 of Object.getOwnPropertyNames(H.properties)) {
          if (!(Y0 in z.properties))
            return C.False;
          if (D0(z.properties[Y0], H.properties[Y0]) === C.False)
            return C.False;
        }
        return C.True;
      })();
    }
    function P(z, H) {
      return X(H) ? Z(z, H) : B.TObject(H) && E0(H) ? C.True : !B.TPromise(H) ? C.False : Y(Q0(z.item, H.item));
    }
    function _(z) {
      return m6.PatternNumberExact in z.patternProperties ? m6.Type.Number() : (m6.PatternStringExact in z.patternProperties) ? m6.Type.String() : W("Unknown record key pattern");
    }
    function S(z) {
      return m6.PatternNumberExact in z.patternProperties ? z.patternProperties[m6.PatternNumberExact] : (m6.PatternStringExact in z.patternProperties) ? z.patternProperties[m6.PatternStringExact] : W("Unable to get record value schema");
    }
    function p(z, H) {
      const [Y0, h0] = [_(H), S(H)];
      return B.TLiteralString(z) && B.TNumber(Y0) && Y(Q0(z, h0)) === C.True ? C.True : B.TUint8Array(z) && B.TNumber(Y0) ? Q0(z, h0) : B.TString(z) && B.TNumber(Y0) ? Q0(z, h0) : B.TArray(z) && B.TNumber(Y0) ? Q0(z, h0) : B.TObject(z) ? (() => {
        for (let aW of Object.getOwnPropertyNames(z.properties))
          if (D0(h0, z.properties[aW]) === C.False)
            return C.False;
        return C.True;
      })() : C.False;
    }
    function f(z, H) {
      return X(H) ? Z(z, H) : B.TObject(H) ? a(z, H) : !B.TRecord(H) ? C.False : Q0(S(z), S(H));
    }
    function T(z, H) {
      return B.TLiteral(z) && x.IsString(z.const) ? C.True : B.TString(z) ? C.True : C.False;
    }
    function W0(z, H) {
      return X(H) ? Z(z, H) : B.TObject(H) ? a(z, H) : B.TRecord(H) ? p(z, H) : B.TString(H) ? C.True : C.False;
    }
    function K0(z, H) {
      return X(H) ? Z(z, H) : B.TObject(H) ? a(z, H) : B.TRecord(H) ? p(z, H) : B.TSymbol(H) ? C.True : C.False;
    }
    function X0(z, H) {
      return B.TTemplateLiteral(z) ? Q0(Z1.Resolve(z), H) : B.TTemplateLiteral(H) ? Q0(z, Z1.Resolve(H)) : W("Invalid fallthrough for TemplateLiteral");
    }
    function N(z, H) {
      return B.TArray(H) && z.items !== undefined && z.items.every((Y0) => Q0(Y0, H.items) === C.True);
    }
    function l(z, H) {
      return B.TNever(z) ? C.True : B.TUnknown(z) ? C.False : B.TAny(z) ? C.Union : C.False;
    }
    function S0(z, H) {
      return X(H) ? Z(z, H) : B.TObject(H) && H0(H) ? C.True : B.TArray(H) && N(z, H) ? C.True : !B.TTuple(H) ? C.False : x.IsUndefined(z.items) && !x.IsUndefined(H.items) || !x.IsUndefined(z.items) && x.IsUndefined(H.items) ? C.False : x.IsUndefined(z.items) && !x.IsUndefined(H.items) ? C.True : z.items.every((Y0, h0) => Q0(Y0, H.items[h0]) === C.True) ? C.True : C.False;
    }
    function l$(z, H) {
      return X(H) ? Z(z, H) : B.TObject(H) ? a(z, H) : B.TRecord(H) ? p(z, H) : B.TUint8Array(H) ? C.True : C.False;
    }
    function t$(z, H) {
      return X(H) ? Z(z, H) : B.TObject(H) ? a(z, H) : B.TRecord(H) ? p(z, H) : B.TVoid(H) ? tW(z, H) : B.TUndefined(H) ? C.True : C.False;
    }
    function s$(z, H) {
      return H.anyOf.some((Y0) => Q0(z, Y0) === C.True) ? C.True : C.False;
    }
    function cW(z, H) {
      return z.anyOf.every((Y0) => Q0(Y0, H) === C.True) ? C.True : C.False;
    }
    function O6(z, H) {
      return C.True;
    }
    function lW(z, H) {
      return B.TNever(H) ? G(z, H) : B.TIntersect(H) ? w(z, H) : B.TUnion(H) ? s$(z, H) : B.TAny(H) ? Q(z, H) : B.TString(H) ? T(z, H) : B.TNumber(H) ? w0(z, H) : B.TInteger(H) ? O(z, H) : B.TBoolean(H) ? A(z, H) : B.TArray(H) ? q(z, H) : B.TTuple(H) ? l(z, H) : B.TObject(H) ? a(z, H) : B.TUnknown(H) ? C.True : C.False;
    }
    function tW(z, H) {
      return B.TUndefined(z) ? C.True : B.TUndefined(z) ? C.True : C.False;
    }
    function sW(z, H) {
      return B.TIntersect(H) ? w(z, H) : B.TUnion(H) ? s$(z, H) : B.TUnknown(H) ? O6(z, H) : B.TAny(H) ? Q(z, H) : B.TObject(H) ? a(z, H) : B.TVoid(H) ? C.True : C.False;
    }
    function Q0(z, H) {
      return B.TTemplateLiteral(z) || B.TTemplateLiteral(H) ? X0(z, H) : B.TNot(z) || B.TNot(H) ? $0(z, H) : B.TAny(z) ? J(z, H) : B.TArray(z) ? F(z, H) : B.TBigInt(z) ? K(z, H) : B.TBoolean(z) ? I(z, H) : B.TAsyncIterator(z) ? D(z, H) : B.TConstructor(z) ? j(z, H) : B.TDate(z) ? M(z, H) : B.TFunction(z) ? L(z, H) : B.TInteger(z) ? U(z, H) : B.TIntersect(z) ? b(z, H) : B.TIterator(z) ? R(z, H) : B.TLiteral(z) ? V(z, H) : B.TNever(z) ? h(z, H) : B.TNull(z) ? n0(z, H) : B.TNumber(z) ? k0(z, H) : B.TObject(z) ? A1(z, H) : B.TRecord(z) ? f(z, H) : B.TString(z) ? W0(z, H) : B.TSymbol(z) ? K0(z, H) : B.TTuple(z) ? S0(z, H) : B.TPromise(z) ? P(z, H) : B.TUint8Array(z) ? l$(z, H) : B.TUndefined(z) ? t$(z, H) : B.TUnion(z) ? cW(z, H) : B.TUnknown(z) ? lW(z, H) : B.TVoid(z) ? sW(z, H) : W(`Unknown left type operand '${z[m6.Kind]}'`);
    }
    function rW(z, H) {
      return Q0(z, H);
    }
    $.Extends = rW;
  })(j1 || (m6.TypeExtends = j1 = {}));
  var i;
  (function($) {
    function Y(J) {
      const q = Object.getOwnPropertyNames(J).reduce((D, K) => ({ ...D, [K]: X(J[K]) }), {}), F = Object.getOwnPropertySymbols(J).reduce((D, K) => ({ ...D, [K]: X(J[K]) }), {});
      return { ...q, ...F };
    }
    function W(J) {
      return J.map((q) => X(q));
    }
    function X(J) {
      return x.IsArray(J) ? W(J) : x.IsObject(J) ? Y(J) : J;
    }
    function Z(J) {
      return J.map((q) => Q(q));
    }
    $.Rest = Z;
    function Q(J, q = {}) {
      return { ...X(J), ...q };
    }
    $.Type = Q;
  })(i || (m6.TypeClone = i = {}));
  var Y8;
  (function($) {
    function Y(j) {
      return j.map((M) => {
        const { [m6.Optional]: L, ...O } = i.Type(M);
        return O;
      });
    }
    function W(j) {
      return j.every((M) => B.TOptional(M));
    }
    function X(j) {
      return j.some((M) => B.TOptional(M));
    }
    function Z(j) {
      return W(j.allOf) ? m6.Type.Optional(m6.Type.Intersect(Y(j.allOf))) : j;
    }
    function Q(j) {
      return X(j.anyOf) ? m6.Type.Optional(m6.Type.Union(Y(j.anyOf))) : j;
    }
    function J(j) {
      return j[m6.Kind] === "Intersect" ? Z(j) : j[m6.Kind] === "Union" ? Q(j) : j;
    }
    function q(j, M) {
      const L = j.allOf.reduce((O, U) => {
        const w = A(U, M);
        return w[m6.Kind] === "Never" ? O : [...O, w];
      }, []);
      return J(m6.Type.Intersect(L));
    }
    function F(j, M) {
      const L = j.anyOf.map((O) => A(O, M));
      return J(m6.Type.Union(L));
    }
    function D(j, M) {
      const L = j.properties[M];
      return x.IsUndefined(L) ? m6.Type.Never() : m6.Type.Union([L]);
    }
    function K(j, M) {
      const L = j.items;
      if (x.IsUndefined(L))
        return m6.Type.Never();
      const O = L[M];
      if (x.IsUndefined(O))
        return m6.Type.Never();
      return O;
    }
    function A(j, M) {
      return j[m6.Kind] === "Intersect" ? q(j, M) : j[m6.Kind] === "Union" ? F(j, M) : j[m6.Kind] === "Object" ? D(j, M) : j[m6.Kind] === "Tuple" ? K(j, M) : m6.Type.Never();
    }
    function I(j, M, L = {}) {
      const O = M.map((U) => A(j, U.toString()));
      return J(m6.Type.Union(O, L));
    }
    $.Resolve = I;
  })(Y8 || (m6.IndexedAccessor = Y8 = {}));
  var V1;
  (function($) {
    function Y(K) {
      const [A, I] = [K.slice(0, 1), K.slice(1)];
      return `${A.toLowerCase()}${I}`;
    }
    function W(K) {
      const [A, I] = [K.slice(0, 1), K.slice(1)];
      return `${A.toUpperCase()}${I}`;
    }
    function X(K) {
      return K.toUpperCase();
    }
    function Z(K) {
      return K.toLowerCase();
    }
    function Q(K, A) {
      const I = f1.ParseExact(K.pattern);
      if (!T1.Check(I))
        return { ...K, pattern: J(K.pattern, A) };
      const L = [...d1.Generate(I)].map((w) => m6.Type.Literal(w)), O = q(L, A), U = m6.Type.Union(O);
      return m6.Type.TemplateLiteral([U]);
    }
    function J(K, A) {
      return typeof K === "string" ? A === "Uncapitalize" ? Y(K) : A === "Capitalize" ? W(K) : A === "Uppercase" ? X(K) : A === "Lowercase" ? Z(K) : K : K.toString();
    }
    function q(K, A) {
      if (K.length === 0)
        return [];
      const [I, ...j] = K;
      return [D(I, A), ...q(j, A)];
    }
    function F(K, A) {
      return B.TTemplateLiteral(K) ? Q(K, A) : B.TUnion(K) ? m6.Type.Union(q(K.anyOf, A)) : B.TLiteral(K) ? m6.Type.Literal(J(K.const, A)) : K;
    }
    function D(K, A) {
      return F(K, A);
    }
    $.Map = D;
  })(V1 || (m6.Intrinsic = V1 = {}));
  var x1;
  (function($) {
    function Y(J, q) {
      return m6.Type.Intersect(J.allOf.map((F) => Z(F, q)), { ...J });
    }
    function W(J, q) {
      return m6.Type.Union(J.anyOf.map((F) => Z(F, q)), { ...J });
    }
    function X(J, q) {
      return q(J);
    }
    function Z(J, q) {
      return J[m6.Kind] === "Intersect" ? Y(J, q) : J[m6.Kind] === "Union" ? W(J, q) : J[m6.Kind] === "Object" ? X(J, q) : J;
    }
    function Q(J, q, F) {
      return { ...Z(i.Type(J), q), ...F };
    }
    $.Map = Q;
  })(x1 || (m6.ObjectMap = x1 = {}));
  var P$;
  (function($) {
    function Y(D) {
      return D[0] === "^" && D[D.length - 1] === "$" ? D.slice(1, D.length - 1) : D;
    }
    function W(D, K) {
      return D.allOf.reduce((A, I) => [...A, ...J(I, K)], []);
    }
    function X(D, K) {
      const A = D.anyOf.map((I) => J(I, K));
      return [...A.reduce((I, j) => j.map((M) => A.every((L) => L.includes(M)) ? I.add(M) : I)[0], new Set)];
    }
    function Z(D, K) {
      return Object.getOwnPropertyNames(D.properties);
    }
    function Q(D, K) {
      return K.includePatterns ? Object.getOwnPropertyNames(D.patternProperties) : [];
    }
    function J(D, K) {
      return B.TIntersect(D) ? W(D, K) : B.TUnion(D) ? X(D, K) : B.TObject(D) ? Z(D, K) : B.TRecord(D) ? Q(D, K) : [];
    }
    function q(D, K) {
      return [...new Set(J(D, K))];
    }
    $.ResolveKeys = q;
    function F(D) {
      return `^(${q(D, { includePatterns: true }).map((I) => `(${Y(I)})`).join("|")})$`;
    }
    $.ResolvePattern = F;
  })(P$ || (m6.KeyResolver = P$ = {}));

  class Q8 extends e0 {
  }
  m6.KeyArrayResolverError = Q8;
  var a1;
  (function($) {
    function Y(W) {
      return Array.isArray(W) ? W : B.TUnionLiteral(W) ? W.anyOf.map((X) => X.const.toString()) : B.TLiteral(W) ? [W.const] : B.TTemplateLiteral(W) ? (() => {
        const X = f1.ParseExact(W.pattern);
        if (!T1.Check(X))
          throw new Q8("Cannot resolve keys from infinite template expression");
        return [...d1.Generate(X)];
      })() : [];
    }
    $.Resolve = Y;
  })(a1 || (m6.KeyArrayResolver = a1 = {}));
  var W8;
  (function($) {
    function* Y(X) {
      for (let Z of X.anyOf)
        if (Z[m6.Kind] === "Union")
          yield* Y(Z);
        else
          yield Z;
    }
    function W(X) {
      return m6.Type.Union([...Y(X)], { ...X });
    }
    $.Resolve = W;
  })(W8 || (m6.UnionResolver = W8 = {}));

  class J8 extends e0 {
  }
  m6.TemplateLiteralPatternError = J8;
  var O$;
  (function($) {
    function Y(Q) {
      throw new J8(Q);
    }
    function W(Q) {
      return Q.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function X(Q, J) {
      return B.TTemplateLiteral(Q) ? Q.pattern.slice(1, Q.pattern.length - 1) : B.TUnion(Q) ? `(${Q.anyOf.map((q) => X(q, J)).join("|")})` : B.TNumber(Q) ? `${J}${m6.PatternNumber}` : B.TInteger(Q) ? `${J}${m6.PatternNumber}` : B.TBigInt(Q) ? `${J}${m6.PatternNumber}` : B.TString(Q) ? `${J}${m6.PatternString}` : B.TLiteral(Q) ? `${J}${W(Q.const.toString())}` : B.TBoolean(Q) ? `${J}${m6.PatternBoolean}` : Y(`Unexpected Kind '${Q[m6.Kind]}'`);
    }
    function Z(Q) {
      return `^${Q.map((J) => X(J, "")).join("")}\$`;
    }
    $.Create = Z;
  })(O$ || (m6.TemplateLiteralPattern = O$ = {}));
  var Z1;
  (function($) {
    function Y(W) {
      const X = f1.ParseExact(W.pattern);
      if (!T1.Check(X))
        return m6.Type.String();
      const Z = [...d1.Generate(X)].map((Q) => m6.Type.Literal(Q));
      return m6.Type.Union(Z);
    }
    $.Resolve = Y;
  })(Z1 || (m6.TemplateLiteralResolver = Z1 = {}));

  class S$ extends e0 {
  }
  m6.TemplateLiteralParserError = S$;
  var f1;
  (function($) {
    function Y(j, M, L) {
      return j[M] === L && j.charCodeAt(M - 1) !== 92;
    }
    function W(j, M) {
      return Y(j, M, "(");
    }
    function X(j, M) {
      return Y(j, M, ")");
    }
    function Z(j, M) {
      return Y(j, M, "|");
    }
    function Q(j) {
      if (!(W(j, 0) && X(j, j.length - 1)))
        return false;
      let M = 0;
      for (let L = 0;L < j.length; L++) {
        if (W(j, L))
          M += 1;
        if (X(j, L))
          M -= 1;
        if (M === 0 && L !== j.length - 1)
          return false;
      }
      return true;
    }
    function J(j) {
      return j.slice(1, j.length - 1);
    }
    function q(j) {
      let M = 0;
      for (let L = 0;L < j.length; L++) {
        if (W(j, L))
          M += 1;
        if (X(j, L))
          M -= 1;
        if (Z(j, L) && M === 0)
          return true;
      }
      return false;
    }
    function F(j) {
      for (let M = 0;M < j.length; M++)
        if (W(j, M))
          return true;
      return false;
    }
    function D(j) {
      let [M, L] = [0, 0];
      const O = [];
      for (let w = 0;w < j.length; w++) {
        if (W(j, w))
          M += 1;
        if (X(j, w))
          M -= 1;
        if (Z(j, w) && M === 0) {
          const b = j.slice(L, w);
          if (b.length > 0)
            O.push(A(b));
          L = w + 1;
        }
      }
      const U = j.slice(L);
      if (U.length > 0)
        O.push(A(U));
      if (O.length === 0)
        return { type: "const", const: "" };
      if (O.length === 1)
        return O[0];
      return { type: "or", expr: O };
    }
    function K(j) {
      function M(U, w) {
        if (!W(U, w))
          throw new S$("TemplateLiteralParser: Index must point to open parens");
        let b = 0;
        for (let R = w;R < U.length; R++) {
          if (W(U, R))
            b += 1;
          if (X(U, R))
            b -= 1;
          if (b === 0)
            return [w, R];
        }
        throw new S$("TemplateLiteralParser: Unclosed group parens in expression");
      }
      function L(U, w) {
        for (let b = w;b < U.length; b++)
          if (W(U, b))
            return [w, b];
        return [w, U.length];
      }
      const O = [];
      for (let U = 0;U < j.length; U++)
        if (W(j, U)) {
          const [w, b] = M(j, U), R = j.slice(w, b + 1);
          O.push(A(R)), U = b;
        } else {
          const [w, b] = L(j, U), R = j.slice(w, b);
          if (R.length > 0)
            O.push(A(R));
          U = b - 1;
        }
      return O.length === 0 ? { type: "const", const: "" } : O.length === 1 ? O[0] : { type: "and", expr: O };
    }
    function A(j) {
      return Q(j) ? A(J(j)) : q(j) ? D(j) : F(j) ? K(j) : { type: "const", const: j };
    }
    $.Parse = A;
    function I(j) {
      return A(j.slice(1, j.length - 1));
    }
    $.ParseExact = I;
  })(f1 || (m6.TemplateLiteralParser = f1 = {}));

  class z8 extends e0 {
  }
  m6.TemplateLiteralFiniteError = z8;
  var T1;
  (function($) {
    function Y(J) {
      throw new z8(J);
    }
    function W(J) {
      return J.type === "or" && J.expr.length === 2 && J.expr[0].type === "const" && J.expr[0].const === "0" && J.expr[1].type === "const" && J.expr[1].const === "[1-9][0-9]*";
    }
    function X(J) {
      return J.type === "or" && J.expr.length === 2 && J.expr[0].type === "const" && J.expr[0].const === "true" && J.expr[1].type === "const" && J.expr[1].const === "false";
    }
    function Z(J) {
      return J.type === "const" && J.const === ".*";
    }
    function Q(J) {
      return X(J) ? true : W(J) || Z(J) ? false : J.type === "and" ? J.expr.every((q) => Q(q)) : J.type === "or" ? J.expr.every((q) => Q(q)) : J.type === "const" ? true : Y("Unknown expression type");
    }
    $.Check = Q;
  })(T1 || (m6.TemplateLiteralFinite = T1 = {}));

  class H8 extends e0 {
  }
  m6.TemplateLiteralGeneratorError = H8;
  var d1;
  (function($) {
    function* Y(J) {
      if (J.length === 1)
        return yield* J[0];
      for (let q of J[0])
        for (let F of Y(J.slice(1)))
          yield `${q}${F}`;
    }
    function* W(J) {
      return yield* Y(J.expr.map((q) => [...Q(q)]));
    }
    function* X(J) {
      for (let q of J.expr)
        yield* Q(q);
    }
    function* Z(J) {
      return yield J.const;
    }
    function* Q(J) {
      return J.type === "and" ? yield* W(J) : J.type === "or" ? yield* X(J) : J.type === "const" ? yield* Z(J) : (() => {
        throw new H8("Unknown expression");
      })();
    }
    $.Generate = Q;
  })(d1 || (m6.TemplateLiteralGenerator = d1 = {}));
  var X8;
  (function($) {
    function* Y(Q) {
      const J = Q.trim().replace(/"|'/g, "");
      return J === "boolean" ? yield m6.Type.Boolean() : J === "number" ? yield m6.Type.Number() : J === "bigint" ? yield m6.Type.BigInt() : J === "string" ? yield m6.Type.String() : yield (() => {
        const q = J.split("|").map((F) => m6.Type.Literal(F.trim()));
        return q.length === 0 ? m6.Type.Never() : q.length === 1 ? q[0] : m6.Type.Union(q);
      })();
    }
    function* W(Q) {
      if (Q[1] !== "{") {
        const J = m6.Type.Literal("$"), q = X(Q.slice(1));
        return yield* [J, ...q];
      }
      for (let J = 2;J < Q.length; J++)
        if (Q[J] === "}") {
          const q = Y(Q.slice(2, J)), F = X(Q.slice(J + 1));
          return yield* [...q, ...F];
        }
      yield m6.Type.Literal(Q);
    }
    function* X(Q) {
      for (let J = 0;J < Q.length; J++)
        if (Q[J] === "$") {
          const q = m6.Type.Literal(Q.slice(0, J)), F = W(Q.slice(J));
          return yield* [q, ...F];
        }
      yield m6.Type.Literal(Q);
    }
    function Z(Q) {
      return [...X(Q)];
    }
    $.Parse = Z;
  })(X8 || (m6.TemplateLiteralDslParser = X8 = {}));

  class q8 {
    constructor($) {
      this.schema = $;
    }
    Decode($) {
      return new N8(this.schema, $);
    }
  }
  m6.TransformDecodeBuilder = q8;

  class N8 {
    constructor($, Y) {
      this.schema = $, this.decode = Y;
    }
    Encode($) {
      const Y = i.Type(this.schema);
      return B.TTransform(Y) ? (() => {
        const Z = { Encode: (Q) => Y[m6.Transform].Encode($(Q)), Decode: (Q) => this.decode(Y[m6.Transform].Decode(Q)) };
        return { ...Y, [m6.Transform]: Z };
      })() : (() => {
        const W = { Decode: this.decode, Encode: $ };
        return { ...Y, [m6.Transform]: W };
      })();
    }
  }
  m6.TransformEncodeBuilder = N8;
  var TX = 0;

  class M8 extends e0 {
  }
  m6.TypeBuilderError = M8;

  class U8 {
    Create($) {
      return $;
    }
    Throw($) {
      throw new M8($);
    }
    Discard($, Y) {
      return Y.reduce((W, X) => {
        const { [X]: Z, ...Q } = W;
        return Q;
      }, $);
    }
    Strict($) {
      return JSON.parse(JSON.stringify($));
    }
  }
  m6.TypeBuilder = U8;

  class L$ extends U8 {
    ReadonlyOptional($) {
      return this.Readonly(this.Optional($));
    }
    Readonly($) {
      return { ...i.Type($), [m6.Readonly]: "Readonly" };
    }
    Optional($) {
      return { ...i.Type($), [m6.Optional]: "Optional" };
    }
    Any($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Any" });
    }
    Array($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Array", type: "array", items: i.Type($) });
    }
    Boolean($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Boolean", type: "boolean" });
    }
    Capitalize($, Y = {}) {
      return { ...V1.Map(i.Type($), "Capitalize"), ...Y };
    }
    Composite($, Y) {
      const W = m6.Type.Intersect($, {}), Z = P$.ResolveKeys(W, { includePatterns: false }).reduce((Q, J) => ({ ...Q, [J]: m6.Type.Index(W, [J]) }), {});
      return m6.Type.Object(Z, Y);
    }
    Enum($, Y = {}) {
      const W = Object.getOwnPropertyNames($).filter((Q) => isNaN(Q)).map((Q) => $[Q]), Z = [...new Set(W)].map((Q) => m6.Type.Literal(Q));
      return this.Union(Z, { ...Y, [m6.Hint]: "Enum" });
    }
    Extends($, Y, W, X, Z = {}) {
      switch (j1.Extends($, Y)) {
        case C.Union:
          return this.Union([i.Type(W, Z), i.Type(X, Z)]);
        case C.True:
          return i.Type(W, Z);
        case C.False:
          return i.Type(X, Z);
      }
    }
    Exclude($, Y, W = {}) {
      return B.TTemplateLiteral($) ? this.Exclude(Z1.Resolve($), Y, W) : B.TTemplateLiteral(Y) ? this.Exclude($, Z1.Resolve(Y), W) : B.TUnion($) ? (() => {
        const X = $.anyOf.filter((Z) => j1.Extends(Z, Y) === C.False);
        return X.length === 1 ? i.Type(X[0], W) : this.Union(X, W);
      })() : j1.Extends($, Y) !== C.False ? this.Never(W) : i.Type($, W);
    }
    Extract($, Y, W = {}) {
      return B.TTemplateLiteral($) ? this.Extract(Z1.Resolve($), Y, W) : B.TTemplateLiteral(Y) ? this.Extract($, Z1.Resolve(Y), W) : B.TUnion($) ? (() => {
        const X = $.anyOf.filter((Z) => j1.Extends(Z, Y) !== C.False);
        return X.length === 1 ? i.Type(X[0], W) : this.Union(X, W);
      })() : j1.Extends($, Y) !== C.False ? i.Type($, W) : this.Never(W);
    }
    Index($, Y, W = {}) {
      return B.TArray($) && B.TNumber(Y) ? (() => {
        return i.Type($.items, W);
      })() : B.TTuple($) && B.TNumber(Y) ? (() => {
        const Z = (x.IsUndefined($.items) ? [] : $.items).map((Q) => i.Type(Q));
        return this.Union(Z, W);
      })() : (() => {
        const X = a1.Resolve(Y), Z = i.Type($);
        return Y8.Resolve(Z, X, W);
      })();
    }
    Integer($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Integer", type: "integer" });
    }
    Intersect($, Y = {}) {
      if ($.length === 0)
        return m6.Type.Never();
      if ($.length === 1)
        return i.Type($[0], Y);
      if ($.some((Q) => B.TTransform(Q)))
        this.Throw("Cannot intersect transform types");
      const W = $.every((Q) => B.TObject(Q)), X = i.Rest($), Z = B.TSchema(Y.unevaluatedProperties) ? { unevaluatedProperties: i.Type(Y.unevaluatedProperties) } : {};
      return Y.unevaluatedProperties === false || B.TSchema(Y.unevaluatedProperties) || W ? this.Create({ ...Y, ...Z, [m6.Kind]: "Intersect", type: "object", allOf: X }) : this.Create({ ...Y, ...Z, [m6.Kind]: "Intersect", allOf: X });
    }
    KeyOf($, Y = {}) {
      return B.TRecord($) ? (() => {
        const W = Object.getOwnPropertyNames($.patternProperties)[0];
        return W === m6.PatternNumberExact ? this.Number(Y) : W === m6.PatternStringExact ? this.String(Y) : this.Throw("Unable to resolve key type from Record key pattern");
      })() : B.TTuple($) ? (() => {
        const X = (x.IsUndefined($.items) ? [] : $.items).map((Z, Q) => m6.Type.Literal(Q.toString()));
        return this.Union(X, Y);
      })() : B.TArray($) ? (() => {
        return this.Number(Y);
      })() : (() => {
        const W = P$.ResolveKeys($, { includePatterns: false });
        if (W.length === 0)
          return this.Never(Y);
        const X = W.map((Z) => this.Literal(Z));
        return this.Union(X, Y);
      })();
    }
    Literal($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Literal", const: $, type: typeof $ });
    }
    Lowercase($, Y = {}) {
      return { ...V1.Map(i.Type($), "Lowercase"), ...Y };
    }
    Never($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Never", not: {} });
    }
    Not($, Y) {
      return this.Create({ ...Y, [m6.Kind]: "Not", not: i.Type($) });
    }
    Null($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Null", type: "null" });
    }
    Number($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Number", type: "number" });
    }
    Object($, Y = {}) {
      const W = Object.getOwnPropertyNames($), X = W.filter((q) => B.TOptional($[q])), Z = W.filter((q) => !X.includes(q)), Q = B.TSchema(Y.additionalProperties) ? { additionalProperties: i.Type(Y.additionalProperties) } : {}, J = W.reduce((q, F) => ({ ...q, [F]: i.Type($[F]) }), {});
      return Z.length > 0 ? this.Create({ ...Y, ...Q, [m6.Kind]: "Object", type: "object", properties: J, required: Z }) : this.Create({ ...Y, ...Q, [m6.Kind]: "Object", type: "object", properties: J });
    }
    Omit($, Y, W = {}) {
      const X = a1.Resolve(Y);
      return x1.Map(this.Discard(i.Type($), ["$id", m6.Transform]), (Z) => {
        if (x.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((Q) => !X.includes(Q)), Z.required.length === 0)
            delete Z.required;
        }
        for (let Q of Object.getOwnPropertyNames(Z.properties))
          if (X.includes(Q))
            delete Z.properties[Q];
        return this.Create(Z);
      }, W);
    }
    Partial($, Y = {}) {
      return x1.Map(this.Discard(i.Type($), ["$id", m6.Transform]), (W) => {
        const X = Object.getOwnPropertyNames(W.properties).reduce((Z, Q) => {
          return { ...Z, [Q]: this.Optional(W.properties[Q]) };
        }, {});
        return this.Object(X, this.Discard(W, ["required"]));
      }, Y);
    }
    Pick($, Y, W = {}) {
      const X = a1.Resolve(Y);
      return x1.Map(this.Discard(i.Type($), ["$id", m6.Transform]), (Z) => {
        if (x.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((Q) => X.includes(Q)), Z.required.length === 0)
            delete Z.required;
        }
        for (let Q of Object.getOwnPropertyNames(Z.properties))
          if (!X.includes(Q))
            delete Z.properties[Q];
        return this.Create(Z);
      }, W);
    }
    Record($, Y, W = {}) {
      return B.TTemplateLiteral($) ? (() => {
        const X = f1.ParseExact($.pattern);
        return T1.Check(X) ? this.Object([...d1.Generate(X)].reduce((Z, Q) => ({ ...Z, [Q]: i.Type(Y) }), {}), W) : this.Create({ ...W, [m6.Kind]: "Record", type: "object", patternProperties: { [$.pattern]: i.Type(Y) } });
      })() : B.TUnion($) ? (() => {
        const X = W8.Resolve($);
        if (B.TUnionLiteral(X)) {
          const Z = X.anyOf.reduce((Q, J) => ({ ...Q, [J.const]: i.Type(Y) }), {});
          return this.Object(Z, { ...W, [m6.Hint]: "Record" });
        } else
          this.Throw("Record key of type union contains non-literal types");
      })() : B.TLiteral($) ? (() => {
        return x.IsString($.const) || x.IsNumber($.const) ? this.Object({ [$.const]: i.Type(Y) }, W) : this.Throw("Record key of type literal is not of type string or number");
      })() : B.TInteger($) || B.TNumber($) ? (() => {
        return this.Create({ ...W, [m6.Kind]: "Record", type: "object", patternProperties: { [m6.PatternNumberExact]: i.Type(Y) } });
      })() : B.TString($) ? (() => {
        const X = x.IsUndefined($.pattern) ? m6.PatternStringExact : $.pattern;
        return this.Create({ ...W, [m6.Kind]: "Record", type: "object", patternProperties: { [X]: i.Type(Y) } });
      })() : this.Never();
    }
    Recursive($, Y = {}) {
      if (x.IsUndefined(Y.$id))
        Y.$id = `T${TX++}`;
      const W = $({ [m6.Kind]: "This", $ref: `${Y.$id}` });
      return W.$id = Y.$id, this.Create({ ...Y, [m6.Hint]: "Recursive", ...W });
    }
    Ref($, Y = {}) {
      if (x.IsString($))
        return this.Create({ ...Y, [m6.Kind]: "Ref", $ref: $ });
      if (x.IsUndefined($.$id))
        this.Throw("Reference target type must specify an $id");
      return this.Create({ ...Y, [m6.Kind]: "Ref", $ref: $.$id });
    }
    Required($, Y = {}) {
      return x1.Map(this.Discard(i.Type($), ["$id", m6.Transform]), (W) => {
        const X = Object.getOwnPropertyNames(W.properties).reduce((Z, Q) => {
          return { ...Z, [Q]: this.Discard(W.properties[Q], [m6.Optional]) };
        }, {});
        return this.Object(X, W);
      }, Y);
    }
    Rest($) {
      return B.TTuple($) && !x.IsUndefined($.items) ? i.Rest($.items) : B.TIntersect($) ? i.Rest($.allOf) : B.TUnion($) ? i.Rest($.anyOf) : [];
    }
    String($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "String", type: "string" });
    }
    TemplateLiteral($, Y = {}) {
      const W = x.IsString($) ? O$.Create(X8.Parse($)) : O$.Create($);
      return this.Create({ ...Y, [m6.Kind]: "TemplateLiteral", type: "string", pattern: W });
    }
    Transform($) {
      return new q8($);
    }
    Tuple($, Y = {}) {
      const [W, X, Z] = [false, $.length, $.length], Q = i.Rest($), J = $.length > 0 ? { ...Y, [m6.Kind]: "Tuple", type: "array", items: Q, additionalItems: W, minItems: X, maxItems: Z } : { ...Y, [m6.Kind]: "Tuple", type: "array", minItems: X, maxItems: Z };
      return this.Create(J);
    }
    Uncapitalize($, Y = {}) {
      return { ...V1.Map(i.Type($), "Uncapitalize"), ...Y };
    }
    Union($, Y = {}) {
      return B.TTemplateLiteral($) ? Z1.Resolve($) : (() => {
        const W = $;
        if (W.length === 0)
          return this.Never(Y);
        if (W.length === 1)
          return this.Create(i.Type(W[0], Y));
        const X = i.Rest(W);
        return this.Create({ ...Y, [m6.Kind]: "Union", anyOf: X });
      })();
    }
    Unknown($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Unknown" });
    }
    Unsafe($ = {}) {
      return this.Create({ ...$, [m6.Kind]: $[m6.Kind] || "Unsafe" });
    }
    Uppercase($, Y = {}) {
      return { ...V1.Map(i.Type($), "Uppercase"), ...Y };
    }
  }
  m6.JsonTypeBuilder = L$;

  class F8 extends L$ {
    AsyncIterator($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "AsyncIterator", type: "AsyncIterator", items: i.Type($) });
    }
    Awaited($, Y = {}) {
      const W = (X) => X.length > 0 ? (() => {
        const [Z, ...Q] = X;
        return [this.Awaited(Z), ...W(Q)];
      })() : X;
      return B.TIntersect($) ? m6.Type.Intersect(W($.allOf)) : B.TUnion($) ? m6.Type.Union(W($.anyOf)) : B.TPromise($) ? this.Awaited($.item) : i.Type($, Y);
    }
    BigInt($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "BigInt", type: "bigint" });
    }
    ConstructorParameters($, Y = {}) {
      return this.Tuple([...$.parameters], { ...Y });
    }
    Constructor($, Y, W) {
      const [X, Z] = [i.Rest($), i.Type(Y)];
      return this.Create({ ...W, [m6.Kind]: "Constructor", type: "Constructor", parameters: X, returns: Z });
    }
    Date($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Date", type: "Date" });
    }
    Function($, Y, W) {
      const [X, Z] = [i.Rest($), i.Type(Y)];
      return this.Create({ ...W, [m6.Kind]: "Function", type: "Function", parameters: X, returns: Z });
    }
    InstanceType($, Y = {}) {
      return i.Type($.returns, Y);
    }
    Iterator($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Iterator", type: "Iterator", items: i.Type($) });
    }
    Parameters($, Y = {}) {
      return this.Tuple($.parameters, { ...Y });
    }
    Promise($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Promise", type: "Promise", item: i.Type($) });
    }
    RegExp($, Y = {}) {
      const W = x.IsString($) ? $ : $.source;
      return this.Create({ ...Y, [m6.Kind]: "String", type: "string", pattern: W });
    }
    RegEx($, Y = {}) {
      return this.RegExp($, Y);
    }
    ReturnType($, Y = {}) {
      return i.Type($.returns, Y);
    }
    Symbol($) {
      return this.Create({ ...$, [m6.Kind]: "Symbol", type: "symbol" });
    }
    Undefined($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Undefined", type: "undefined" });
    }
    Uint8Array($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Uint8Array", type: "Uint8Array" });
    }
    Void($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Void", type: "void" });
    }
  }
  m6.JavaScriptTypeBuilder = F8;
  m6.JsonType = new L$;
  m6.Type = new F8;
});
var P8 = J0((o6) => {
  var w8 = function($, Y) {
    switch (Y) {
      case y.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case y.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${$.maxContains} matching values`;
      case y.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${$.minContains} matching values`;
      case y.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${$.maxItems}`;
      case y.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${$.minItems}`;
      case y.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case y.ValueErrorType.Array:
        return "Expected array";
      case y.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case y.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.BigInt:
        return "Expected bigint";
      case y.ValueErrorType.Boolean:
        return "Expected boolean";
      case y.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${$.exclusiveMinimumTimestamp}`;
      case y.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${$.exclusiveMaximumTimestamp}`;
      case y.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${$.minimumTimestamp}`;
      case y.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${$.maximumTimestamp}`;
      case y.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${$.multipleOfTimestamp}`;
      case y.ValueErrorType.Date:
        return "Expected Date";
      case y.ValueErrorType.Function:
        return "Expected function";
      case y.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.Integer:
        return "Expected integer";
      case y.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case y.ValueErrorType.Intersect:
        return "Expected all values to match";
      case y.ValueErrorType.Iterator:
        return "Expected Iterator";
      case y.ValueErrorType.Literal:
        return `Expected ${typeof $.const === "string" ? `'${$.const}'` : $.const}`;
      case y.ValueErrorType.Never:
        return "Never";
      case y.ValueErrorType.Not:
        return "Value should not match";
      case y.ValueErrorType.Null:
        return "Expected null";
      case y.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.Number:
        return "Expected number";
      case y.ValueErrorType.Object:
        return "Expected object";
      case y.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case y.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${$.maxProperties} properties`;
      case y.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${$.minProperties} properties`;
      case y.ValueErrorType.ObjectRequiredProperty:
        return "Required property";
      case y.ValueErrorType.Promise:
        return "Expected Promise";
      case y.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${$.format}'`;
      case y.ValueErrorType.StringFormat:
        return `Expected string to match '${$.format}' format`;
      case y.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${$.maxLength}`;
      case y.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${$.minLength}`;
      case y.ValueErrorType.StringPattern:
        return `Expected string to match '${$.pattern}'`;
      case y.ValueErrorType.String:
        return "Expected string";
      case y.ValueErrorType.Symbol:
        return "Expected symbol";
      case y.ValueErrorType.TupleLength:
        return `Expected tuple to have ${$.maxItems || 0} elements`;
      case y.ValueErrorType.Tuple:
        return "Expected tuple";
      case y.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${$.maxByteLength}`;
      case y.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${$.minByteLength}`;
      case y.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case y.ValueErrorType.Undefined:
        return "Expected undefined";
      case y.ValueErrorType.Union:
        return "Expected union value";
      case y.ValueErrorType.Void:
        return "Expected void";
      case y.ValueErrorType.Kind:
        return `Expected kind '${$[Q1.Kind]}'`;
      default:
        return "Unknown error type";
    }
  };
  Object.defineProperty(o6, "__esModule", { value: true });
  o6.DefaultErrorFunction = o6.TypeSystemPolicy = o6.TypeSystemErrorFunction = o6.TypeSystem = o6.TypeSystemDuplicateFormat = o6.TypeSystemDuplicateTypeKind = undefined;
  var C$ = V0(), y = Y$(), Q1 = f0();

  class K8 extends Q1.TypeBoxError {
    constructor($) {
      super(`Duplicate type kind '${$}' detected`);
    }
  }
  o6.TypeSystemDuplicateTypeKind = K8;

  class j8 extends Q1.TypeBoxError {
    constructor($) {
      super(`Duplicate string format '${$}' detected`);
    }
  }
  o6.TypeSystemDuplicateFormat = j8;
  var u6;
  (function($) {
    function Y(X, Z) {
      if (Q1.TypeRegistry.Has(X))
        throw new K8(X);
      return Q1.TypeRegistry.Set(X, Z), (Q = {}) => Q1.Type.Unsafe({ ...Q, [Q1.Kind]: X });
    }
    $.Type = Y;
    function W(X, Z) {
      if (Q1.FormatRegistry.Has(X))
        throw new j8(X);
      return Q1.FormatRegistry.Set(X, Z), X;
    }
    $.Format = W;
  })(u6 || (o6.TypeSystem = u6 = {}));
  var n6;
  (function($) {
    let Y = w8;
    function W() {
      Y = w8;
    }
    $.Reset = W;
    function X(Q) {
      Y = Q;
    }
    $.Set = X;
    function Z() {
      return Y;
    }
    $.Get = Z;
  })(n6 || (o6.TypeSystemErrorFunction = n6 = {}));
  var h6;
  (function($) {
    $.ExactOptionalPropertyTypes = false, $.AllowArrayObject = false, $.AllowNaN = false, $.AllowNullVoid = false;
    function Y(J, q) {
      return $.ExactOptionalPropertyTypes ? q in J : J[q] !== undefined;
    }
    $.IsExactOptionalProperty = Y;
    function W(J) {
      const q = (0, C$.IsObject)(J);
      return $.AllowArrayObject ? q : q && !(0, C$.IsArray)(J);
    }
    $.IsObjectLike = W;
    function X(J) {
      return W(J) && !(J instanceof Date) && !(J instanceof Uint8Array);
    }
    $.IsRecordLike = X;
    function Z(J) {
      const q = (0, C$.IsNumber)(J);
      return $.AllowNaN ? q : q && Number.isFinite(J);
    }
    $.IsNumberLike = Z;
    function Q(J) {
      const q = (0, C$.IsUndefined)(J);
      return $.AllowNullVoid ? q || J === null : q;
    }
    $.IsVoidLike = Q;
  })(h6 || (o6.TypeSystemPolicy = h6 = {}));
  o6.DefaultErrorFunction = w8;
});
var D1 = J0((l6) => {
  var IZ = function($, Y) {
    const W = Y.findIndex((X) => X.$id === $.$ref);
    if (W === -1)
      throw new O8($);
    return Y[W];
  };
  Object.defineProperty(l6, "__esModule", { value: true });
  l6.Deref = l6.TypeDereferenceError = undefined;
  var CZ = f0();

  class O8 extends CZ.TypeBoxError {
    constructor($) {
      super(`Unable to dereference schema with $id '${$.$id}'`);
      this.schema = $;
    }
  }
  l6.TypeDereferenceError = O8;
  l6.Deref = IZ;
});
var W$ = J0((e6) => {
  function* EZ($) {
    const Y = $ === 0 ? 1 : Math.ceil(Math.floor(Math.log2($) + 1) / 8);
    for (let W = 0;W < Y; W++)
      yield $ >> 8 * (Y - 1 - W) & 255;
  }
  var VZ = function($) {
    R0(T0.Array);
    for (let Y of $)
      v1(Y);
  }, xZ = function($) {
    R0(T0.Boolean), R0($ ? 1 : 0);
  }, kZ = function($) {
    R0(T0.BigInt), r6.setBigInt64(0, $);
    for (let Y of a6)
      R0(Y);
  }, gZ = function($) {
    R0(T0.Date), v1($.getTime());
  }, fZ = function($) {
    R0(T0.Null);
  }, TZ = function($) {
    R0(T0.Number), r6.setFloat64(0, $);
    for (let Y of a6)
      R0(Y);
  }, dZ = function($) {
    R0(T0.Object);
    for (let Y of globalThis.Object.keys($).sort())
      v1(Y), v1($[Y]);
  }, yZ = function($) {
    R0(T0.String);
    for (let Y = 0;Y < $.length; Y++)
      for (let W of EZ($.charCodeAt(Y)))
        R0(W);
  }, vZ = function($) {
    R0(T0.Symbol), v1($.description);
  }, pZ = function($) {
    R0(T0.Uint8Array);
    for (let Y = 0;Y < $.length; Y++)
      R0($[Y]);
  }, iZ = function($) {
    return R0(T0.Undefined);
  }, v1 = function($) {
    if ((0, o0.IsArray)($))
      return VZ($);
    if ((0, o0.IsBoolean)($))
      return xZ($);
    if ((0, o0.IsBigInt)($))
      return kZ($);
    if ((0, o0.IsDate)($))
      return gZ($);
    if ((0, o0.IsNull)($))
      return fZ($);
    if ((0, o0.IsNumber)($))
      return TZ($);
    if ((0, o0.IsPlainObject)($))
      return dZ($);
    if ((0, o0.IsString)($))
      return yZ($);
    if ((0, o0.IsSymbol)($))
      return vZ($);
    if ((0, o0.IsUint8Array)($))
      return pZ($);
    if ((0, o0.IsUndefined)($))
      return iZ($);
    throw new S8($);
  }, R0 = function($) {
    y1 = y1 ^ _Z[$], y1 = y1 * RZ % GZ;
  }, mZ = function($) {
    return y1 = BigInt("14695981039346656037"), v1($), y1;
  };
  Object.defineProperty(e6, "__esModule", { value: true });
  e6.Hash = e6.ByteMarker = e6.ValueHashError = undefined;
  var o0 = V0();

  class S8 extends Error {
    constructor($) {
      super("Unable to hash value");
      this.value = $;
    }
  }
  e6.ValueHashError = S8;
  var T0;
  (function($) {
    $[$.Undefined = 0] = "Undefined", $[$.Null = 1] = "Null", $[$.Boolean = 2] = "Boolean", $[$.Number = 3] = "Number", $[$.String = 4] = "String", $[$.Object = 5] = "Object", $[$.Array = 6] = "Array", $[$.Date = 7] = "Date", $[$.Uint8Array = 8] = "Uint8Array", $[$.Symbol = 9] = "Symbol", $[$.BigInt = 10] = "BigInt";
  })(T0 || (e6.ByteMarker = T0 = {}));
  var y1 = BigInt("14695981039346656037"), [RZ, GZ] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")], _Z = Array.from({ length: 256 }).map(($, Y) => BigInt(Y)), s6 = new Float64Array(1), r6 = new DataView(s6.buffer), a6 = new Uint8Array(s6.buffer);
  e6.Hash = mZ;
});
var Y$ = J0((WY) => {
  var s = function($) {
    return $ !== undefined;
  }, g = function($, Y, W, X) {
    return { type: $, schema: Y, path: W, value: X, message: p1.TypeSystemErrorFunction.Get()(Y, $) };
  };
  function* oZ($, Y, W, X) {
  }
  function* cZ($, Y, W, X) {
    if (!(0, B0.IsArray)(X))
      return yield g(k.Array, $, W, X);
    if (s($.minItems) && !(X.length >= $.minItems))
      yield g(k.ArrayMinItems, $, W, X);
    if (s($.maxItems) && !(X.length <= $.maxItems))
      yield g(k.ArrayMaxItems, $, W, X);
    for (let J = 0;J < X.length; J++)
      yield* L0($.items, Y, `${W}/${J}`, X[J]);
    if ($.uniqueItems === true && !function() {
      const J = new Set;
      for (let q of X) {
        const F = (0, hZ.Hash)(q);
        if (J.has(F))
          return false;
        else
          J.add(F);
      }
      return true;
    }())
      yield g(k.ArrayUniqueItems, $, W, X);
    if (!(s($.contains) || s($.minContains) || s($.maxContains)))
      return;
    const Z = s($.contains) ? $.contains : i0.Type.Never(), Q = X.reduce((J, q, F) => L0(Z, Y, `${W}${F}`, q).next().done === true ? J + 1 : J, 0);
    if (Q === 0)
      yield g(k.ArrayContains, $, W, X);
    if ((0, B0.IsNumber)($.minContains) && Q < $.minContains)
      yield g(k.ArrayMinContains, $, W, X);
    if ((0, B0.IsNumber)($.maxContains) && Q > $.maxContains)
      yield g(k.ArrayMaxContains, $, W, X);
  }
  function* lZ($, Y, W, X) {
    if (!(0, B0.IsAsyncIterator)(X))
      yield g(k.AsyncIterator, $, W, X);
  }
  function* tZ($, Y, W, X) {
    if (!(0, B0.IsBigInt)(X))
      return yield g(k.BigInt, $, W, X);
    if (s($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(k.BigIntExclusiveMaximum, $, W, X);
    if (s($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(k.BigIntExclusiveMinimum, $, W, X);
    if (s($.maximum) && !(X <= $.maximum))
      yield g(k.BigIntMaximum, $, W, X);
    if (s($.minimum) && !(X >= $.minimum))
      yield g(k.BigIntMinimum, $, W, X);
    if (s($.multipleOf) && X % $.multipleOf !== BigInt(0))
      yield g(k.BigIntMultipleOf, $, W, X);
  }
  function* sZ($, Y, W, X) {
    if (!(0, B0.IsBoolean)(X))
      yield g(k.Boolean, $, W, X);
  }
  function* rZ($, Y, W, X) {
    yield* L0($.returns, Y, W, X.prototype);
  }
  function* aZ($, Y, W, X) {
    if (!(0, B0.IsDate)(X))
      return yield g(k.Date, $, W, X);
    if (s($.exclusiveMaximumTimestamp) && !(X.getTime() < $.exclusiveMaximumTimestamp))
      yield g(k.DateExclusiveMaximumTimestamp, $, W, X);
    if (s($.exclusiveMinimumTimestamp) && !(X.getTime() > $.exclusiveMinimumTimestamp))
      yield g(k.DateExclusiveMinimumTimestamp, $, W, X);
    if (s($.maximumTimestamp) && !(X.getTime() <= $.maximumTimestamp))
      yield g(k.DateMaximumTimestamp, $, W, X);
    if (s($.minimumTimestamp) && !(X.getTime() >= $.minimumTimestamp))
      yield g(k.DateMinimumTimestamp, $, W, X);
    if (s($.multipleOfTimestamp) && X.getTime() % $.multipleOfTimestamp !== 0)
      yield g(k.DateMultipleOfTimestamp, $, W, X);
  }
  function* eZ($, Y, W, X) {
    if (!(0, B0.IsFunction)(X))
      yield g(k.Function, $, W, X);
  }
  function* $Q($, Y, W, X) {
    if (!(0, B0.IsInteger)(X))
      return yield g(k.Integer, $, W, X);
    if (s($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(k.IntegerExclusiveMaximum, $, W, X);
    if (s($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(k.IntegerExclusiveMinimum, $, W, X);
    if (s($.maximum) && !(X <= $.maximum))
      yield g(k.IntegerMaximum, $, W, X);
    if (s($.minimum) && !(X >= $.minimum))
      yield g(k.IntegerMinimum, $, W, X);
    if (s($.multipleOf) && X % $.multipleOf !== 0)
      yield g(k.IntegerMultipleOf, $, W, X);
  }
  function* YQ($, Y, W, X) {
    for (let Z of $.allOf) {
      const Q = L0(Z, Y, W, X).next();
      if (!Q.done)
        yield g(k.Intersect, $, W, X), yield Q.value;
    }
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(i0.KeyResolver.ResolvePattern($));
      for (let Q of Object.getOwnPropertyNames(X))
        if (!Z.test(Q))
          yield g(k.IntersectUnevaluatedProperties, $, `${W}/${Q}`, X);
    }
    if (typeof $.unevaluatedProperties === "object") {
      const Z = new RegExp(i0.KeyResolver.ResolvePattern($));
      for (let Q of Object.getOwnPropertyNames(X))
        if (!Z.test(Q)) {
          const J = L0($.unevaluatedProperties, Y, `${W}/${Q}`, X[Q]).next();
          if (!J.done)
            yield J.value;
        }
    }
  }
  function* WQ($, Y, W, X) {
    if (!(0, B0.IsIterator)(X))
      yield g(k.Iterator, $, W, X);
  }
  function* XQ($, Y, W, X) {
    if (X !== $.const)
      yield g(k.Literal, $, W, X);
  }
  function* ZQ($, Y, W, X) {
    yield g(k.Never, $, W, X);
  }
  function* QQ($, Y, W, X) {
    if (L0($.not, Y, W, X).next().done === true)
      yield g(k.Not, $, W, X);
  }
  function* JQ($, Y, W, X) {
    if (!(0, B0.IsNull)(X))
      yield g(k.Null, $, W, X);
  }
  function* zQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsNumberLike(X))
      return yield g(k.Number, $, W, X);
    if (s($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(k.NumberExclusiveMaximum, $, W, X);
    if (s($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(k.NumberExclusiveMinimum, $, W, X);
    if (s($.maximum) && !(X <= $.maximum))
      yield g(k.NumberMaximum, $, W, X);
    if (s($.minimum) && !(X >= $.minimum))
      yield g(k.NumberMinimum, $, W, X);
    if (s($.multipleOf) && X % $.multipleOf !== 0)
      yield g(k.NumberMultipleOf, $, W, X);
  }
  function* HQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsObjectLike(X))
      return yield g(k.Object, $, W, X);
    if (s($.minProperties) && !(Object.getOwnPropertyNames(X).length >= $.minProperties))
      yield g(k.ObjectMinProperties, $, W, X);
    if (s($.maxProperties) && !(Object.getOwnPropertyNames(X).length <= $.maxProperties))
      yield g(k.ObjectMaxProperties, $, W, X);
    const Z = Array.isArray($.required) ? $.required : [], Q = Object.getOwnPropertyNames($.properties), J = Object.getOwnPropertyNames(X);
    for (let q of Z) {
      if (J.includes(q))
        continue;
      yield g(k.ObjectRequiredProperty, $.properties[q], `${W}/${q}`, undefined);
    }
    if ($.additionalProperties === false) {
      for (let q of J)
        if (!Q.includes(q))
          yield g(k.ObjectAdditionalProperties, $, `${W}/${q}`, X[q]);
    }
    if (typeof $.additionalProperties === "object")
      for (let q of J) {
        if (Q.includes(q))
          continue;
        yield* L0($.additionalProperties, Y, `${W}/${q}`, X[q]);
      }
    for (let q of Q) {
      const F = $.properties[q];
      if ($.required && $.required.includes(q)) {
        if (yield* L0(F, Y, `${W}/${q}`, X[q]), i0.ExtendsUndefined.Check($) && !(q in X))
          yield g(k.ObjectRequiredProperty, F, `${W}/${q}`, undefined);
      } else if (p1.TypeSystemPolicy.IsExactOptionalProperty(X, q))
        yield* L0(F, Y, `${W}/${q}`, X[q]);
    }
  }
  function* qQ($, Y, W, X) {
    if (!(0, B0.IsPromise)(X))
      yield g(k.Promise, $, W, X);
  }
  function* NQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsRecordLike(X))
      return yield g(k.Object, $, W, X);
    if (s($.minProperties) && !(Object.getOwnPropertyNames(X).length >= $.minProperties))
      yield g(k.ObjectMinProperties, $, W, X);
    if (s($.maxProperties) && !(Object.getOwnPropertyNames(X).length <= $.maxProperties))
      yield g(k.ObjectMaxProperties, $, W, X);
    const [Z, Q] = Object.entries($.patternProperties)[0], J = new RegExp(Z);
    for (let [q, F] of Object.entries(X))
      if (J.test(q))
        yield* L0(Q, Y, `${W}/${q}`, F);
    if (typeof $.additionalProperties === "object") {
      for (let [q, F] of Object.entries(X))
        if (!J.test(q))
          yield* L0($.additionalProperties, Y, `${W}/${q}`, F);
    }
    if ($.additionalProperties === false)
      for (let [q, F] of Object.entries(X)) {
        if (J.test(q))
          continue;
        return yield g(k.ObjectAdditionalProperties, $, `${W}/${q}`, F);
      }
  }
  function* MQ($, Y, W, X) {
    yield* L0((0, YY.Deref)($, Y), Y, W, X);
  }
  function* UQ($, Y, W, X) {
    if (!(0, B0.IsString)(X))
      return yield g(k.String, $, W, X);
    if (s($.minLength) && !(X.length >= $.minLength))
      yield g(k.StringMinLength, $, W, X);
    if (s($.maxLength) && !(X.length <= $.maxLength))
      yield g(k.StringMaxLength, $, W, X);
    if ((0, B0.IsString)($.pattern)) {
      if (!new RegExp($.pattern).test(X))
        yield g(k.StringPattern, $, W, X);
    }
    if ((0, B0.IsString)($.format)) {
      if (!i0.FormatRegistry.Has($.format))
        yield g(k.StringFormatUnknown, $, W, X);
      else if (!i0.FormatRegistry.Get($.format)(X))
        yield g(k.StringFormat, $, W, X);
    }
  }
  function* FQ($, Y, W, X) {
    if (!(0, B0.IsSymbol)(X))
      yield g(k.Symbol, $, W, X);
  }
  function* BQ($, Y, W, X) {
    if (!(0, B0.IsString)(X))
      return yield g(k.String, $, W, X);
    if (!new RegExp($.pattern).test(X))
      yield g(k.StringPattern, $, W, X);
  }
  function* AQ($, Y, W, X) {
    yield* L0((0, YY.Deref)($, Y), Y, W, X);
  }
  function* DQ($, Y, W, X) {
    if (!(0, B0.IsArray)(X))
      return yield g(k.Tuple, $, W, X);
    if ($.items === undefined && X.length !== 0)
      return yield g(k.TupleLength, $, W, X);
    if (X.length !== $.maxItems)
      return yield g(k.TupleLength, $, W, X);
    if (!$.items)
      return;
    for (let Z = 0;Z < $.items.length; Z++)
      yield* L0($.items[Z], Y, `${W}/${Z}`, X[Z]);
  }
  function* wQ($, Y, W, X) {
    if (!(0, B0.IsUndefined)(X))
      yield g(k.Undefined, $, W, X);
  }
  function* KQ($, Y, W, X) {
    let Z = 0;
    for (let Q of $.anyOf) {
      const J = [...L0(Q, Y, W, X)];
      if (J.length === 0)
        return;
      Z += J.length;
    }
    if (Z > 0)
      yield g(k.Union, $, W, X);
  }
  function* jQ($, Y, W, X) {
    if (!(0, B0.IsUint8Array)(X))
      return yield g(k.Uint8Array, $, W, X);
    if (s($.maxByteLength) && !(X.length <= $.maxByteLength))
      yield g(k.Uint8ArrayMaxByteLength, $, W, X);
    if (s($.minByteLength) && !(X.length >= $.minByteLength))
      yield g(k.Uint8ArrayMinByteLength, $, W, X);
  }
  function* PQ($, Y, W, X) {
  }
  function* OQ($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsVoidLike(X))
      yield g(k.Void, $, W, X);
  }
  function* SQ($, Y, W, X) {
    if (!i0.TypeRegistry.Get($[i0.Kind])($, X))
      yield g(k.Kind, $, W, X);
  }
  function* L0($, Y, W, X) {
    const Z = s($.$id) ? [...Y, $] : Y, Q = $;
    switch (Q[i0.Kind]) {
      case "Any":
        return yield* oZ(Q, Z, W, X);
      case "Array":
        return yield* cZ(Q, Z, W, X);
      case "AsyncIterator":
        return yield* lZ(Q, Z, W, X);
      case "BigInt":
        return yield* tZ(Q, Z, W, X);
      case "Boolean":
        return yield* sZ(Q, Z, W, X);
      case "Constructor":
        return yield* rZ(Q, Z, W, X);
      case "Date":
        return yield* aZ(Q, Z, W, X);
      case "Function":
        return yield* eZ(Q, Z, W, X);
      case "Integer":
        return yield* $Q(Q, Z, W, X);
      case "Intersect":
        return yield* YQ(Q, Z, W, X);
      case "Iterator":
        return yield* WQ(Q, Z, W, X);
      case "Literal":
        return yield* XQ(Q, Z, W, X);
      case "Never":
        return yield* ZQ(Q, Z, W, X);
      case "Not":
        return yield* QQ(Q, Z, W, X);
      case "Null":
        return yield* JQ(Q, Z, W, X);
      case "Number":
        return yield* zQ(Q, Z, W, X);
      case "Object":
        return yield* HQ(Q, Z, W, X);
      case "Promise":
        return yield* qQ(Q, Z, W, X);
      case "Record":
        return yield* NQ(Q, Z, W, X);
      case "Ref":
        return yield* MQ(Q, Z, W, X);
      case "String":
        return yield* UQ(Q, Z, W, X);
      case "Symbol":
        return yield* FQ(Q, Z, W, X);
      case "TemplateLiteral":
        return yield* BQ(Q, Z, W, X);
      case "This":
        return yield* AQ(Q, Z, W, X);
      case "Tuple":
        return yield* DQ(Q, Z, W, X);
      case "Undefined":
        return yield* wQ(Q, Z, W, X);
      case "Union":
        return yield* KQ(Q, Z, W, X);
      case "Uint8Array":
        return yield* jQ(Q, Z, W, X);
      case "Unknown":
        return yield* PQ(Q, Z, W, X);
      case "Void":
        return yield* OQ(Q, Z, W, X);
      default:
        if (!i0.TypeRegistry.Has(Q[i0.Kind]))
          throw new L8($);
        return yield* SQ(Q, Z, W, X);
    }
  }
  var LQ = function(...$) {
    const Y = $.length === 3 ? L0($[0], $[1], "", $[2]) : L0($[0], [], "", $[1]);
    return new C8(Y);
  };
  Object.defineProperty(WY, "__esModule", { value: true });
  WY.Errors = WY.ValueErrorIterator = WY.ValueErrorsUnknownTypeError = WY.ValueErrorType = undefined;
  var B0 = V0(), p1 = P8(), YY = D1(), hZ = W$(), i0 = f0(), k;
  (function($) {
    $[$.ArrayContains = 0] = "ArrayContains", $[$.ArrayMaxContains = 1] = "ArrayMaxContains", $[$.ArrayMaxItems = 2] = "ArrayMaxItems", $[$.ArrayMinContains = 3] = "ArrayMinContains", $[$.ArrayMinItems = 4] = "ArrayMinItems", $[$.ArrayUniqueItems = 5] = "ArrayUniqueItems", $[$.Array = 6] = "Array", $[$.AsyncIterator = 7] = "AsyncIterator", $[$.BigIntExclusiveMaximum = 8] = "BigIntExclusiveMaximum", $[$.BigIntExclusiveMinimum = 9] = "BigIntExclusiveMinimum", $[$.BigIntMaximum = 10] = "BigIntMaximum", $[$.BigIntMinimum = 11] = "BigIntMinimum", $[$.BigIntMultipleOf = 12] = "BigIntMultipleOf", $[$.BigInt = 13] = "BigInt", $[$.Boolean = 14] = "Boolean", $[$.DateExclusiveMaximumTimestamp = 15] = "DateExclusiveMaximumTimestamp", $[$.DateExclusiveMinimumTimestamp = 16] = "DateExclusiveMinimumTimestamp", $[$.DateMaximumTimestamp = 17] = "DateMaximumTimestamp", $[$.DateMinimumTimestamp = 18] = "DateMinimumTimestamp", $[$.DateMultipleOfTimestamp = 19] = "DateMultipleOfTimestamp", $[$.Date = 20] = "Date", $[$.Function = 21] = "Function", $[$.IntegerExclusiveMaximum = 22] = "IntegerExclusiveMaximum", $[$.IntegerExclusiveMinimum = 23] = "IntegerExclusiveMinimum", $[$.IntegerMaximum = 24] = "IntegerMaximum", $[$.IntegerMinimum = 25] = "IntegerMinimum", $[$.IntegerMultipleOf = 26] = "IntegerMultipleOf", $[$.Integer = 27] = "Integer", $[$.IntersectUnevaluatedProperties = 28] = "IntersectUnevaluatedProperties", $[$.Intersect = 29] = "Intersect", $[$.Iterator = 30] = "Iterator", $[$.Kind = 31] = "Kind", $[$.Literal = 32] = "Literal", $[$.Never = 33] = "Never", $[$.Not = 34] = "Not", $[$.Null = 35] = "Null", $[$.NumberExclusiveMaximum = 36] = "NumberExclusiveMaximum", $[$.NumberExclusiveMinimum = 37] = "NumberExclusiveMinimum", $[$.NumberMaximum = 38] = "NumberMaximum", $[$.NumberMinimum = 39] = "NumberMinimum", $[$.NumberMultipleOf = 40] = "NumberMultipleOf", $[$.Number = 41] = "Number", $[$.ObjectAdditionalProperties = 42] = "ObjectAdditionalProperties", $[$.ObjectMaxProperties = 43] = "ObjectMaxProperties", $[$.ObjectMinProperties = 44] = "ObjectMinProperties", $[$.ObjectRequiredProperty = 45] = "ObjectRequiredProperty", $[$.Object = 46] = "Object", $[$.Promise = 47] = "Promise", $[$.StringFormatUnknown = 48] = "StringFormatUnknown", $[$.StringFormat = 49] = "StringFormat", $[$.StringMaxLength = 50] = "StringMaxLength", $[$.StringMinLength = 51] = "StringMinLength", $[$.StringPattern = 52] = "StringPattern", $[$.String = 53] = "String", $[$.Symbol = 54] = "Symbol", $[$.TupleLength = 55] = "TupleLength", $[$.Tuple = 56] = "Tuple", $[$.Uint8ArrayMaxByteLength = 57] = "Uint8ArrayMaxByteLength", $[$.Uint8ArrayMinByteLength = 58] = "Uint8ArrayMinByteLength", $[$.Uint8Array = 59] = "Uint8Array", $[$.Undefined = 60] = "Undefined", $[$.Union = 61] = "Union", $[$.Void = 62] = "Void";
  })(k || (WY.ValueErrorType = k = {}));

  class L8 extends i0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  WY.ValueErrorsUnknownTypeError = L8;

  class C8 {
    constructor($) {
      this.iterator = $;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    First() {
      const $ = this.iterator.next();
      return $.done ? undefined : $.value;
    }
  }
  WY.ValueErrorIterator = C8;
  WY.Errors = LQ;
});
var I$ = J0((O1) => {
  var RQ = O1 && O1.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), GQ = O1 && O1.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        RQ(Y, $, W);
  };
  Object.defineProperty(O1, "__esModule", { value: true });
  GQ(Y$(), O1);
});
var b$ = J0((QY) => {
  Object.defineProperty(QY, "__esModule", { value: true });
  QY.ValuePointer = QY.ValuePointerRootDeleteError = QY.ValuePointerRootSetError = undefined;

  class I8 extends Error {
    constructor($, Y, W) {
      super("Cannot set root value");
      this.value = $, this.path = Y, this.update = W;
    }
  }
  QY.ValuePointerRootSetError = I8;

  class b8 extends Error {
    constructor($, Y) {
      super("Cannot delete root value");
      this.value = $, this.path = Y;
    }
  }
  QY.ValuePointerRootDeleteError = b8;
  var ZY;
  (function($) {
    function Y(q) {
      return q.indexOf("~") === -1 ? q : q.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    function* W(q) {
      if (q === "")
        return;
      let [F, D] = [0, 0];
      for (let K = 0;K < q.length; K++)
        if (q.charAt(K) === "/")
          if (K === 0)
            F = K + 1;
          else
            D = K, yield Y(q.slice(F, D)), F = K + 1;
        else
          D = K;
      yield Y(q.slice(F));
    }
    $.Format = W;
    function X(q, F, D) {
      if (F === "")
        throw new I8(q, F, D);
      let [K, A, I] = [null, q, ""];
      for (let j of W(F)) {
        if (A[j] === undefined)
          A[j] = {};
        K = A, A = A[j], I = j;
      }
      K[I] = D;
    }
    $.Set = X;
    function Z(q, F) {
      if (F === "")
        throw new b8(q, F);
      let [D, K, A] = [null, q, ""];
      for (let I of W(F)) {
        if (K[I] === undefined || K[I] === null)
          return;
        D = K, K = K[I], A = I;
      }
      if (Array.isArray(D)) {
        const I = parseInt(A);
        D.splice(I, 1);
      } else
        delete D[A];
    }
    $.Delete = Z;
    function Q(q, F) {
      if (F === "")
        return true;
      let [D, K, A] = [null, q, ""];
      for (let I of W(F)) {
        if (K[I] === undefined)
          return false;
        D = K, K = K[I], A = I;
      }
      return Object.getOwnPropertyNames(D).includes(A);
    }
    $.Has = Q;
    function J(q, F) {
      if (F === "")
        return q;
      let D = q;
      for (let K of W(F)) {
        if (D[K] === undefined)
          return;
        D = D[K];
      }
      return D;
    }
    $.Get = J;
  })(ZY || (QY.ValuePointer = ZY = {}));
});
var i1 = J0((zY) => {
  var VQ = function($) {
    return [...Object.getOwnPropertyNames($), ...Object.getOwnPropertySymbols($)].reduce((W, X) => ({ ...W, [X]: R8($[X]) }), {});
  }, xQ = function($) {
    return $.map((Y) => R8(Y));
  }, kQ = function($) {
    return $.slice();
  }, gQ = function($) {
    return new Date($.toISOString());
  }, fQ = function($) {
    return $;
  }, R8 = function($) {
    if ((0, X$.IsArray)($))
      return xQ($);
    if ((0, X$.IsDate)($))
      return gQ($);
    if ((0, X$.IsPlainObject)($))
      return VQ($);
    if ((0, X$.IsTypedArray)($))
      return kQ($);
    if ((0, X$.IsValueType)($))
      return fQ($);
    throw new Error("ValueClone: Unable to clone value");
  };
  Object.defineProperty(zY, "__esModule", { value: true });
  zY.Clone = undefined;
  var X$ = V0();
  zY.Clone = R8;
});
var V8 = J0((MY) => {
  var Z$ = function($, Y) {
    return { type: "update", path: $, value: Y };
  }, qY = function($, Y) {
    return { type: "insert", path: $, value: Y };
  }, NY = function($) {
    return { type: "delete", path: $ };
  };
  function* TQ($, Y, W) {
    if (!(0, G0.IsPlainObject)(W))
      return yield Z$($, W);
    const X = [...Object.keys(Y), ...Object.getOwnPropertySymbols(Y)], Z = [...Object.keys(W), ...Object.getOwnPropertySymbols(W)];
    for (let Q of X) {
      if ((0, G0.IsSymbol)(Q))
        throw new m1(Q);
      if ((0, G0.IsUndefined)(W[Q]) && Z.includes(Q))
        yield Z$(`${$}/${String(Q)}`, undefined);
    }
    for (let Q of Z) {
      if ((0, G0.IsUndefined)(Y[Q]) || (0, G0.IsUndefined)(W[Q]))
        continue;
      if ((0, G0.IsSymbol)(Q))
        throw new m1(Q);
      yield* R$(`${$}/${String(Q)}`, Y[Q], W[Q]);
    }
    for (let Q of Z) {
      if ((0, G0.IsSymbol)(Q))
        throw new m1(Q);
      if ((0, G0.IsUndefined)(Y[Q]))
        yield qY(`${$}/${String(Q)}`, W[Q]);
    }
    for (let Q of X.reverse()) {
      if ((0, G0.IsSymbol)(Q))
        throw new m1(Q);
      if ((0, G0.IsUndefined)(W[Q]) && !Z.includes(Q))
        yield NY(`${$}/${String(Q)}`);
    }
  }
  function* dQ($, Y, W) {
    if (!(0, G0.IsArray)(W))
      return yield Z$($, W);
    for (let X = 0;X < Math.min(Y.length, W.length); X++)
      yield* R$(`${$}/${X}`, Y[X], W[X]);
    for (let X = 0;X < W.length; X++) {
      if (X < Y.length)
        continue;
      yield qY(`${$}/${X}`, W[X]);
    }
    for (let X = Y.length - 1;X >= 0; X--) {
      if (X < W.length)
        continue;
      yield NY(`${$}/${X}`);
    }
  }
  function* yQ($, Y, W) {
    if (!(0, G0.IsTypedArray)(W) || Y.length !== W.length || Object.getPrototypeOf(Y).constructor.name !== Object.getPrototypeOf(W).constructor.name)
      return yield Z$($, W);
    for (let X = 0;X < Math.min(Y.length, W.length); X++)
      yield* R$(`${$}/${X}`, Y[X], W[X]);
  }
  function* vQ($, Y, W) {
    if (Y === W)
      return;
    yield Z$($, W);
  }
  function* R$($, Y, W) {
    if ((0, G0.IsPlainObject)(Y))
      return yield* TQ($, Y, W);
    if ((0, G0.IsArray)(Y))
      return yield* dQ($, Y, W);
    if ((0, G0.IsTypedArray)(Y))
      return yield* yQ($, Y, W);
    if ((0, G0.IsValueType)(Y))
      return yield* vQ($, Y, W);
    throw new E8(Y);
  }
  var pQ = function($, Y) {
    return [...R$("", $, Y)];
  }, iQ = function($) {
    return $.length > 0 && $[0].path === "" && $[0].type === "update";
  }, mQ = function($) {
    return $.length === 0;
  }, uQ = function($, Y) {
    if (iQ(Y))
      return (0, _8.Clone)(Y[0].value);
    if (mQ(Y))
      return (0, _8.Clone)($);
    const W = (0, _8.Clone)($);
    for (let X of Y)
      switch (X.type) {
        case "insert": {
          G8.ValuePointer.Set(W, X.path, X.value);
          break;
        }
        case "update": {
          G8.ValuePointer.Set(W, X.path, X.value);
          break;
        }
        case "delete": {
          G8.ValuePointer.Delete(W, X.path);
          break;
        }
      }
    return W;
  };
  Object.defineProperty(MY, "__esModule", { value: true });
  MY.Patch = MY.Diff = MY.ValueDeltaUnableToDiffUnknownValue = MY.ValueDeltaObjectWithSymbolKeyError = MY.Edit = MY.Delete = MY.Update = MY.Insert = undefined;
  var G0 = V0(), m0 = f0(), G8 = b$(), _8 = i1();
  MY.Insert = m0.Type.Object({ type: m0.Type.Literal("insert"), path: m0.Type.String(), value: m0.Type.Unknown() });
  MY.Update = m0.Type.Object({ type: m0.Type.Literal("update"), path: m0.Type.String(), value: m0.Type.Unknown() });
  MY.Delete = m0.Type.Object({ type: m0.Type.Literal("delete"), path: m0.Type.String() });
  MY.Edit = m0.Type.Union([MY.Insert, MY.Update, MY.Delete]);

  class m1 extends Error {
    constructor($) {
      super("Cannot diff objects with symbol keys");
      this.key = $;
    }
  }
  MY.ValueDeltaObjectWithSymbolKeyError = m1;

  class E8 extends Error {
    constructor($) {
      super("Unable to create diff edits for unknown value");
      this.value = $;
    }
  }
  MY.ValueDeltaUnableToDiffUnknownValue = E8;
  MY.Diff = pQ;
  MY.Patch = uQ;
});
var jY = J0((wY) => {
  var lQ = function($, Y, W, X) {
    if (!(0, d0.IsPlainObject)(W))
      G$.ValuePointer.Set($, Y, (0, x8.Clone)(X));
    else {
      const Z = Object.keys(W), Q = Object.keys(X);
      for (let J of Z)
        if (!Q.includes(J))
          delete W[J];
      for (let J of Q)
        if (!Z.includes(J))
          W[J] = null;
      for (let J of Q)
        f8($, `${Y}/${J}`, W[J], X[J]);
    }
  }, tQ = function($, Y, W, X) {
    if (!(0, d0.IsArray)(W))
      G$.ValuePointer.Set($, Y, (0, x8.Clone)(X));
    else {
      for (let Z = 0;Z < X.length; Z++)
        f8($, `${Y}/${Z}`, W[Z], X[Z]);
      W.splice(X.length);
    }
  }, sQ = function($, Y, W, X) {
    if ((0, d0.IsTypedArray)(W) && W.length === X.length)
      for (let Z = 0;Z < W.length; Z++)
        W[Z] = X[Z];
    else
      G$.ValuePointer.Set($, Y, (0, x8.Clone)(X));
  }, rQ = function($, Y, W, X) {
    if (W === X)
      return;
    G$.ValuePointer.Set($, Y, X);
  }, f8 = function($, Y, W, X) {
    if ((0, d0.IsArray)(X))
      return tQ($, Y, W, X);
    if ((0, d0.IsTypedArray)(X))
      return sQ($, Y, W, X);
    if ((0, d0.IsPlainObject)(X))
      return lQ($, Y, W, X);
    if ((0, d0.IsValueType)(X))
      return rQ($, Y, W, X);
  }, DY = function($) {
    return (0, d0.IsTypedArray)($) || (0, d0.IsValueType)($);
  }, aQ = function($, Y) {
    return (0, d0.IsPlainObject)($) && (0, d0.IsArray)(Y) || (0, d0.IsArray)($) && (0, d0.IsPlainObject)(Y);
  }, eQ = function($, Y) {
    if (DY($) || DY(Y))
      throw new g8;
    if (aQ($, Y))
      throw new k8;
    f8($, "", $, Y);
  };
  Object.defineProperty(wY, "__esModule", { value: true });
  wY.Mutate = wY.ValueMutateInvalidRootMutationError = wY.ValueMutateTypeMismatchError = undefined;
  var d0 = V0(), G$ = b$(), x8 = i1();

  class k8 extends Error {
    constructor() {
      super("Cannot assign due type mismatch of assignable values");
    }
  }
  wY.ValueMutateTypeMismatchError = k8;

  class g8 extends Error {
    constructor() {
      super("Only object and array types can be mutated at the root level");
    }
  }
  wY.ValueMutateInvalidRootMutationError = g8;
  wY.Mutate = eQ;
});
var SY = J0((PY) => {
  var W4 = function($, Y) {
    if (!(0, J1.IsPlainObject)(Y))
      return false;
    const W = [...Object.keys($), ...Object.getOwnPropertySymbols($)], X = [...Object.keys(Y), ...Object.getOwnPropertySymbols(Y)];
    if (W.length !== X.length)
      return false;
    return W.every((Z) => _$($[Z], Y[Z]));
  }, X4 = function($, Y) {
    return (0, J1.IsDate)(Y) && $.getTime() === Y.getTime();
  }, Z4 = function($, Y) {
    if (!(0, J1.IsArray)(Y) || $.length !== Y.length)
      return false;
    return $.every((W, X) => _$(W, Y[X]));
  }, Q4 = function($, Y) {
    if (!(0, J1.IsTypedArray)(Y) || $.length !== Y.length || Object.getPrototypeOf($).constructor.name !== Object.getPrototypeOf(Y).constructor.name)
      return false;
    return $.every((W, X) => _$(W, Y[X]));
  }, J4 = function($, Y) {
    return $ === Y;
  }, _$ = function($, Y) {
    if ((0, J1.IsPlainObject)($))
      return W4($, Y);
    if ((0, J1.IsDate)($))
      return X4($, Y);
    if ((0, J1.IsTypedArray)($))
      return Q4($, Y);
    if ((0, J1.IsArray)($))
      return Z4($, Y);
    if ((0, J1.IsValueType)($))
      return J4($, Y);
    throw new Error("ValueEquals: Unable to compare value");
  };
  Object.defineProperty(PY, "__esModule", { value: true });
  PY.Equal = undefined;
  var J1 = V0();
  PY.Equal = _$;
});
var E$ = J0((z1) => {
  var z4 = z1 && z1.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), H4 = z1 && z1.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        z4(Y, $, W);
  };
  Object.defineProperty(z1, "__esModule", { value: true });
  z1.ValueErrorType = undefined;
  var q4 = Y$();
  Object.defineProperty(z1, "ValueErrorType", { enumerable: true, get: function() {
    return q4.ValueErrorType;
  } });
  H4(P8(), z1);
});
var J$ = J0((CY) => {
  var M4 = function($) {
    return $[C0.Kind] === "Any" || $[C0.Kind] === "Unknown";
  }, r = function($) {
    return $ !== undefined;
  }, U4 = function($, Y, W) {
    return true;
  }, F4 = function($, Y, W) {
    if (!(0, A0.IsArray)(W))
      return false;
    if (r($.minItems) && !(W.length >= $.minItems))
      return false;
    if (r($.maxItems) && !(W.length <= $.maxItems))
      return false;
    if (!W.every((Q) => I0($.items, Y, Q)))
      return false;
    if ($.uniqueItems === true && !function() {
      const Q = new Set;
      for (let J of W) {
        const q = (0, N4.Hash)(J);
        if (Q.has(q))
          return false;
        else
          Q.add(q);
      }
      return true;
    }())
      return false;
    if (!(r($.contains) || (0, A0.IsNumber)($.minContains) || (0, A0.IsNumber)($.maxContains)))
      return true;
    const X = r($.contains) ? $.contains : C0.Type.Never(), Z = W.reduce((Q, J) => I0(X, Y, J) ? Q + 1 : Q, 0);
    if (Z === 0)
      return false;
    if ((0, A0.IsNumber)($.minContains) && Z < $.minContains)
      return false;
    if ((0, A0.IsNumber)($.maxContains) && Z > $.maxContains)
      return false;
    return true;
  }, B4 = function($, Y, W) {
    return (0, A0.IsAsyncIterator)(W);
  }, A4 = function($, Y, W) {
    if (!(0, A0.IsBigInt)(W))
      return false;
    if (r($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (r($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (r($.maximum) && !(W <= $.maximum))
      return false;
    if (r($.minimum) && !(W >= $.minimum))
      return false;
    if (r($.multipleOf) && W % $.multipleOf !== BigInt(0))
      return false;
    return true;
  }, D4 = function($, Y, W) {
    return (0, A0.IsBoolean)(W);
  }, w4 = function($, Y, W) {
    return I0($.returns, Y, W.prototype);
  }, K4 = function($, Y, W) {
    if (!(0, A0.IsDate)(W))
      return false;
    if (r($.exclusiveMaximumTimestamp) && !(W.getTime() < $.exclusiveMaximumTimestamp))
      return false;
    if (r($.exclusiveMinimumTimestamp) && !(W.getTime() > $.exclusiveMinimumTimestamp))
      return false;
    if (r($.maximumTimestamp) && !(W.getTime() <= $.maximumTimestamp))
      return false;
    if (r($.minimumTimestamp) && !(W.getTime() >= $.minimumTimestamp))
      return false;
    if (r($.multipleOfTimestamp) && W.getTime() % $.multipleOfTimestamp !== 0)
      return false;
    return true;
  }, j4 = function($, Y, W) {
    return (0, A0.IsFunction)(W);
  }, P4 = function($, Y, W) {
    if (!(0, A0.IsInteger)(W))
      return false;
    if (r($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (r($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (r($.maximum) && !(W <= $.maximum))
      return false;
    if (r($.minimum) && !(W >= $.minimum))
      return false;
    if (r($.multipleOf) && W % $.multipleOf !== 0)
      return false;
    return true;
  }, O4 = function($, Y, W) {
    const X = $.allOf.every((Z) => I0(Z, Y, W));
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(C0.KeyResolver.ResolvePattern($)), Q = Object.getOwnPropertyNames(W).every((J) => Z.test(J));
      return X && Q;
    } else if (C0.TypeGuard.TSchema($.unevaluatedProperties)) {
      const Z = new RegExp(C0.KeyResolver.ResolvePattern($)), Q = Object.getOwnPropertyNames(W).every((J) => Z.test(J) || I0($.unevaluatedProperties, Y, W[J]));
      return X && Q;
    } else
      return X;
  }, S4 = function($, Y, W) {
    return (0, A0.IsIterator)(W);
  }, L4 = function($, Y, W) {
    return W === $.const;
  }, C4 = function($, Y, W) {
    return false;
  }, I4 = function($, Y, W) {
    return !I0($.not, Y, W);
  }, b4 = function($, Y, W) {
    return (0, A0.IsNull)(W);
  }, R4 = function($, Y, W) {
    if (!Q$.TypeSystemPolicy.IsNumberLike(W))
      return false;
    if (r($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (r($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (r($.minimum) && !(W >= $.minimum))
      return false;
    if (r($.maximum) && !(W <= $.maximum))
      return false;
    if (r($.multipleOf) && W % $.multipleOf !== 0)
      return false;
    return true;
  }, G4 = function($, Y, W) {
    if (!Q$.TypeSystemPolicy.IsObjectLike(W))
      return false;
    if (r($.minProperties) && !(Object.getOwnPropertyNames(W).length >= $.minProperties))
      return false;
    if (r($.maxProperties) && !(Object.getOwnPropertyNames(W).length <= $.maxProperties))
      return false;
    const X = Object.getOwnPropertyNames($.properties);
    for (let Z of X) {
      const Q = $.properties[Z];
      if ($.required && $.required.includes(Z)) {
        if (!I0(Q, Y, W[Z]))
          return false;
        if ((C0.ExtendsUndefined.Check(Q) || M4(Q)) && !(Z in W))
          return false;
      } else if (Q$.TypeSystemPolicy.IsExactOptionalProperty(W, Z) && !I0(Q, Y, W[Z]))
        return false;
    }
    if ($.additionalProperties === false) {
      const Z = Object.getOwnPropertyNames(W);
      if ($.required && $.required.length === X.length && Z.length === X.length)
        return true;
      else
        return Z.every((Q) => X.includes(Q));
    } else if (typeof $.additionalProperties === "object")
      return Object.getOwnPropertyNames(W).every((Q) => X.includes(Q) || I0($.additionalProperties, Y, W[Q]));
    else
      return true;
  }, _4 = function($, Y, W) {
    return (0, A0.IsPromise)(W);
  }, E4 = function($, Y, W) {
    if (!Q$.TypeSystemPolicy.IsRecordLike(W))
      return false;
    if (r($.minProperties) && !(Object.getOwnPropertyNames(W).length >= $.minProperties))
      return false;
    if (r($.maxProperties) && !(Object.getOwnPropertyNames(W).length <= $.maxProperties))
      return false;
    const [X, Z] = Object.entries($.patternProperties)[0], Q = new RegExp(X), J = Object.entries(W).every(([D, K]) => {
      return Q.test(D) ? I0(Z, Y, K) : true;
    }), q = typeof $.additionalProperties === "object" ? Object.entries(W).every(([D, K]) => {
      return !Q.test(D) ? I0($.additionalProperties, Y, K) : true;
    }) : true, F = $.additionalProperties === false ? Object.getOwnPropertyNames(W).every((D) => {
      return Q.test(D);
    }) : true;
    return J && q && F;
  }, V4 = function($, Y, W) {
    return I0((0, LY.Deref)($, Y), Y, W);
  }, x4 = function($, Y, W) {
    if (!(0, A0.IsString)(W))
      return false;
    if (r($.minLength)) {
      if (!(W.length >= $.minLength))
        return false;
    }
    if (r($.maxLength)) {
      if (!(W.length <= $.maxLength))
        return false;
    }
    if (r($.pattern)) {
      if (!new RegExp($.pattern).test(W))
        return false;
    }
    if (r($.format)) {
      if (!C0.FormatRegistry.Has($.format))
        return false;
      return C0.FormatRegistry.Get($.format)(W);
    }
    return true;
  }, k4 = function($, Y, W) {
    return (0, A0.IsSymbol)(W);
  }, g4 = function($, Y, W) {
    return (0, A0.IsString)(W) && new RegExp($.pattern).test(W);
  }, f4 = function($, Y, W) {
    return I0((0, LY.Deref)($, Y), Y, W);
  }, T4 = function($, Y, W) {
    if (!(0, A0.IsArray)(W))
      return false;
    if ($.items === undefined && W.length !== 0)
      return false;
    if (W.length !== $.maxItems)
      return false;
    if (!$.items)
      return true;
    for (let X = 0;X < $.items.length; X++)
      if (!I0($.items[X], Y, W[X]))
        return false;
    return true;
  }, d4 = function($, Y, W) {
    return (0, A0.IsUndefined)(W);
  }, y4 = function($, Y, W) {
    return $.anyOf.some((X) => I0(X, Y, W));
  }, v4 = function($, Y, W) {
    if (!(0, A0.IsUint8Array)(W))
      return false;
    if (r($.maxByteLength) && !(W.length <= $.maxByteLength))
      return false;
    if (r($.minByteLength) && !(W.length >= $.minByteLength))
      return false;
    return true;
  }, p4 = function($, Y, W) {
    return true;
  }, i4 = function($, Y, W) {
    return Q$.TypeSystemPolicy.IsVoidLike(W);
  }, m4 = function($, Y, W) {
    if (!C0.TypeRegistry.Has($[C0.Kind]))
      return false;
    return C0.TypeRegistry.Get($[C0.Kind])($, W);
  }, I0 = function($, Y, W) {
    const X = r($.$id) ? [...Y, $] : Y, Z = $;
    switch (Z[C0.Kind]) {
      case "Any":
        return U4(Z, X, W);
      case "Array":
        return F4(Z, X, W);
      case "AsyncIterator":
        return B4(Z, X, W);
      case "BigInt":
        return A4(Z, X, W);
      case "Boolean":
        return D4(Z, X, W);
      case "Constructor":
        return w4(Z, X, W);
      case "Date":
        return K4(Z, X, W);
      case "Function":
        return j4(Z, X, W);
      case "Integer":
        return P4(Z, X, W);
      case "Intersect":
        return O4(Z, X, W);
      case "Iterator":
        return S4(Z, X, W);
      case "Literal":
        return L4(Z, X, W);
      case "Never":
        return C4(Z, X, W);
      case "Not":
        return I4(Z, X, W);
      case "Null":
        return b4(Z, X, W);
      case "Number":
        return R4(Z, X, W);
      case "Object":
        return G4(Z, X, W);
      case "Promise":
        return _4(Z, X, W);
      case "Record":
        return E4(Z, X, W);
      case "Ref":
        return V4(Z, X, W);
      case "String":
        return x4(Z, X, W);
      case "Symbol":
        return k4(Z, X, W);
      case "TemplateLiteral":
        return g4(Z, X, W);
      case "This":
        return f4(Z, X, W);
      case "Tuple":
        return T4(Z, X, W);
      case "Undefined":
        return d4(Z, X, W);
      case "Union":
        return y4(Z, X, W);
      case "Uint8Array":
        return v4(Z, X, W);
      case "Unknown":
        return p4(Z, X, W);
      case "Void":
        return i4(Z, X, W);
      default:
        if (!C0.TypeRegistry.Has(Z[C0.Kind]))
          throw new T8(Z);
        return m4(Z, X, W);
    }
  }, u4 = function(...$) {
    return $.length === 3 ? I0($[0], $[1], $[2]) : I0($[0], [], $[1]);
  };
  Object.defineProperty(CY, "__esModule", { value: true });
  CY.Check = CY.ValueCheckUnknownTypeError = undefined;
  var A0 = V0(), Q$ = E$(), LY = D1(), N4 = W$(), C0 = f0();

  class T8 extends C0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  CY.ValueCheckUnknownTypeError = T8;
  CY.Check = u4;
});
var u8 = J0((_Y) => {
  var o4 = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return {};
  }, c4 = function($, Y) {
    if ($.uniqueItems === true && !(0, e.HasPropertyKey)($, "default"))
      throw new Error("ValueCreate.Array: Array with the uniqueItems constraint requires a default value");
    else if (("contains" in $) && !(0, e.HasPropertyKey)($, "default"))
      throw new Error("ValueCreate.Array: Array with the contains constraint requires a default value");
    else if ("default" in $)
      return $.default;
    else if ($.minItems !== undefined)
      return Array.from({ length: $.minItems }).map((W) => {
        return y0($.items, Y);
      });
    else
      return [];
  }, l4 = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return async function* () {
      }();
  }, t4 = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return BigInt(0);
  }, s4 = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return false;
  }, r4 = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = y0($.returns, Y);
      if (typeof W === "object" && !Array.isArray(W))
        return class {
          constructor() {
            for (let [X, Z] of Object.entries(W)) {
              const Q = this;
              Q[X] = Z;
            }
          }
        };
      else
        return class {
        };
    }
  }, a4 = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimumTimestamp !== undefined)
      return new Date($.minimumTimestamp);
    else
      return new Date(0);
  }, e4 = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return () => y0($.returns, Y);
  }, $J = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, YJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = $.allOf.reduce((X, Z) => {
        const Q = y0(Z, Y);
        return typeof Q === "object" ? { ...X, ...Q } : Q;
      }, {});
      if (!(0, h4.Check)($, Y, W))
        throw new p8($);
      return W;
    }
  }, WJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return function* () {
      }();
  }, XJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return $.const;
  }, ZJ = function($, Y) {
    throw new y8($);
  }, QJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      throw new v8($);
  }, JJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return null;
  }, zJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, HJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = new Set($.required);
      return $.default || Object.entries($.properties).reduce((X, [Z, Q]) => {
        return W.has(Z) ? { ...X, [Z]: y0(Q, Y) } : { ...X };
      }, {});
    }
  }, qJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return Promise.resolve(y0($.item, Y));
  }, NJ = function($, Y) {
    const [W, X] = Object.entries($.patternProperties)[0];
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else if (!(W === x0.PatternStringExact || W === x0.PatternNumberExact))
      return W.slice(1, W.length - 1).split("|").reduce((Q, J) => {
        return { ...Q, [J]: y0(X, Y) };
      }, {});
    else
      return {};
  }, MJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return y0((0, RY.Deref)($, Y), Y);
  }, UJ = function($, Y) {
    if ($.pattern !== undefined)
      if (!(0, e.HasPropertyKey)($, "default"))
        throw new Error("ValueCreate.String: String types with patterns must specify a default value");
      else
        return $.default;
    else if ($.format !== undefined)
      if (!(0, e.HasPropertyKey)($, "default"))
        throw new Error("ValueCreate.String: String types with formats must specify a default value");
      else
        return $.default;
    else if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minLength !== undefined)
      return Array.from({ length: $.minLength }).map(() => ".").join("");
    else
      return "";
  }, FJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else if ("value" in $)
      return Symbol.for($.value);
    else
      return Symbol();
  }, BJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    const W = x0.TemplateLiteralParser.ParseExact($.pattern);
    if (!x0.TemplateLiteralFinite.Check(W))
      throw new i8($);
    return x0.TemplateLiteralGenerator.Generate(W).next().value;
  }, AJ = function($, Y) {
    if (GY++ > bY)
      throw new m8($, bY);
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return y0((0, RY.Deref)($, Y), Y);
  }, DJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    if ($.items === undefined)
      return [];
    else
      return Array.from({ length: $.minItems }).map((W, X) => y0($.items[X], Y));
  }, wJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return;
  }, KJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.anyOf.length === 0)
      throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
    else
      return y0($.anyOf[0], Y);
  }, jJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minByteLength !== undefined)
      return new Uint8Array($.minByteLength);
    else
      return new Uint8Array(0);
  }, PJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return {};
  }, OJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return;
  }, SJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      throw new Error("User defined types must specify a default value");
  }, y0 = function($, Y) {
    const W = (0, e.IsString)($.$id) ? [...Y, $] : Y, X = $;
    switch (X[x0.Kind]) {
      case "Any":
        return o4(X, W);
      case "Array":
        return c4(X, W);
      case "AsyncIterator":
        return l4(X, W);
      case "BigInt":
        return t4(X, W);
      case "Boolean":
        return s4(X, W);
      case "Constructor":
        return r4(X, W);
      case "Date":
        return a4(X, W);
      case "Function":
        return e4(X, W);
      case "Integer":
        return $J(X, W);
      case "Intersect":
        return YJ(X, W);
      case "Iterator":
        return WJ(X, W);
      case "Literal":
        return XJ(X, W);
      case "Never":
        return ZJ(X, W);
      case "Not":
        return QJ(X, W);
      case "Null":
        return JJ(X, W);
      case "Number":
        return zJ(X, W);
      case "Object":
        return HJ(X, W);
      case "Promise":
        return qJ(X, W);
      case "Record":
        return NJ(X, W);
      case "Ref":
        return MJ(X, W);
      case "String":
        return UJ(X, W);
      case "Symbol":
        return FJ(X, W);
      case "TemplateLiteral":
        return BJ(X, W);
      case "This":
        return AJ(X, W);
      case "Tuple":
        return DJ(X, W);
      case "Undefined":
        return wJ(X, W);
      case "Union":
        return KJ(X, W);
      case "Uint8Array":
        return jJ(X, W);
      case "Unknown":
        return PJ(X, W);
      case "Void":
        return OJ(X, W);
      default:
        if (!x0.TypeRegistry.Has(X[x0.Kind]))
          throw new d8(X);
        return SJ(X, W);
    }
  }, LJ = function(...$) {
    return GY = 0, $.length === 2 ? y0($[0], $[1]) : y0($[0], []);
  };
  Object.defineProperty(_Y, "__esModule", { value: true });
  _Y.Create = _Y.ValueCreateRecursiveInstantiationError = _Y.ValueCreateTempateLiteralTypeError = _Y.ValueCreateIntersectTypeError = _Y.ValueCreateNotTypeError = _Y.ValueCreateNeverTypeError = _Y.ValueCreateUnknownTypeError = undefined;
  var e = V0(), h4 = J$(), RY = D1(), x0 = f0();

  class d8 extends x0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  _Y.ValueCreateUnknownTypeError = d8;

  class y8 extends x0.TypeBoxError {
    constructor($) {
      super("Never types cannot be created");
      this.schema = $;
    }
  }
  _Y.ValueCreateNeverTypeError = y8;

  class v8 extends x0.TypeBoxError {
    constructor($) {
      super("Not types must have a default value");
      this.schema = $;
    }
  }
  _Y.ValueCreateNotTypeError = v8;

  class p8 extends x0.TypeBoxError {
    constructor($) {
      super("Intersect produced invalid value. Consider using a default value.");
      this.schema = $;
    }
  }
  _Y.ValueCreateIntersectTypeError = p8;

  class i8 extends x0.TypeBoxError {
    constructor($) {
      super("Can only create template literal values from patterns that produce finite sequences. Consider using a default value.");
      this.schema = $;
    }
  }
  _Y.ValueCreateTempateLiteralTypeError = i8;

  class m8 extends x0.TypeBoxError {
    constructor($, Y) {
      super("Value cannot be created as recursive type may produce value of infinite size. Consider using a default.");
      this.schema = $, this.recursiveMaxDepth = Y;
    }
  }
  _Y.ValueCreateRecursiveInstantiationError = m8;
  var bY = 512, GY = 0;
  _Y.Create = LJ;
});
var dY = J0((fY) => {
  var kY = function($, Y, W) {
    return (0, u0.Check)($, Y, W) ? (0, u1.Clone)(W) : (0, q1.Create)($, Y);
  }, h8 = function($, Y, W) {
    return (0, u0.Check)($, Y, W) ? W : (0, q1.Create)($, Y);
  }, EJ = function($, Y, W) {
    if ((0, u0.Check)($, Y, W))
      return (0, u1.Clone)(W);
    const X = (0, w1.IsArray)(W) ? (0, u1.Clone)(W) : (0, q1.Create)($, Y), Z = (0, w1.IsNumber)($.minItems) && X.length < $.minItems ? [...X, ...Array.from({ length: $.minItems - X.length }, () => null)] : X, J = ((0, w1.IsNumber)($.maxItems) && Z.length > $.maxItems ? Z.slice(0, $.maxItems) : Z).map((F) => $1($.items, Y, F));
    if ($.uniqueItems !== true)
      return J;
    const q = [...new Set(J)];
    if (!(0, u0.Check)($, Y, q))
      throw new o8($, q);
    return q;
  }, VJ = function($, Y, W) {
    if ((0, u0.Check)($, Y, W))
      return (0, q1.Create)($, Y);
    const X = new Set($.returns.required || []), Z = function() {
    };
    for (let [Q, J] of Object.entries($.returns.properties)) {
      if (!X.has(Q) && W.prototype[Q] === undefined)
        continue;
      Z.prototype[Q] = $1(J, Y, W.prototype[Q]);
    }
    return Z;
  }, xJ = function($, Y, W) {
    const X = (0, q1.Create)($, Y), Z = (0, w1.IsPlainObject)(X) && (0, w1.IsPlainObject)(W) ? { ...X, ...W } : W;
    return (0, u0.Check)($, Y, Z) ? Z : (0, q1.Create)($, Y);
  }, kJ = function($, Y, W) {
    throw new c8($);
  }, gJ = function($, Y, W) {
    if ((0, u0.Check)($, Y, W))
      return W;
    if (W === null || typeof W !== "object")
      return (0, q1.Create)($, Y);
    const X = new Set($.required || []), Z = {};
    for (let [Q, J] of Object.entries($.properties)) {
      if (!X.has(Q) && W[Q] === undefined)
        continue;
      Z[Q] = $1(J, Y, W[Q]);
    }
    if (typeof $.additionalProperties === "object") {
      const Q = Object.getOwnPropertyNames($.properties);
      for (let J of Object.getOwnPropertyNames(W)) {
        if (Q.includes(J))
          continue;
        Z[J] = $1($.additionalProperties, Y, W[J]);
      }
    }
    return Z;
  }, fJ = function($, Y, W) {
    if ((0, u0.Check)($, Y, W))
      return (0, u1.Clone)(W);
    if (W === null || typeof W !== "object" || Array.isArray(W) || W instanceof Date)
      return (0, q1.Create)($, Y);
    const X = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X], Q = {};
    for (let [J, q] of Object.entries(W))
      Q[J] = $1(Z, Y, q);
    return Q;
  }, TJ = function($, Y, W) {
    return $1((0, VY.Deref)($, Y), Y, W);
  }, dJ = function($, Y, W) {
    return $1((0, VY.Deref)($, Y), Y, W);
  }, yJ = function($, Y, W) {
    if ((0, u0.Check)($, Y, W))
      return (0, u1.Clone)(W);
    if (!(0, w1.IsArray)(W))
      return (0, q1.Create)($, Y);
    if ($.items === undefined)
      return [];
    return $.items.map((X, Z) => $1(X, Y, W[Z]));
  }, vJ = function($, Y, W) {
    return (0, u0.Check)($, Y, W) ? (0, u1.Clone)(W) : n8.Create($, Y, W);
  }, $1 = function($, Y, W) {
    const X = (0, w1.IsString)($.$id) ? [...Y, $] : Y, Z = $;
    switch ($[H1.Kind]) {
      case "Array":
        return EJ(Z, X, W);
      case "Constructor":
        return VJ(Z, X, W);
      case "Intersect":
        return xJ(Z, X, W);
      case "Never":
        return kJ(Z, X, W);
      case "Object":
        return gJ(Z, X, W);
      case "Record":
        return fJ(Z, X, W);
      case "Ref":
        return TJ(Z, X, W);
      case "This":
        return dJ(Z, X, W);
      case "Tuple":
        return yJ(Z, X, W);
      case "Union":
        return vJ(Z, X, W);
      case "Date":
      case "Symbol":
      case "Uint8Array":
        return kY($, Y, W);
      case "Any":
      case "AsyncIterator":
      case "BigInt":
      case "Boolean":
      case "Function":
      case "Integer":
      case "Iterator":
      case "Literal":
      case "Not":
      case "Null":
      case "Number":
      case "Promise":
      case "String":
      case "TemplateLiteral":
      case "Undefined":
      case "Unknown":
      case "Void":
        return h8(Z, X, W);
      default:
        if (!H1.TypeRegistry.Has(Z[H1.Kind]))
          throw new l8(Z);
        return h8(Z, X, W);
    }
  }, gY = function(...$) {
    return $.length === 3 ? $1($[0], $[1], $[2]) : $1($[0], [], $[1]);
  };
  Object.defineProperty(fY, "__esModule", { value: true });
  fY.Cast = fY.Default = fY.DefaultClone = fY.ValueCastUnknownTypeError = fY.ValueCastRecursiveTypeError = fY.ValueCastNeverTypeError = fY.ValueCastArrayUniqueItemsTypeError = undefined;
  var w1 = V0(), q1 = u8(), u0 = J$(), u1 = i1(), VY = D1(), H1 = f0();

  class o8 extends H1.TypeBoxError {
    constructor($, Y) {
      super("Array cast produced invalid data due to uniqueItems constraint");
      this.schema = $, this.value = Y;
    }
  }
  fY.ValueCastArrayUniqueItemsTypeError = o8;

  class c8 extends H1.TypeBoxError {
    constructor($) {
      super("Never types cannot be cast");
      this.schema = $;
    }
  }
  fY.ValueCastNeverTypeError = c8;

  class xY extends H1.TypeBoxError {
    constructor($) {
      super("Cannot cast recursive schemas");
      this.schema = $;
    }
  }
  fY.ValueCastRecursiveTypeError = xY;

  class l8 extends H1.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  fY.ValueCastUnknownTypeError = l8;
  var n8;
  (function($) {
    function Y(Z, Q, J) {
      if (Z[H1.Kind] === "Object" && typeof J === "object" && !(0, w1.IsNull)(J)) {
        const q = Z, F = Object.getOwnPropertyNames(J), D = Object.entries(q.properties), [K, A] = [1 / D.length, D.length];
        return D.reduce((I, [j, M]) => {
          const L = M[H1.Kind] === "Literal" && M.const === J[j] ? A : 0, O = (0, u0.Check)(M, Q, J[j]) ? K : 0, U = F.includes(j) ? K : 0;
          return I + (L + O + U);
        }, 0);
      } else
        return (0, u0.Check)(Z, Q, J) ? 1 : 0;
    }
    function W(Z, Q, J) {
      let [q, F] = [Z.anyOf[0], 0];
      for (let D of Z.anyOf) {
        const K = Y(D, Q, J);
        if (K > F)
          q = D, F = K;
      }
      return q;
    }
    function X(Z, Q, J) {
      if ("default" in Z)
        return Z.default;
      else {
        const q = W(Z, Q, J);
        return gY(q, Q, J);
      }
    }
    $.Create = X;
  })(n8 || (n8 = {}));
  fY.DefaultClone = kY;
  fY.Default = h8;
  fY.Cast = gY;
});
var nY = J0((mY) => {
  var V$ = function($) {
    return (0, Z0.IsString)($) && !isNaN($) && !isNaN(parseFloat($));
  }, lJ = function($) {
    return (0, Z0.IsBigInt)($) || (0, Z0.IsBoolean)($) || (0, Z0.IsNumber)($);
  }, z$ = function($) {
    return $ === true || (0, Z0.IsNumber)($) && $ === 1 || (0, Z0.IsBigInt)($) && $ === BigInt("1") || (0, Z0.IsString)($) && ($.toLowerCase() === "true" || $ === "1");
  }, H$ = function($) {
    return $ === false || (0, Z0.IsNumber)($) && ($ === 0 || Object.is($, -0)) || (0, Z0.IsBigInt)($) && $ === BigInt("0") || (0, Z0.IsString)($) && ($.toLowerCase() === "false" || $ === "0" || $ === "-0");
  }, tJ = function($) {
    return (0, Z0.IsString)($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, sJ = function($) {
    return (0, Z0.IsString)($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, rJ = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, aJ = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, eJ = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test($);
  }, $9 = function($, Y) {
    const W = pY($);
    return W === Y ? W : $;
  }, Y9 = function($, Y) {
    const W = iY($);
    return W === Y ? W : $;
  }, W9 = function($, Y) {
    const W = vY($);
    return W === Y ? W : $;
  }, X9 = function($, Y) {
    if (typeof $.const === "string")
      return $9(Y, $.const);
    else if (typeof $.const === "number")
      return Y9(Y, $.const);
    else if (typeof $.const === "boolean")
      return W9(Y, $.const);
    else
      return (0, oJ.Clone)(Y);
  }, vY = function($) {
    return z$($) ? true : H$($) ? false : $;
  }, Z9 = function($) {
    return V$($) ? BigInt(parseInt($)) : (0, Z0.IsNumber)($) ? BigInt($ | 0) : H$($) ? BigInt(0) : z$($) ? BigInt(1) : $;
  }, pY = function($) {
    return lJ($) ? $.toString() : (0, Z0.IsSymbol)($) && $.description !== undefined ? $.description.toString() : $;
  }, iY = function($) {
    return V$($) ? parseFloat($) : z$($) ? 1 : H$($) ? 0 : $;
  }, Q9 = function($) {
    return V$($) ? parseInt($) : (0, Z0.IsNumber)($) ? $ | 0 : z$($) ? 1 : H$($) ? 0 : $;
  }, J9 = function($) {
    return (0, Z0.IsString)($) && $.toLowerCase() === "null" ? null : $;
  }, z9 = function($) {
    return (0, Z0.IsString)($) && $ === "undefined" ? undefined : $;
  }, H9 = function($) {
    return (0, Z0.IsDate)($) ? $ : (0, Z0.IsNumber)($) ? new Date($) : z$($) ? new Date(1) : H$($) ? new Date(0) : V$($) ? new Date(parseInt($)) : sJ($) ? new Date(`1970-01-01T${$}.000Z`) : tJ($) ? new Date(`1970-01-01T${$}`) : aJ($) ? new Date(`${$}.000Z`) : rJ($) ? new Date($) : eJ($) ? new Date(`${$}T00:00:00.000Z`) : $;
  }, t8 = function($) {
    return $;
  }, q9 = function($, Y, W) {
    if ((0, Z0.IsArray)(W))
      return W.map((X) => c0($.items, Y, X));
    return W;
  }, N9 = function($, Y, W) {
    return Z9(W);
  }, M9 = function($, Y, W) {
    return vY(W);
  }, U9 = function($, Y, W) {
    return H9(W);
  }, F9 = function($, Y, W) {
    return Q9(W);
  }, B9 = function($, Y, W) {
    return $.allOf.every((X) => n1.TypeGuard.TObject(X)) ? c0(n1.Type.Composite($.allOf), Y, W) : c0($.allOf[0], Y, W);
  }, A9 = function($, Y, W) {
    return X9($, W);
  }, D9 = function($, Y, W) {
    return J9(W);
  }, w9 = function($, Y, W) {
    return iY(W);
  }, K9 = function($, Y, W) {
    if ((0, Z0.IsObject)(W))
      return Object.getOwnPropertyNames($.properties).reduce((X, Z) => {
        return W[Z] !== undefined ? { ...X, [Z]: c0($.properties[Z], Y, W[Z]) } : { ...X };
      }, W);
    return W;
  }, j9 = function($, Y, W) {
    const X = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X], Q = {};
    for (let [J, q] of Object.entries(W))
      Q[J] = c0(Z, Y, q);
    return Q;
  }, P9 = function($, Y, W) {
    return c0((0, yY.Deref)($, Y), Y, W);
  }, O9 = function($, Y, W) {
    return pY(W);
  }, S9 = function($, Y, W) {
    return (0, Z0.IsString)(W) || (0, Z0.IsNumber)(W) ? Symbol(W) : W;
  }, L9 = function($, Y, W) {
    return c0((0, yY.Deref)($, Y), Y, W);
  }, C9 = function($, Y, W) {
    if ((0, Z0.IsArray)(W) && !(0, Z0.IsUndefined)($.items))
      return W.map((X, Z) => {
        return Z < $.items.length ? c0($.items[Z], Y, X) : X;
      });
    return W;
  }, I9 = function($, Y, W) {
    return z9(W);
  }, b9 = function($, Y, W) {
    for (let X of $.anyOf) {
      const Z = c0(X, Y, W);
      if ((0, cJ.Check)(X, Y, Z))
        return Z;
    }
    return W;
  }, c0 = function($, Y, W) {
    const X = (0, Z0.IsString)($.$id) ? [...Y, $] : Y, Z = $;
    switch ($[n1.Kind]) {
      case "Array":
        return q9(Z, X, W);
      case "BigInt":
        return N9(Z, X, W);
      case "Boolean":
        return M9(Z, X, W);
      case "Date":
        return U9(Z, X, W);
      case "Integer":
        return F9(Z, X, W);
      case "Intersect":
        return B9(Z, X, W);
      case "Literal":
        return A9(Z, X, W);
      case "Null":
        return D9(Z, X, W);
      case "Number":
        return w9(Z, X, W);
      case "Object":
        return K9(Z, X, W);
      case "Record":
        return j9(Z, X, W);
      case "Ref":
        return P9(Z, X, W);
      case "String":
        return O9(Z, X, W);
      case "Symbol":
        return S9(Z, X, W);
      case "This":
        return L9(Z, X, W);
      case "Tuple":
        return C9(Z, X, W);
      case "Undefined":
        return I9(Z, X, W);
      case "Union":
        return b9(Z, X, W);
      case "Any":
      case "AsyncIterator":
      case "Constructor":
      case "Function":
      case "Iterator":
      case "Never":
      case "Promise":
      case "TemplateLiteral":
      case "Uint8Array":
      case "Unknown":
      case "Void":
        return t8(W);
      default:
        if (!n1.TypeRegistry.Has(Z[n1.Kind]))
          throw new s8(Z);
        return t8(W);
    }
  }, R9 = function(...$) {
    return $.length === 3 ? c0($[0], $[1], $[2]) : c0($[0], [], $[1]);
  };
  Object.defineProperty(mY, "__esModule", { value: true });
  mY.Convert = mY.Default = mY.ValueConvertUnknownTypeError = undefined;
  var Z0 = V0(), oJ = i1(), cJ = J$(), yY = D1(), n1 = f0();

  class s8 extends n1.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  mY.ValueConvertUnknownTypeError = s8;
  mY.Default = t8;
  mY.Convert = R9;
});
var e8 = J0((sY) => {
  Object.defineProperty(sY, "__esModule", { value: true });
  sY.EncodeTransform = sY.DecodeTransform = sY.HasTransform = sY.TransformEncodeError = sY.TransformDecodeError = sY.TransformEncodeCheckError = sY.TransformDecodeCheckError = sY.TransformUnknownTypeError = undefined;
  var l0 = V0(), h1 = D1(), n = f0();

  class q$ extends n.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  sY.TransformUnknownTypeError = q$;

  class lY extends n.TypeBoxError {
    constructor($, Y, W) {
      super("Unable to decode due to invalid value");
      this.schema = $, this.value = Y, this.error = W;
    }
  }
  sY.TransformDecodeCheckError = lY;

  class tY extends n.TypeBoxError {
    constructor($, Y, W) {
      super("Unable to encode due to invalid value");
      this.schema = $, this.value = Y, this.error = W;
    }
  }
  sY.TransformEncodeCheckError = tY;

  class r8 extends n.TypeBoxError {
    constructor($, Y, W) {
      super(`${W instanceof Error ? W.message : "Unknown error"}`);
      this.schema = $, this.value = Y;
    }
  }
  sY.TransformDecodeError = r8;

  class a8 extends n.TypeBoxError {
    constructor($, Y, W) {
      super(`${W instanceof Error ? W.message : "Unknown error"}`);
      this.schema = $, this.value = Y;
    }
  }
  sY.TransformEncodeError = a8;
  var hY;
  (function($) {
    function Y(w, b) {
      return n.TypeGuard.TTransform(w) || L(w.items, b);
    }
    function W(w, b) {
      return n.TypeGuard.TTransform(w) || L(w.items, b);
    }
    function X(w, b) {
      return n.TypeGuard.TTransform(w) || L(w.returns, b) || w.parameters.some((R) => L(R, b));
    }
    function Z(w, b) {
      return n.TypeGuard.TTransform(w) || L(w.returns, b) || w.parameters.some((R) => L(R, b));
    }
    function Q(w, b) {
      return n.TypeGuard.TTransform(w) || n.TypeGuard.TTransform(w.unevaluatedProperties) || w.allOf.some((R) => L(R, b));
    }
    function J(w, b) {
      return n.TypeGuard.TTransform(w) || L(w.items, b);
    }
    function q(w, b) {
      return n.TypeGuard.TTransform(w) || L(w.not, b);
    }
    function F(w, b) {
      return n.TypeGuard.TTransform(w) || Object.values(w.properties).some((R) => L(R, b)) || n.TypeGuard.TSchema(w.additionalProperties) && L(w.additionalProperties, b);
    }
    function D(w, b) {
      return n.TypeGuard.TTransform(w) || L(w.item, b);
    }
    function K(w, b) {
      const R = Object.getOwnPropertyNames(w.patternProperties)[0], V = w.patternProperties[R];
      return n.TypeGuard.TTransform(w) || L(V, b) || n.TypeGuard.TSchema(w.additionalProperties) && n.TypeGuard.TTransform(w.additionalProperties);
    }
    function A(w, b) {
      if (n.TypeGuard.TTransform(w))
        return true;
      return L((0, h1.Deref)(w, b), b);
    }
    function I(w, b) {
      if (n.TypeGuard.TTransform(w))
        return true;
      return L((0, h1.Deref)(w, b), b);
    }
    function j(w, b) {
      return n.TypeGuard.TTransform(w) || n.TypeGuard.TSchema(w.items) && w.items.some((R) => L(R, b));
    }
    function M(w, b) {
      return n.TypeGuard.TTransform(w) || w.anyOf.some((R) => L(R, b));
    }
    function L(w, b) {
      const R = (0, l0.IsString)(w.$id) ? [...b, w] : b, V = w;
      if (w.$id && O.has(w.$id))
        return false;
      if (w.$id)
        O.add(w.$id);
      switch (w[n.Kind]) {
        case "Array":
          return Y(V, R);
        case "AsyncIterator":
          return W(V, R);
        case "Constructor":
          return X(V, R);
        case "Function":
          return Z(V, R);
        case "Intersect":
          return Q(V, R);
        case "Iterator":
          return J(V, R);
        case "Not":
          return q(V, R);
        case "Object":
          return F(V, R);
        case "Promise":
          return D(V, R);
        case "Record":
          return K(V, R);
        case "Ref":
          return A(V, R);
        case "This":
          return I(V, R);
        case "Tuple":
          return j(V, R);
        case "Union":
          return M(V, R);
        case "Any":
        case "BigInt":
        case "Boolean":
        case "Date":
        case "Integer":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "String":
        case "Symbol":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return n.TypeGuard.TTransform(w);
        default:
          if (!n.TypeRegistry.Has(V[n.Kind]))
            throw new q$(V);
          return n.TypeGuard.TTransform(w);
      }
    }
    const O = new Set;
    function U(w, b) {
      return O.clear(), L(w, b);
    }
    $.Has = U;
  })(hY || (sY.HasTransform = hY = {}));
  var oY;
  (function($) {
    function Y(M, L) {
      try {
        return n.TypeGuard.TTransform(M) ? M[n.Transform].Decode(L) : L;
      } catch (O) {
        throw new r8(M, L, O);
      }
    }
    function W(M, L, O) {
      const U = O.map((w) => A(M.items, L, w));
      return Y(M, U);
    }
    function X(M, L, O) {
      if (!(0, l0.IsPlainObject)(O) || (0, l0.IsValueType)(O))
        return Y(M, O);
      const U = n.KeyResolver.ResolveKeys(M, { includePatterns: false }), w = Object.entries(O).reduce((R, [V, G]) => {
        return !U.includes(V) ? { ...R, [V]: G } : { ...R, [V]: Y(n.IndexedAccessor.Resolve(M, [V]), G) };
      }, {});
      if (!n.TypeGuard.TTransform(M.unevaluatedProperties))
        return Y(M, w);
      const b = Object.entries(w).reduce((R, [V, G]) => {
        return U.includes(V) ? { ...R, [V]: G } : { ...R, [V]: Y(M.unevaluatedProperties, G) };
      }, {});
      return Y(M, b);
    }
    function Z(M, L, O) {
      const U = A(M.not, L, O);
      return Y(M, U);
    }
    function Q(M, L, O) {
      if (!(0, l0.IsPlainObject)(O))
        return Y(M, O);
      const U = Object.entries(O).reduce((R, [V, G]) => {
        return !(V in M.properties) ? { ...R, [V]: G } : { ...R, [V]: A(M.properties[V], L, G) };
      }, {});
      if (!n.TypeGuard.TSchema(M.additionalProperties))
        return Y(M, U);
      const w = M.additionalProperties, b = Object.entries(U).reduce((R, [V, G]) => {
        return V in M.properties ? { ...R, [V]: G } : { ...R, [V]: A(w, L, G) };
      }, {});
      return Y(M, b);
    }
    function J(M, L, O) {
      if (!(0, l0.IsPlainObject)(O))
        return Y(M, O);
      const U = Object.getOwnPropertyNames(M.patternProperties)[0], w = M.patternProperties[U], b = new RegExp(U), R = Object.entries(O).reduce((h, [o, $0]) => {
        return !b.test(o) ? { ...h, [o]: $0 } : { ...h, [o]: A(w, L, $0) };
      }, {});
      if (!n.TypeGuard.TSchema(M.additionalProperties))
        return Y(M, R);
      const V = M.additionalProperties, G = Object.entries(R).reduce((h, [o, $0]) => {
        return b.test(o) ? { ...h, [o]: $0 } : { ...h, [o]: A(V, L, $0) };
      }, {});
      return Y(M, G);
    }
    function q(M, L, O) {
      const U = (0, h1.Deref)(M, L), w = A(U, L, O);
      return Y(M, w);
    }
    function F(M, L, O) {
      const U = (0, h1.Deref)(M, L), w = A(U, L, O);
      return Y(M, w);
    }
    function D(M, L, O) {
      const U = (0, l0.IsArray)(M.items) ? M.items.map((w, b) => A(w, L, O[b])) : [];
      return Y(M, U);
    }
    function K(M, L, O) {
      const U = Y(M, O);
      for (let w of M.anyOf) {
        if (!I(w, L, U))
          continue;
        return A(w, L, U);
      }
      return U;
    }
    function A(M, L, O) {
      const U = typeof M.$id === "string" ? [...L, M] : L, w = M;
      switch (M[n.Kind]) {
        case "Array":
          return W(w, U, O);
        case "Intersect":
          return X(w, U, O);
        case "Not":
          return Z(w, U, O);
        case "Object":
          return Q(w, U, O);
        case "Record":
          return J(w, U, O);
        case "Ref":
          return q(w, U, O);
        case "Symbol":
          return Y(w, O);
        case "This":
          return F(w, U, O);
        case "Tuple":
          return D(w, U, O);
        case "Union":
          return K(w, U, O);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Constructor":
        case "Date":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Y(w, O);
        default:
          if (!n.TypeRegistry.Has(w[n.Kind]))
            throw new q$(w);
          return Y(w, O);
      }
    }
    let I = () => false;
    function j(M, L, O, U) {
      return I = U, A(M, L, O);
    }
    $.Decode = j;
  })(oY || (sY.DecodeTransform = oY = {}));
  var cY;
  (function($) {
    function Y(M, L) {
      try {
        return n.TypeGuard.TTransform(M) ? M[n.Transform].Encode(L) : L;
      } catch (O) {
        throw new a8(M, L, O);
      }
    }
    function W(M, L, O) {
      return Y(M, O).map((w) => A(M.items, L, w));
    }
    function X(M, L, O) {
      const U = Y(M, O);
      if (!(0, l0.IsPlainObject)(O) || (0, l0.IsValueType)(O))
        return U;
      const w = n.KeyResolver.ResolveKeys(M, { includePatterns: false }), b = Object.entries(U).reduce((R, [V, G]) => {
        return !w.includes(V) ? { ...R, [V]: G } : { ...R, [V]: Y(n.IndexedAccessor.Resolve(M, [V]), G) };
      }, {});
      if (!n.TypeGuard.TTransform(M.unevaluatedProperties))
        return Y(M, b);
      return Object.entries(b).reduce((R, [V, G]) => {
        return w.includes(V) ? { ...R, [V]: G } : { ...R, [V]: Y(M.unevaluatedProperties, G) };
      }, {});
    }
    function Z(M, L, O) {
      const U = Y(M, O);
      return Y(M.not, U);
    }
    function Q(M, L, O) {
      const U = Y(M, O);
      if (!(0, l0.IsPlainObject)(O))
        return U;
      const w = Object.entries(U).reduce((R, [V, G]) => {
        return !(V in M.properties) ? { ...R, [V]: G } : { ...R, [V]: A(M.properties[V], L, G) };
      }, {});
      if (!n.TypeGuard.TSchema(M.additionalProperties))
        return w;
      const b = M.additionalProperties;
      return Object.entries(w).reduce((R, [V, G]) => {
        return V in M.properties ? { ...R, [V]: G } : { ...R, [V]: A(b, L, G) };
      }, {});
    }
    function J(M, L, O) {
      const U = Y(M, O);
      if (!(0, l0.IsPlainObject)(O))
        return U;
      const w = Object.getOwnPropertyNames(M.patternProperties)[0], b = M.patternProperties[w], R = new RegExp(w), V = Object.entries(U).reduce((h, [o, $0]) => {
        return !R.test(o) ? { ...h, [o]: $0 } : { ...h, [o]: A(b, L, $0) };
      }, {});
      if (!n.TypeGuard.TSchema(M.additionalProperties))
        return Y(M, V);
      const G = M.additionalProperties;
      return Object.entries(V).reduce((h, [o, $0]) => {
        return R.test(o) ? { ...h, [o]: $0 } : { ...h, [o]: A(G, L, $0) };
      }, {});
    }
    function q(M, L, O) {
      const U = (0, h1.Deref)(M, L), w = A(U, L, O);
      return Y(M, w);
    }
    function F(M, L, O) {
      const U = (0, h1.Deref)(M, L), w = A(U, L, O);
      return Y(M, w);
    }
    function D(M, L, O) {
      const U = Y(M, O);
      return (0, l0.IsArray)(M.items) ? M.items.map((w, b) => A(w, L, U[b])) : [];
    }
    function K(M, L, O) {
      for (let U of M.anyOf) {
        if (!I(U, L, O))
          continue;
        const w = A(U, L, O);
        return Y(M, w);
      }
      return Y(M, O);
    }
    function A(M, L, O) {
      const U = typeof M.$id === "string" ? [...L, M] : L, w = M;
      switch (M[n.Kind]) {
        case "Array":
          return W(w, U, O);
        case "Intersect":
          return X(w, U, O);
        case "Not":
          return Z(w, U, O);
        case "Object":
          return Q(w, U, O);
        case "Record":
          return J(w, U, O);
        case "Ref":
          return q(w, U, O);
        case "This":
          return F(w, U, O);
        case "Tuple":
          return D(w, U, O);
        case "Union":
          return K(w, U, O);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Constructor":
        case "Date":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "Symbol":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Y(w, O);
        default:
          if (!n.TypeRegistry.Has(w[n.Kind]))
            throw new q$(w);
          return Y(w, O);
      }
    }
    let I = () => false;
    function j(M, L, O, U) {
      return I = U, A(M, L, O);
    }
    $.Encode = j;
  })(cY || (sY.EncodeTransform = cY = {}));
});
var JW = J0((ZW) => {
  Object.defineProperty(ZW, "__esModule", { value: true });
  ZW.Value = undefined;
  var aY = I$(), d9 = jY(), y9 = W$(), v9 = SY(), eY = dY(), p9 = i1(), $W = nY(), YW = u8(), x$ = J$(), WW = V8(), k$ = e8(), XW;
  (function($) {
    function Y(...M) {
      return eY.Cast.apply(eY, M);
    }
    $.Cast = Y;
    function W(...M) {
      return YW.Create.apply(YW, M);
    }
    $.Create = W;
    function X(...M) {
      return x$.Check.apply(x$, M);
    }
    $.Check = X;
    function Z(...M) {
      return $W.Convert.apply($W, M);
    }
    $.Convert = Z;
    function Q(M) {
      return p9.Clone(M);
    }
    $.Clone = Q;
    function J(...M) {
      const [L, O, U] = M.length === 3 ? [M[0], M[1], M[2]] : [M[0], [], M[1]];
      if (!X(L, O, U))
        throw new k$.TransformDecodeCheckError(L, U, F(L, O, U).First());
      return k$.DecodeTransform.Decode(L, O, U, x$.Check);
    }
    $.Decode = J;
    function q(...M) {
      const [L, O, U] = M.length === 3 ? [M[0], M[1], M[2]] : [M[0], [], M[1]], w = k$.EncodeTransform.Encode(L, O, U, x$.Check);
      if (!X(L, O, w))
        throw new k$.TransformEncodeCheckError(L, U, F(L, O, U).First());
      return w;
    }
    $.Encode = q;
    function F(...M) {
      return aY.Errors.apply(aY, M);
    }
    $.Errors = F;
    function D(M, L) {
      return v9.Equal(M, L);
    }
    $.Equal = D;
    function K(M, L) {
      return WW.Diff(M, L);
    }
    $.Diff = K;
    function A(M) {
      return y9.Hash(M);
    }
    $.Hash = A;
    function I(M, L) {
      return WW.Patch(M, L);
    }
    $.Patch = I;
    function j(M, L) {
      d9.Mutate(M, L);
    }
    $.Mutate = j;
  })(XW || (ZW.Value = XW = {}));
});
var $6 = J0((Y1) => {
  Object.defineProperty(Y1, "__esModule", { value: true });
  Y1.Value = Y1.ValuePointer = Y1.Delete = Y1.Update = Y1.Insert = Y1.Edit = Y1.ValueErrorIterator = Y1.ValueErrorType = undefined;
  var zW = I$();
  Object.defineProperty(Y1, "ValueErrorType", { enumerable: true, get: function() {
    return zW.ValueErrorType;
  } });
  Object.defineProperty(Y1, "ValueErrorIterator", { enumerable: true, get: function() {
    return zW.ValueErrorIterator;
  } });
  var g$ = V8();
  Object.defineProperty(Y1, "Edit", { enumerable: true, get: function() {
    return g$.Edit;
  } });
  Object.defineProperty(Y1, "Insert", { enumerable: true, get: function() {
    return g$.Insert;
  } });
  Object.defineProperty(Y1, "Update", { enumerable: true, get: function() {
    return g$.Update;
  } });
  Object.defineProperty(Y1, "Delete", { enumerable: true, get: function() {
    return g$.Delete;
  } });
  var i9 = b$();
  Object.defineProperty(Y1, "ValuePointer", { enumerable: true, get: function() {
    return i9.ValuePointer;
  } });
  var m9 = JW();
  Object.defineProperty(Y1, "Value", { enumerable: true, get: function() {
    return m9.Value;
  } });
});
var FW = J0((MW) => {
  Object.defineProperty(MW, "__esModule", { value: true });
  MW.TypeCompiler = MW.Policy = MW.TypeCompilerTypeGuardError = MW.TypeCompilerUnknownTypeError = MW.TypeCheck = undefined;
  var U$ = e8(), c = V0(), r9 = Y$(), F$ = E$(), a9 = D1(), e9 = W$(), M0 = f0();

  class Q6 {
    constructor($, Y, W, X) {
      this.schema = $, this.references = Y, this.checkFunc = W, this.code = X, this.hasTransform = U$.HasTransform.Has($, Y);
    }
    Code() {
      return this.code;
    }
    Errors($) {
      return (0, r9.Errors)(this.schema, this.references, $);
    }
    Check($) {
      return this.checkFunc($);
    }
    Decode($) {
      if (!this.checkFunc($))
        throw new U$.TransformDecodeCheckError(this.schema, $, this.Errors($).First());
      return this.hasTransform ? U$.DecodeTransform.Decode(this.schema, this.references, $, (Y, W, X) => this.Check(X)) : $;
    }
    Encode($) {
      const Y = this.hasTransform ? U$.EncodeTransform.Encode(this.schema, this.references, $, (W, X, Z) => this.Check(Z)) : $;
      if (!this.checkFunc(Y))
        throw new U$.TransformEncodeCheckError(this.schema, $, this.Errors($).First());
      return Y;
    }
  }
  MW.TypeCheck = Q6;
  var N1;
  (function($) {
    function Y(Q) {
      return Q === 36;
    }
    $.DollarSign = Y;
    function W(Q) {
      return Q === 95;
    }
    $.IsUnderscore = W;
    function X(Q) {
      return Q >= 65 && Q <= 90 || Q >= 97 && Q <= 122;
    }
    $.IsAlpha = X;
    function Z(Q) {
      return Q >= 48 && Q <= 57;
    }
    $.IsNumeric = Z;
  })(N1 || (N1 = {}));
  var v$;
  (function($) {
    function Y(Q) {
      if (Q.length === 0)
        return false;
      return N1.IsNumeric(Q.charCodeAt(0));
    }
    function W(Q) {
      if (Y(Q))
        return false;
      for (let J = 0;J < Q.length; J++) {
        const q = Q.charCodeAt(J);
        if (!(N1.IsAlpha(q) || N1.IsNumeric(q) || N1.DollarSign(q) || N1.IsUnderscore(q)))
          return false;
      }
      return true;
    }
    function X(Q) {
      return Q.replace(/'/g, "\\'");
    }
    function Z(Q, J) {
      return W(J) ? `${Q}.${J}` : `${Q}['${X(J)}']`;
    }
    $.Encode = Z;
  })(v$ || (v$ = {}));
  var X6;
  (function($) {
    function Y(W) {
      const X = [];
      for (let Z = 0;Z < W.length; Z++) {
        const Q = W.charCodeAt(Z);
        if (N1.IsNumeric(Q) || N1.IsAlpha(Q))
          X.push(W.charAt(Z));
        else
          X.push(`_${Q}_`);
      }
      return X.join("").replace(/__/g, "_");
    }
    $.Encode = Y;
  })(X6 || (X6 = {}));
  var Z6;
  (function($) {
    function Y(W) {
      return W.replace(/'/g, "\\'");
    }
    $.Escape = Y;
  })(Z6 || (Z6 = {}));

  class J6 extends M0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  MW.TypeCompilerUnknownTypeError = J6;

  class p$ extends M0.TypeBoxError {
    constructor($) {
      super("Preflight validation check failed to guard for the given schema");
      this.schema = $;
    }
  }
  MW.TypeCompilerTypeGuardError = p$;
  var L1;
  (function($) {
    function Y(J, q, F) {
      return F$.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${q}' in ${J} ? ${F} : true)` : `(${v$.Encode(J, q)} !== undefined ? ${F} : true)`;
    }
    $.IsExactOptionalProperty = Y;
    function W(J) {
      return !F$.TypeSystemPolicy.AllowArrayObject ? `(typeof ${J} === 'object' && ${J} !== null && !Array.isArray(${J}))` : `(typeof ${J} === 'object' && ${J} !== null)`;
    }
    $.IsObjectLike = W;
    function X(J) {
      return !F$.TypeSystemPolicy.AllowArrayObject ? `(typeof ${J} === 'object' && ${J} !== null && !Array.isArray(${J}) && !(${J} instanceof Date) && !(${J} instanceof Uint8Array))` : `(typeof ${J} === 'object' && ${J} !== null && !(${J} instanceof Date) && !(${J} instanceof Uint8Array))`;
    }
    $.IsRecordLike = X;
    function Z(J) {
      return !F$.TypeSystemPolicy.AllowNaN ? `(typeof ${J} === 'number' && Number.isFinite(${J}))` : `typeof ${J} === 'number'`;
    }
    $.IsNumberLike = Z;
    function Q(J) {
      return F$.TypeSystemPolicy.AllowNullVoid ? `(${J} === undefined || ${J} === null)` : `${J} === undefined`;
    }
    $.IsVoidLike = Q;
  })(L1 || (MW.Policy = L1 = {}));
  var NW;
  (function($) {
    function Y(P) {
      return P[M0.Kind] === "Any" || P[M0.Kind] === "Unknown";
    }
    function* W(P, _, S) {
      yield "true";
    }
    function* X(P, _, S) {
      yield `Array.isArray(${S})`;
      const [p, f] = [H0("value", "any"), H0("acc", "number")];
      if ((0, c.IsNumber)(P.maxItems))
        yield `${S}.length <= ${P.maxItems}`;
      if ((0, c.IsNumber)(P.minItems))
        yield `${S}.length >= ${P.minItems}`;
      const T = E(P.items, _, "value");
      if (yield `${S}.every((${p}) => ${T})`, M0.TypeGuard.TSchema(P.contains) || (0, c.IsNumber)(P.minContains) || (0, c.IsNumber)(P.maxContains)) {
        const W0 = M0.TypeGuard.TSchema(P.contains) ? P.contains : M0.Type.Never(), K0 = E(W0, _, "value"), X0 = (0, c.IsNumber)(P.minContains) ? [`(count >= ${P.minContains})`] : [], N = (0, c.IsNumber)(P.maxContains) ? [`(count <= ${P.maxContains})`] : [], l = `const count = ${S}.reduce((${f}, ${p}) => ${K0} ? acc + 1 : acc, 0)`, S0 = ["(count > 0)", ...X0, ...N].join(" && ");
        yield `((${p}) => { ${l}; return ${S0}})(${S})`;
      }
      if (P.uniqueItems === true)
        yield `((${p}) => { const set = new Set(); for(const element of value) { const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true } )(${S})`;
    }
    function* Z(P, _, S) {
      yield `(typeof value === 'object' && Symbol.asyncIterator in ${S})`;
    }
    function* Q(P, _, S) {
      if (yield `(typeof ${S} === 'bigint')`, (0, c.IsBigInt)(P.exclusiveMaximum))
        yield `${S} < BigInt(${P.exclusiveMaximum})`;
      if ((0, c.IsBigInt)(P.exclusiveMinimum))
        yield `${S} > BigInt(${P.exclusiveMinimum})`;
      if ((0, c.IsBigInt)(P.maximum))
        yield `${S} <= BigInt(${P.maximum})`;
      if ((0, c.IsBigInt)(P.minimum))
        yield `${S} >= BigInt(${P.minimum})`;
      if ((0, c.IsBigInt)(P.multipleOf))
        yield `(${S} % BigInt(${P.multipleOf})) === 0`;
    }
    function* J(P, _, S) {
      yield `(typeof ${S} === 'boolean')`;
    }
    function* q(P, _, S) {
      yield* g0(P.returns, _, `${S}.prototype`);
    }
    function* F(P, _, S) {
      if (yield `(${S} instanceof Date) && Number.isFinite(${S}.getTime())`, (0, c.IsNumber)(P.exclusiveMaximumTimestamp))
        yield `${S}.getTime() < ${P.exclusiveMaximumTimestamp}`;
      if ((0, c.IsNumber)(P.exclusiveMinimumTimestamp))
        yield `${S}.getTime() > ${P.exclusiveMinimumTimestamp}`;
      if ((0, c.IsNumber)(P.maximumTimestamp))
        yield `${S}.getTime() <= ${P.maximumTimestamp}`;
      if ((0, c.IsNumber)(P.minimumTimestamp))
        yield `${S}.getTime() >= ${P.minimumTimestamp}`;
      if ((0, c.IsNumber)(P.multipleOfTimestamp))
        yield `(${S}.getTime() % ${P.multipleOfTimestamp}) === 0`;
    }
    function* D(P, _, S) {
      yield `(typeof ${S} === 'function')`;
    }
    function* K(P, _, S) {
      if (yield `(typeof ${S} === 'number' && Number.isInteger(${S}))`, (0, c.IsNumber)(P.exclusiveMaximum))
        yield `${S} < ${P.exclusiveMaximum}`;
      if ((0, c.IsNumber)(P.exclusiveMinimum))
        yield `${S} > ${P.exclusiveMinimum}`;
      if ((0, c.IsNumber)(P.maximum))
        yield `${S} <= ${P.maximum}`;
      if ((0, c.IsNumber)(P.minimum))
        yield `${S} >= ${P.minimum}`;
      if ((0, c.IsNumber)(P.multipleOf))
        yield `(${S} % ${P.multipleOf}) === 0`;
    }
    function* A(P, _, S) {
      const p = P.allOf.map((f) => E(f, _, S)).join(" && ");
      if (P.unevaluatedProperties === false) {
        const f = u(`${new RegExp(M0.KeyResolver.ResolvePattern(P))};`), T = `Object.getOwnPropertyNames(${S}).every(key => ${f}.test(key))`;
        yield `(${p} && ${T})`;
      } else if (M0.TypeGuard.TSchema(P.unevaluatedProperties)) {
        const f = u(`${new RegExp(M0.KeyResolver.ResolvePattern(P))};`), T = `Object.getOwnPropertyNames(${S}).every(key => ${f}.test(key) || ${E(P.unevaluatedProperties, _, `${S}[key]`)})`;
        yield `(${p} && ${T})`;
      } else
        yield `(${p})`;
    }
    function* I(P, _, S) {
      yield `(typeof value === 'object' && Symbol.iterator in ${S})`;
    }
    function* j(P, _, S) {
      if (typeof P.const === "number" || typeof P.const === "boolean")
        yield `(${S} === ${P.const})`;
      else
        yield `(${S} === '${Z6.Escape(P.const)}')`;
    }
    function* M(P, _, S) {
      yield "false";
    }
    function* L(P, _, S) {
      yield `(!${E(P.not, _, S)})`;
    }
    function* O(P, _, S) {
      yield `(${S} === null)`;
    }
    function* U(P, _, S) {
      if (yield L1.IsNumberLike(S), (0, c.IsNumber)(P.exclusiveMaximum))
        yield `${S} < ${P.exclusiveMaximum}`;
      if ((0, c.IsNumber)(P.exclusiveMinimum))
        yield `${S} > ${P.exclusiveMinimum}`;
      if ((0, c.IsNumber)(P.maximum))
        yield `${S} <= ${P.maximum}`;
      if ((0, c.IsNumber)(P.minimum))
        yield `${S} >= ${P.minimum}`;
      if ((0, c.IsNumber)(P.multipleOf))
        yield `(${S} % ${P.multipleOf}) === 0`;
    }
    function* w(P, _, S) {
      if (yield L1.IsObjectLike(S), (0, c.IsNumber)(P.minProperties))
        yield `Object.getOwnPropertyNames(${S}).length >= ${P.minProperties}`;
      if ((0, c.IsNumber)(P.maxProperties))
        yield `Object.getOwnPropertyNames(${S}).length <= ${P.maxProperties}`;
      const p = Object.getOwnPropertyNames(P.properties);
      for (let f of p) {
        const T = v$.Encode(S, f), W0 = P.properties[f];
        if (P.required && P.required.includes(f)) {
          if (yield* g0(W0, _, T), M0.ExtendsUndefined.Check(W0) || Y(W0))
            yield `('${f}' in ${S})`;
        } else {
          const K0 = E(W0, _, T);
          yield L1.IsExactOptionalProperty(S, f, K0);
        }
      }
      if (P.additionalProperties === false)
        if (P.required && P.required.length === p.length)
          yield `Object.getOwnPropertyNames(${S}).length === ${p.length}`;
        else {
          const f = `[${p.map((T) => `'${T}'`).join(", ")}]`;
          yield `Object.getOwnPropertyNames(${S}).every(key => ${f}.includes(key))`;
        }
      if (typeof P.additionalProperties === "object") {
        const f = E(P.additionalProperties, _, `${S}[key]`), T = `[${p.map((W0) => `'${W0}'`).join(", ")}]`;
        yield `(Object.getOwnPropertyNames(${S}).every(key => ${T}.includes(key) || ${f}))`;
      }
    }
    function* b(P, _, S) {
      yield `(typeof value === 'object' && typeof ${S}.then === 'function')`;
    }
    function* R(P, _, S) {
      if (yield L1.IsRecordLike(S), (0, c.IsNumber)(P.minProperties))
        yield `Object.getOwnPropertyNames(${S}).length >= ${P.minProperties}`;
      if ((0, c.IsNumber)(P.maxProperties))
        yield `Object.getOwnPropertyNames(${S}).length <= ${P.maxProperties}`;
      const [p, f] = Object.entries(P.patternProperties)[0], T = u(`${new RegExp(p)}`), W0 = E(f, _, "value"), K0 = M0.TypeGuard.TSchema(P.additionalProperties) ? E(P.additionalProperties, _, S) : P.additionalProperties === false ? "false" : "true", X0 = `(${T}.test(key) ? ${W0} : ${K0})`;
      yield `(Object.entries(${S}).every(([key, value]) => ${X0}))`;
    }
    function* V(P, _, S) {
      const p = (0, a9.Deref)(P, _);
      if (N0.functions.has(P.$ref))
        return yield `${d(P.$ref)}(${S})`;
      yield* g0(p, _, S);
    }
    function* G(P, _, S) {
      if (yield `(typeof ${S} === 'string')`, (0, c.IsNumber)(P.maxLength))
        yield `${S}.length <= ${P.maxLength}`;
      if ((0, c.IsNumber)(P.minLength))
        yield `${S}.length >= ${P.minLength}`;
      if (P.pattern !== undefined)
        yield `${u(`${new RegExp(P.pattern)};`)}.test(${S})`;
      if (P.format !== undefined)
        yield `format('${P.format}', ${S})`;
    }
    function* h(P, _, S) {
      yield `(typeof ${S} === 'symbol')`;
    }
    function* o(P, _, S) {
      yield `(typeof ${S} === 'string')`, yield `${u(`${new RegExp(P.pattern)};`)}.test(${S})`;
    }
    function* $0(P, _, S) {
      yield `${d(P.$ref)}(${S})`;
    }
    function* n0(P, _, S) {
      if (yield `Array.isArray(${S})`, P.items === undefined)
        return yield `${S}.length === 0`;
      yield `(${S}.length === ${P.maxItems})`;
      for (let p = 0;p < P.items.length; p++)
        yield `${E(P.items[p], _, `${S}[${p}]`)}`;
    }
    function* w0(P, _, S) {
      yield `${S} === undefined`;
    }
    function* k0(P, _, S) {
      yield `(${P.anyOf.map((f) => E(f, _, S)).join(" || ")})`;
    }
    function* F0(P, _, S) {
      if (yield `${S} instanceof Uint8Array`, (0, c.IsNumber)(P.maxByteLength))
        yield `(${S}.length <= ${P.maxByteLength})`;
      if ((0, c.IsNumber)(P.minByteLength))
        yield `(${S}.length >= ${P.minByteLength})`;
    }
    function* v0(P, _, S) {
      yield "true";
    }
    function* z0(P, _, S) {
      yield L1.IsVoidLike(S);
    }
    function* p0(P, _, S) {
      const p = N0.instances.size;
      N0.instances.set(p, P), yield `kind('${P[M0.Kind]}', ${p}, ${S})`;
    }
    function* g0(P, _, S, p = true) {
      const f = (0, c.IsString)(P.$id) ? [..._, P] : _, T = P;
      if (p && (0, c.IsString)(P.$id)) {
        const W0 = d(P.$id);
        if (N0.functions.has(W0))
          return yield `${W0}(${S})`;
        else {
          const K0 = t(W0, P, _, "value", false);
          return N0.functions.set(W0, K0), yield `${W0}(${S})`;
        }
      }
      switch (T[M0.Kind]) {
        case "Any":
          return yield* W(T, f, S);
        case "Array":
          return yield* X(T, f, S);
        case "AsyncIterator":
          return yield* Z(T, f, S);
        case "BigInt":
          return yield* Q(T, f, S);
        case "Boolean":
          return yield* J(T, f, S);
        case "Constructor":
          return yield* q(T, f, S);
        case "Date":
          return yield* F(T, f, S);
        case "Function":
          return yield* D(T, f, S);
        case "Integer":
          return yield* K(T, f, S);
        case "Intersect":
          return yield* A(T, f, S);
        case "Iterator":
          return yield* I(T, f, S);
        case "Literal":
          return yield* j(T, f, S);
        case "Never":
          return yield* M(T, f, S);
        case "Not":
          return yield* L(T, f, S);
        case "Null":
          return yield* O(T, f, S);
        case "Number":
          return yield* U(T, f, S);
        case "Object":
          return yield* w(T, f, S);
        case "Promise":
          return yield* b(T, f, S);
        case "Record":
          return yield* R(T, f, S);
        case "Ref":
          return yield* V(T, f, S);
        case "String":
          return yield* G(T, f, S);
        case "Symbol":
          return yield* h(T, f, S);
        case "TemplateLiteral":
          return yield* o(T, f, S);
        case "This":
          return yield* $0(T, f, S);
        case "Tuple":
          return yield* n0(T, f, S);
        case "Undefined":
          return yield* w0(T, f, S);
        case "Union":
          return yield* k0(T, f, S);
        case "Uint8Array":
          return yield* F0(T, f, S);
        case "Unknown":
          return yield* v0(T, f, S);
        case "Void":
          return yield* z0(T, f, S);
        default:
          if (!M0.TypeRegistry.Has(T[M0.Kind]))
            throw new J6(P);
          return yield* p0(T, f, S);
      }
    }
    const N0 = { language: "javascript", functions: new Map, variables: new Map, instances: new Map };
    function E(P, _, S, p = true) {
      return `(${[...g0(P, _, S, p)].join(" && ")})`;
    }
    function d(P) {
      return `check_${X6.Encode(P)}`;
    }
    function u(P) {
      const _ = `local_${N0.variables.size}`;
      return N0.variables.set(_, `const ${_} = ${P}`), _;
    }
    function t(P, _, S, p, f = true) {
      const [T, W0] = ["\n", (l) => "".padStart(l, " ")], K0 = H0("value", "any"), X0 = E0("boolean"), N = [...g0(_, S, p, f)].map((l) => `${W0(4)}${l}`).join(` &&${T}`);
      return `function ${P}(${K0})${X0} {${T}${W0(2)}return (${T}${N}${T}${W0(2)})\n}`;
    }
    function H0(P, _) {
      const S = N0.language === "typescript" ? `: ${_}` : "";
      return `${P}${S}`;
    }
    function E0(P) {
      return N0.language === "typescript" ? `: ${P}` : "";
    }
    function D0(P, _, S) {
      const p = t("check", P, _, "value"), f = H0("value", "any"), T = E0("boolean"), W0 = [...N0.functions.values()], K0 = [...N0.variables.values()], X0 = (0, c.IsString)(P.$id) ? `return function check(${f})${T} {\n  return ${d(P.$id)}(value)\n}` : `return ${p}`;
      return [...K0, ...W0, X0].join("\n");
    }
    function a(...P) {
      const _ = { language: "javascript" }, [S, p, f] = P.length === 2 && (0, c.IsArray)(P[1]) ? [P[0], P[1], _] : P.length === 2 && !(0, c.IsArray)(P[1]) ? [P[0], [], P[1]] : P.length === 3 ? [P[0], P[1], P[2]] : P.length === 1 ? [P[0], [], _] : [null, [], _];
      if (N0.language = f.language, N0.variables.clear(), N0.functions.clear(), N0.instances.clear(), !M0.TypeGuard.TSchema(S))
        throw new p$(S);
      for (let T of p)
        if (!M0.TypeGuard.TSchema(T))
          throw new p$(T);
      return D0(S, p, f);
    }
    $.Code = a;
    function A1(P, _ = []) {
      const S = a(P, _, { language: "javascript" }), p = globalThis.Function("kind", "format", "hash", S), f = new Map(N0.instances);
      function T(N, l, S0) {
        if (!M0.TypeRegistry.Has(N) || !f.has(l))
          return false;
        const l$ = M0.TypeRegistry.Get(N), t$ = f.get(l);
        return l$(t$, S0);
      }
      function W0(N, l) {
        if (!M0.FormatRegistry.Has(N))
          return false;
        return M0.FormatRegistry.Get(N)(l);
      }
      function K0(N) {
        return (0, e9.Hash)(N);
      }
      const X0 = p(T, W0, K0);
      return new Q6(P, _, X0, S);
    }
    $.Compile = A1;
  })(NW || (MW.TypeCompiler = NW = {}));
});
var AW = J0((t0) => {
  var Z7 = t0 && t0.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), Q7 = t0 && t0.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        Z7(Y, $, W);
  };
  Object.defineProperty(t0, "__esModule", { value: true });
  t0.ValueErrorIterator = t0.ValueErrorType = undefined;
  var BW = I$();
  Object.defineProperty(t0, "ValueErrorType", { enumerable: true, get: function() {
    return BW.ValueErrorType;
  } });
  Object.defineProperty(t0, "ValueErrorIterator", { enumerable: true, get: function() {
    return BW.ValueErrorIterator;
  } });
  Q7(FW(), t0);
});
var bW = J0((K5, IW) => {
  var H7 = function($) {
    var Y = $.indexOf("%");
    if (Y === -1)
      return $;
    var W = $.length, X = "", Z = 0, Q = 0, J = Y, q = LW;
    while (Y > -1 && Y < W) {
      var F = CW($[Y + 1], 4), D = CW($[Y + 2], 0), K = F | D, A = F6[K];
      if (q = F6[256 + q + A], Q = Q << 6 | K & F6[364 + A], q === LW)
        X += $.slice(Z, J), X += Q <= 65535 ? String.fromCharCode(Q) : String.fromCharCode(55232 + (Q >> 10), 56320 + (Q & 1023)), Q = 0, Z = Y + 3, Y = J = $.indexOf("%", Z);
      else if (q === z7)
        return null;
      else {
        if (Y += 3, Y < W && $.charCodeAt(Y) === 37)
          continue;
        return null;
      }
    }
    return X + $.slice(Z);
  }, CW = function($, Y) {
    var W = q7[$];
    return W === undefined ? 255 : W << Y;
  }, LW = 12, z7 = 0, F6 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7], q7 = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  IW.exports = H7;
});
var VW = J0((j5, EW) => {
  var N7 = function($) {
    const Y = new _W;
    if (typeof $ !== "string")
      return Y;
    let W = $.length, X = "", Z = "", Q = -1, J = -1, q = false, F = false, D = false, K = false, A = false, I = 0;
    for (let j = 0;j < W + 1; j++)
      if (I = j !== W ? $.charCodeAt(j) : 38, I === 38) {
        if (A = J > Q, !A)
          J = j;
        if (X = $.slice(Q + 1, J), A || X.length > 0) {
          if (D)
            X = X.replace(GW, " ");
          if (q)
            X = RW(X) || X;
          if (A) {
            if (Z = $.slice(J + 1, j), K)
              Z = Z.replace(GW, " ");
            if (F)
              Z = RW(Z) || Z;
          }
          const M = Y[X];
          if (M === undefined)
            Y[X] = Z;
          else if (M.pop)
            M.push(Z);
          else
            Y[X] = [M, Z];
        }
        Z = "", Q = j, J = j, q = false, F = false, D = false, K = false;
      } else if (I === 61)
        if (J <= Q)
          J = j;
        else
          F = true;
      else if (I === 43)
        if (J > Q)
          K = true;
        else
          D = true;
      else if (I === 37)
        if (J > Q)
          F = true;
        else
          q = true;
    return Y;
  }, RW = bW(), GW = /\+/g, _W = function() {
  };
  _W.prototype = Object.create(null);
  EW.exports = N7;
});
var kW = J0((P5, xW) => {
  var U7 = function($) {
    const Y = $.length;
    if (Y === 0)
      return "";
    let W = "", X = 0, Z = 0;
    $:
      for (;Z < Y; Z++) {
        let Q = $.charCodeAt(Z);
        while (Q < 128) {
          if (M7[Q] !== 1) {
            if (X < Z)
              W += $.slice(X, Z);
            X = Z + 1, W += W1[Q];
          }
          if (++Z === Y)
            break $;
          Q = $.charCodeAt(Z);
        }
        if (X < Z)
          W += $.slice(X, Z);
        if (Q < 2048) {
          X = Z + 1, W += W1[192 | Q >> 6] + W1[128 | Q & 63];
          continue;
        }
        if (Q < 55296 || Q >= 57344) {
          X = Z + 1, W += W1[224 | Q >> 12] + W1[128 | Q >> 6 & 63] + W1[128 | Q & 63];
          continue;
        }
        if (++Z, Z >= Y)
          throw new Error("URI malformed");
        const J = $.charCodeAt(Z) & 1023;
        X = Z + 1, Q = 65536 + ((Q & 1023) << 10 | J), W += W1[240 | Q >> 18] + W1[128 | Q >> 12 & 63] + W1[128 | Q >> 6 & 63] + W1[128 | Q & 63];
      }
    if (X === 0)
      return $;
    if (X < Y)
      return W + $.slice(X);
    return W;
  }, W1 = Array.from({ length: 256 }, ($, Y) => "%" + ((Y < 16 ? "0" : "") + Y.toString(16)).toUpperCase()), M7 = new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0]);
  xW.exports = { encodeString: U7 };
});
var TW = J0((O5, fW) => {
  var gW = function($) {
    const Y = typeof $;
    if (Y === "string")
      return B6($);
    else if (Y === "bigint")
      return $.toString();
    else if (Y === "boolean")
      return $ ? "true" : "false";
    else if (Y === "number" && Number.isFinite($))
      return $ < 1000000000000000000000 ? "" + $ : B6("" + $);
    return "";
  }, F7 = function($) {
    let Y = "";
    if ($ === null || typeof $ !== "object")
      return Y;
    const W = "&", X = Object.keys($), Z = X.length;
    let Q = 0;
    for (let J = 0;J < Z; J++) {
      const q = X[J], F = $[q], D = B6(q) + "=";
      if (J)
        Y += W;
      if (Array.isArray(F)) {
        Q = F.length;
        for (let K = 0;K < Q; K++) {
          if (K)
            Y += W;
          Y += D, Y += gW(F[K]);
        }
      } else
        Y += D, Y += gW(F);
    }
    return Y;
  }, { encodeString: B6 } = kW();
  fW.exports = F7;
});
var A6 = J0((S5, D$) => {
  var dW = VW(), yW = TW(), vW = { parse: dW, stringify: yW };
  D$.exports = vW;
  D$.exports.default = vW;
  D$.exports.parse = dW;
  D$.exports.stringify = yW;
});
var _1 = ($, Y) => ({ part: $, store: null, inert: Y !== undefined ? new Map(Y.map((W) => [W.part.charCodeAt(0), W])) : null, params: null, wildcardStore: null });
var L6 = ($, Y) => ({ ...$, part: Y });
var C6 = ($) => ({ paramName: $, store: null, inert: null });

class E1 {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
  add($, Y, W) {
    let X;
    if (typeof Y != "string")
      throw TypeError("Route path must be a string");
    Y === "" ? Y = "/" : Y[0] !== "/" && (Y = `/${Y}`), this.history.push([$, Y, W]);
    let Z = Y[Y.length - 1] === "*";
    Z && (Y = Y.slice(0, -1));
    let Q = Y.split(E1.regex.static), J = Y.match(E1.regex.params) || [];
    Q[Q.length - 1] === "" && Q.pop(), X = this.root[$] ? this.root[$] : this.root[$] = _1("/");
    let q = 0;
    for (let F = 0;F < Q.length; ++F) {
      let D = Q[F];
      if (F > 0) {
        let K = J[q++].slice(1);
        if (X.params === null)
          X.params = C6(K);
        else if (X.params.paramName !== K)
          throw Error(`Cannot create route "${Y}" with parameter "${K}" because a route already exists with a different parameter name ("${X.params.paramName}") in the same location`);
        let A = X.params;
        if (A.inert === null) {
          X = A.inert = _1(D);
          continue;
        }
        X = A.inert;
      }
      for (let K = 0;; ) {
        if (K === D.length) {
          if (K < X.part.length) {
            let A = L6(X, X.part.slice(K));
            Object.assign(X, _1(D, [A]));
          }
          break;
        }
        if (K === X.part.length) {
          if (X.inert === null)
            X.inert = new Map;
          else if (X.inert.has(D.charCodeAt(K))) {
            X = X.inert.get(D.charCodeAt(K)), D = D.slice(K), K = 0;
            continue;
          }
          let A = _1(D.slice(K));
          X.inert.set(D.charCodeAt(K), A), X = A;
          break;
        }
        if (D[K] !== X.part[K]) {
          let A = L6(X, X.part.slice(K)), I = _1(D.slice(K));
          Object.assign(X, _1(X.part.slice(0, K), [A, I])), X = I;
          break;
        }
        ++K;
      }
    }
    if (q < J.length) {
      let F = J[q], D = F.slice(1);
      if (X.params === null)
        X.params = C6(D);
      else if (X.params.paramName !== D)
        throw Error(`Cannot create route "${Y}" with parameter "${D}" because a route already exists with a different parameter name ("${X.params.paramName}") in the same location`);
      return X.params.store === null && (X.params.store = W), X.params.store;
    }
    return Z ? (X.wildcardStore === null && (X.wildcardStore = W), X.wildcardStore) : (X.store === null && (X.store = W), X.store);
  }
  find($, Y) {
    let W = this.root[$];
    return W ? r$(Y, Y.length, W, 0) : null;
  }
}
var r$ = ($, Y, W, X) => {
  let Z = W?.part, Q = X + Z.length;
  if (Z.length > 1) {
    if (Q > Y)
      return null;
    if (Z.length < 15) {
      for (let J = 1, q = X + 1;J < Z.length; ++J, ++q)
        if (Z.charCodeAt(J) !== $.charCodeAt(q))
          return null;
    } else if ($.substring(X, Q) !== Z)
      return null;
  }
  if (Q === Y)
    return W.store !== null ? { store: W.store, params: {} } : W.wildcardStore !== null ? { store: W.wildcardStore, params: { "*": "" } } : null;
  if (W.inert !== null) {
    let J = W.inert.get($.charCodeAt(Q));
    if (J !== undefined) {
      let q = r$($, Y, J, Q);
      if (q !== null)
        return q;
    }
  }
  if (W.params !== null) {
    let J = W.params, q = $.indexOf("/", Q);
    if (q !== Q) {
      if (q === -1 || q >= Y) {
        if (J.store !== null) {
          let F = {};
          return F[J.paramName] = $.substring(Q, Y), { store: J.store, params: F };
        }
      } else if (J.inert !== null) {
        let F = r$($, Y, J.inert, q);
        if (F !== null)
          return F.params[J.paramName] = $.substring(Q, q), F;
      }
    }
  }
  return W.wildcardStore !== null ? { store: W.wildcardStore, params: { "*": $.substring(Q, Y) } } : null;
};
var R6 = X1(b6(), 1);
var G6 = R6.default;
var _6 = ($, Y) => {
  return (W) => {
    const X = W.id;
    if (W.event === "request" && W.type === "begin") {
      const Z = () => {
        let M, L, O = -1;
        const U = [], w = [];
        let b = false;
        const R = new Promise((h) => {
          M = (o) => {
            if (b)
              return;
            else
              b = true;
            h(o);
          };
        });
        let V = false;
        const G = new Promise((h) => {
          L = (o) => {
            if (V)
              return;
            else
              V = true;
            if (O === -1)
              O = 0;
            for (;O < w.length; O++) {
              let $0;
              const n0 = { name: "anonymous", time: performance.now(), skip: true, end: new Promise((w0) => {
                w0($0);
              }), children: [] };
              $0 = performance.now(), U[O](n0);
            }
            h(o);
          };
        });
        return { signal: R, consumeChild(h) {
          switch (h.type) {
            case "begin":
              U[++O]({ name: h.name, time: h.time, skip: false, end: new Promise((o) => {
                w.push(o);
              }) });
              break;
            case "end":
              w[O](h.time);
              break;
          }
        }, consume(h) {
          switch (h.type) {
            case "begin":
              const o = [], $0 = h.unit ?? 0;
              for (let n0 = 0;n0 < $0; n0++) {
                let w0;
                o.push(new Promise((k0) => {
                  w0 = k0;
                })), U.push(w0);
              }
              M({ name: h.name, time: h.time, skip: false, end: G, children: o });
              break;
            case "end":
              L(h.time);
              break;
          }
        }, resolve() {
          if (b && V)
            return;
          let h;
          const o = { name: "anonymous", time: performance.now(), skip: true, end: new Promise(($0) => {
            $0(h);
          }), children: [] };
          h = performance.now(), M(o), L(h);
        } };
      }, Q = Z(), J = Z(), q = Z(), F = Z(), D = Z(), K = Z(), A = Z(), I = Z();
      Q.consume(W);
      const j = (M) => {
        if (M.id === X)
          switch (M.event) {
            case "request":
              Q.consume(M);
              break;
            case "request.unit":
              Q.consumeChild(M);
              break;
            case "parse":
              J.consume(M);
              break;
            case "parse.unit":
              J.consumeChild(M);
              break;
            case "transform":
              q.consume(M);
              break;
            case "transform.unit":
              q.consumeChild(M);
              break;
            case "beforeHandle":
              F.consume(M);
              break;
            case "beforeHandle.unit":
              F.consumeChild(M);
              break;
            case "handle":
              D.consume(M);
              break;
            case "afterHandle":
              K.consume(M);
              break;
            case "afterHandle.unit":
              K.consumeChild(M);
              break;
            case "error":
              A.consume(M);
              break;
            case "error.unit":
              A.consumeChild(M);
              break;
            case "response":
              if (M.type === "begin")
                Q.resolve(), J.resolve(), q.resolve(), F.resolve(), D.resolve(), K.resolve(), A.resolve();
              else
                $.off("event", j);
              I.consume(M);
              break;
            case "response.unit":
              I.consumeChild(M);
              break;
          }
      };
      $.on("event", j), Y({ id: W.id, context: W.ctx, set: W.ctx?.set, store: W.ctx?.store, time: W.time, request: Q.signal, parse: J.signal, transform: q.signal, beforeHandle: F.signal, handle: D.signal, afterHandle: K.signal, error: A.signal, response: I.signal });
    }
  };
};
var Y6 = X1($6(), 1);
var HW = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var o1 = Symbol("ErrorCode");
var N$ = (HW?.NODE_ENV ?? HW?.ENV) === "production";

class f$ extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor($) {
    super($ ?? "INTERNAL_SERVER_ERROR");
  }
}

class S1 extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor($) {
    super($ ?? "NOT_FOUND");
  }
}
class M$ extends Error {
  $;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor($, Y) {
    super(Y ?? `"${$}" has invalid cookie signature`);
    this.key = $;
  }
}

class j0 extends Error {
  $;
  Y;
  W;
  code = "VALIDATION";
  status = 400;
  constructor($, Y, W) {
    const X = N$ ? undefined : Y.Errors(W).First(), Z = X?.schema.error ? typeof X.schema.error === "function" ? X.schema.error($, Y, W) : X.schema.error : undefined, Q = N$ ? Z ?? `Invalid ${$ ?? X?.schema.error ?? X?.message}` : Z ?? `Invalid ${$}, '${X?.path?.slice(1) || "type"}': ${X?.message}` + "\n\nExpected: " + JSON.stringify(Y6.Value.Create(Y.schema), null, 2) + "\n\nFound: " + JSON.stringify(W, null, 2);
    super(Q);
    this.type = $;
    this.validator = Y;
    this.value = W;
    Object.setPrototypeOf(this, j0.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  get model() {
    return Y6.Value.Create(this.validator.schema);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: $ });
  }
}
var W6 = { open($) {
  $.data.open?.($);
}, message($, Y) {
  $.data.message?.($, Y);
}, drain($) {
  $.data.drain?.($);
}, close($, Y, W) {
  $.data.close?.($, Y, W);
} };

class c1 {
  $;
  Y;
  validator;
  constructor($, Y) {
    this.raw = $;
    this.data = Y;
    this.validator = $.data.validator;
  }
  publish($, Y = undefined, W) {
    if (this.validator?.Check(Y) === false)
      throw new j0("message", this.validator, Y);
    if (typeof Y === "object")
      Y = JSON.stringify(Y);
    return this.raw.publish($, Y, W), this;
  }
  send($) {
    if (this.validator?.Check($) === false)
      throw new j0("message", this.validator, $);
    if (typeof $ === "object")
      $ = JSON.stringify($);
    return this.raw.send($), this;
  }
  subscribe($) {
    return this.raw.subscribe($), this;
  }
  unsubscribe($) {
    return this.raw.unsubscribe($), this;
  }
  cork($) {
    return this.raw.cork($), this;
  }
  close() {
    return this.raw.close(), this;
  }
  terminate() {
    this.raw.terminate();
  }
  isSubscribed($) {
    return this.raw.isSubscribed($);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
}
var h9 = function($, Y) {
  if (typeof $ !== "string")
    throw new TypeError("argument str must be a string");
  var W = {}, X = Y || {}, Z = X.decode || c9, Q = 0;
  while (Q < $.length) {
    var J = $.indexOf("=", Q);
    if (J === -1)
      break;
    var q = $.indexOf(";", Q);
    if (q === -1)
      q = $.length;
    else if (q < J) {
      Q = $.lastIndexOf(";", J - 1) + 1;
      continue;
    }
    var F = $.slice(Q, J).trim();
    if (W[F] === undefined) {
      var D = $.slice(J + 1, q).trim();
      if (D.charCodeAt(0) === 34)
        D = D.slice(1, -1);
      W[F] = s9(D, Z);
    }
    Q = q + 1;
  }
  return W;
};
var o9 = function($, Y, W) {
  var X = W || {}, Z = X.encode || l9;
  if (typeof Z !== "function")
    throw new TypeError("option encode is invalid");
  if (!T$.test($))
    throw new TypeError("argument name is invalid");
  var Q = Z(Y);
  if (Q && !T$.test(Q))
    throw new TypeError("argument val is invalid");
  var J = $ + "=" + Q;
  if (X.maxAge != null) {
    var q = X.maxAge - 0;
    if (isNaN(q) || !isFinite(q))
      throw new TypeError("option maxAge is invalid");
    J += "; Max-Age=" + Math.floor(q);
  }
  if (X.domain) {
    if (!T$.test(X.domain))
      throw new TypeError("option domain is invalid");
    J += "; Domain=" + X.domain;
  }
  if (X.path) {
    if (!T$.test(X.path))
      throw new TypeError("option path is invalid");
    J += "; Path=" + X.path;
  }
  if (X.expires) {
    var F = X.expires;
    if (!t9(F) || isNaN(F.valueOf()))
      throw new TypeError("option expires is invalid");
    J += "; Expires=" + F.toUTCString();
  }
  if (X.httpOnly)
    J += "; HttpOnly";
  if (X.secure)
    J += "; Secure";
  if (X.priority) {
    var D = typeof X.priority === "string" ? X.priority.toLowerCase() : X.priority;
    switch (D) {
      case "low":
        J += "; Priority=Low";
        break;
      case "medium":
        J += "; Priority=Medium";
        break;
      case "high":
        J += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (X.sameSite) {
    var K = typeof X.sameSite === "string" ? X.sameSite.toLowerCase() : X.sameSite;
    switch (K) {
      case true:
        J += "; SameSite=Strict";
        break;
      case "lax":
        J += "; SameSite=Lax";
        break;
      case "strict":
        J += "; SameSite=Strict";
        break;
      case "none":
        J += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return J;
};
var c9 = function($) {
  return $.indexOf("%") !== -1 ? decodeURIComponent($) : $;
};
var l9 = function($) {
  return encodeURIComponent($);
};
var t9 = function($) {
  return n9.call($) === "[object Date]" || $ instanceof Date;
};
var s9 = function($, Y) {
  try {
    return Y($);
  } catch (W) {
    return $;
  }
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var d$ = h9;
var y$ = o9;
var n9 = Object.prototype.toString;
var T$ = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var i$ = X1(f0(), 1);
var B$ = X1($6(), 1);
var H6 = X1(AW(), 1);
var z6 = ($) => $ && typeof $ === "object" && !Array.isArray($);
var J7 = ($) => typeof $ === "function" && /^\s*class\s+/.test($.toString()) || $.toString() === "[object Module]" || F1(Object.getPrototypeOf($));
var M1 = ($, Y, { skipKeys: W } = {}) => {
  if (z6($) && z6(Y))
    for (let [X, Z] of Object.entries(Y)) {
      if (W?.includes(X))
        continue;
      if (!z6(Z)) {
        $[X] = Z;
        continue;
      }
      if (!(X in $)) {
        $[X] = Z;
        continue;
      }
      if (J7(Z)) {
        $[X] = Z;
        continue;
      }
      $[X] = M1($[X], Z);
    }
  return $;
};
var DW = ($, Y) => M1($, Y, { skipKeys: ["properties"] });
var P0 = ($, Y) => {
  const W = [...Array.isArray($) ? $ : [$]], X = [];
  for (let Z of W)
    if (Z.$elysiaChecksum)
      X.push(Z.$elysiaChecksum);
  for (let Z of Array.isArray(Y) ? Y : [Y])
    if (!X.includes(Z?.$elysiaChecksum))
      W.push(Z);
  return W;
};
var C1 = ($, Y) => {
  return { body: Y?.body ?? $?.body, headers: Y?.headers ?? $?.headers, params: Y?.params ?? $?.params, query: Y?.query ?? $?.query, response: Y?.response ?? $?.response, type: $?.type || Y?.type, detail: M1(Y?.detail ?? {}, $?.detail ?? {}), parse: P0($?.parse ?? [], Y?.parse ?? []), transform: P0($?.transform ?? [], Y?.transform ?? []), beforeHandle: P0($?.beforeHandle ?? [], Y?.beforeHandle ?? []), afterHandle: P0($?.afterHandle ?? [], Y?.afterHandle ?? []), onResponse: P0($?.onResponse ?? [], Y?.onResponse ?? []), trace: P0($?.trace ?? [], Y?.trace ?? []), error: P0($?.error ?? [], Y?.error ?? []) };
};
var U1 = ($, { models: Y = {}, additionalProperties: W = false, dynamic: X = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Y))
    return;
  const Z = typeof $ === "string" ? Y[$] : $;
  if (Z.type === "object" && ("additionalProperties" in Z) === false)
    Z.additionalProperties = W;
  if (X)
    return { schema: Z, references: "", checkFunc: () => {
    }, code: "", Check: (Q) => B$.Value.Check(Z, Q), Errors: (Q) => B$.Value.Errors(Z, Q), Code: () => "" };
  return H6.TypeCompiler.Compile(Z);
};
var q6 = ($, { models: Y = {}, additionalProperties: W = false, dynamic: X = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Y))
    return;
  const Z = typeof $ === "string" ? Y[$] : $, Q = (q) => {
    if (X)
      return { schema: q, references: "", checkFunc: () => {
      }, code: "", Check: (F) => B$.Value.Check(q, F), Errors: (F) => B$.Value.Errors(q, F), Code: () => "" };
    return H6.TypeCompiler.Compile(q);
  };
  if (i$.Kind in Z) {
    if (("additionalProperties" in Z) === false)
      Z.additionalProperties = W;
    return { 200: Q(Z) };
  }
  const J = {};
  return Object.keys(Z).forEach((q) => {
    const F = Z[+q];
    if (typeof F === "string") {
      if (F in Y) {
        const D = Y[F];
        D.type === "object" && ("additionalProperties" in D), J[+q] = (i$.Kind in D) ? Q(D) : D;
      }
      return;
    }
    if (F.type === "object" && ("additionalProperties" in F) === false)
      F.additionalProperties = W;
    J[+q] = (i$.Kind in F) ? Q(F) : F;
  }), J;
};
var N6 = ($) => {
  let Y = 9;
  for (let W = 0;W < $.length; )
    Y = Math.imul(Y ^ $.charCodeAt(W++), 387420489);
  return Y = Y ^ Y >>> 9;
};
var m$ = ($, Y, W) => {
  const X = (Z) => {
    if (W)
      Z.$elysiaChecksum = W;
    return Z;
  };
  return { start: P0($.start, ("start" in Y ? Y.start ?? [] : []).map(X)), request: P0($.request, ("request" in Y ? Y.request ?? [] : []).map(X)), parse: P0($.parse, "parse" in Y ? Y?.parse ?? [] : []).map(X), transform: P0($.transform, (Y?.transform ?? []).map(X)), beforeHandle: P0($.beforeHandle, (Y?.beforeHandle ?? []).map(X)), afterHandle: P0($.afterHandle, (Y?.afterHandle ?? []).map(X)), onResponse: P0($.onResponse, (Y?.onResponse ?? []).map(X)), trace: P0($.trace, ("trace" in Y ? Y.trace ?? [] : []).map(X)), error: P0($.error, (Y?.error ?? []).map(X)), stop: P0($.stop, ("stop" in Y ? Y.stop ?? [] : []).map(X)) };
};
var wW = ($, Y = true) => {
  if (!$)
    return $;
  if (typeof $ === "function") {
    if (Y)
      $.$elysiaHookType = "global";
    else
      $.$elysiaHookType = undefined;
    return $;
  }
  return $.map((W) => {
    if (Y)
      W.$elysiaHookType = "global";
    else
      W.$elysiaHookType = undefined;
    return W;
  });
};
var l1 = ($) => {
  if (!$)
    return $;
  if (typeof $ === "function")
    return $.$elysiaHookType === "global" ? $ : undefined;
  return $.filter((Y) => Y.$elysiaHookType === "global");
};
var M6 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: l1($?.parse), transform: l1($?.transform), beforeHandle: l1($?.beforeHandle), afterHandle: l1($?.afterHandle), onResponse: l1($?.onResponse), error: l1($?.error) };
};
var U6 = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var KW = import.meta.require("crypto");
var I1 = function($, Y) {
  if (typeof $ != "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (Y == null)
    throw new TypeError("Secret key must be provided.");
  return $ + "." + KW.createHmac("sha256", Y).update($).digest("base64").replace(/\=+$/, "");
};
var u$ = function($, Y) {
  if (typeof $ != "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (Y == null)
    throw new TypeError("Secret key must be provided.");
  var W = $.slice(0, $.lastIndexOf(".")), X = I1(W, Y), Z = Buffer.from(X), Q = Buffer.from($);
  return Z.length === Q.length && KW.timingSafeEqual(Z, Q) ? W : false;
};

class s0 {
  $;
  Y;
  name;
  setter;
  constructor($, Y = {}) {
    this._value = $;
    this.property = Y;
  }
  get() {
    return this._value;
  }
  get value() {
    return this._value;
  }
  set value($) {
    if (typeof $ === "object") {
      if (JSON.stringify(this.value) === JSON.stringify($))
        return;
    } else if (this.value === $)
      return;
    this._value = $, this.sync();
  }
  add($) {
    const Y = Object.assign(this.property, typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $);
    if ("value" in Y)
      this._value = Y.value, delete Y.value;
    return this.property = Y, this.sync();
  }
  set($) {
    const Y = typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $;
    if ("value" in Y)
      this._value = Y.value, delete Y.value;
    return this.property = Y, this.sync();
  }
  remove() {
    if (this.value === undefined)
      return;
    this.set({ value: "", expires: new Date });
  }
  get domain() {
    return this.property.domain;
  }
  set domain($) {
    this.property.domain = $, this.sync();
  }
  get expires() {
    return this.property.expires;
  }
  set expires($) {
    this.property.expires = $, this.sync();
  }
  get httpOnly() {
    return this.property.httpOnly;
  }
  set httpOnly($) {
    this.property.httpOnly = $, this.sync();
  }
  get maxAge() {
    return this.property.maxAge;
  }
  set maxAge($) {
    this.property.maxAge = $, this.sync();
  }
  get path() {
    return this.property.path;
  }
  set path($) {
    this.property.path = $, this.sync();
  }
  get priority() {
    return this.property.priority;
  }
  set priority($) {
    this.property.priority = $, this.sync();
  }
  get sameSite() {
    return this.property.sameSite;
  }
  set sameSite($) {
    this.property.sameSite = $, this.sync();
  }
  get secure() {
    return this.property.secure;
  }
  set secure($) {
    this.property.secure = $, this.sync();
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
  sync() {
    if (!this.name || !this.setter)
      return this;
    if (!this.setter.cookie)
      this.setter.cookie = { [this.name]: Object.assign(this.property, { value: this.toString() }) };
    else
      this.setter.cookie[this.name] = Object.assign(this.property, { value: this.toString() });
    return this;
  }
}
var jW = ($, Y) => new Proxy($, { get(W, X) {
  if (X in W)
    return W[X];
  const Z = new s0(undefined);
  return Z.setter = Y, Z.name = X, Z;
}, set(W, X, Z) {
  if (!(Z instanceof s0))
    return false;
  if (!Y.cookie)
    Y.cookie = {};
  return Z.setter = Y, Z.name = X, Z.sync(), W[X] = Z, true;
} });
var n$ = ($, Y, { secret: W, sign: X } = {}) => {
  if (!Y)
    return jW({}, $);
  const Z = {}, Q = typeof W === "string";
  if (X && X !== true && !Array.isArray(X))
    X = [X];
  const J = Object.keys(d$(Y));
  for (let q = 0;q < J.length; q++) {
    const F = J[q];
    let D = d$(Y)[F];
    if (X === true || X?.includes(F)) {
      if (!W)
        throw new Error("No secret is provided to cookie plugin");
      if (Q) {
        if (D = u$(D, W), D === false)
          throw new M$(F);
      } else {
        let I = true;
        for (let j = 0;j < W.length; j++) {
          const M = u$(D, W[j]);
          if (M !== false) {
            D = M, I = false;
            break;
          }
        }
        if (I)
          throw new M$(F);
      }
    }
    const K = D.charCodeAt(0);
    if (K === 123 || K === 91)
      try {
        const I = new s0(JSON.parse(D));
        I.setter = $, I.name = F, Z[F] = I;
        continue;
      } catch {
      }
    if (!Number.isNaN(+D))
      D = +D;
    else if (D === "true")
      D = true;
    else if (D === "false")
      D = false;
    const A = new s0(D);
    A.setter = $, A.name = F, Z[F] = A;
  }
  return jW(Z, $);
};
var PW = "toJSON" in new Headers;
var F1 = ($) => {
  for (let Y in $)
    return true;
  return false;
};
var OW = ($, Y) => {
  if (!$ || !Array.isArray(Y))
    return $;
  $.delete("Set-Cookie");
  for (let W = 0;W < Y.length; W++) {
    const X = Y[W].indexOf("=");
    $.append("Set-Cookie", `${Y[W].slice(0, X)}=${Y[W].slice(X + 1)}`);
  }
  return $;
};
var SW = ($) => {
  if (!$ || typeof $ !== "object" || !F1($))
    return;
  const Y = [];
  for (let [W, X] of Object.entries($)) {
    if (!W || !X)
      continue;
    if (Array.isArray(X.value))
      for (let Z = 0;Z < X.value.length; Z++) {
        let Q = X.value[Z];
        if (Q === undefined || Q === null)
          continue;
        if (typeof Q === "object")
          Q = JSON.stringify(Q);
        Y.push(y$(W, Q, X));
      }
    else {
      let Z = X.value;
      if (Z === undefined || Z === null)
        continue;
      if (typeof Z === "object")
        Z = JSON.stringify(Z);
      Y.push(y$(W, X.value, X));
    }
  }
  if (Y.length === 0)
    return;
  if (Y.length === 1)
    return Y[0];
  return Y;
};
var B1 = ($, Y) => {
  if (F1(Y.headers) || Y.status !== 200 || Y.redirect || Y.cookie) {
    if (typeof Y.status === "string")
      Y.status = U6[Y.status];
    if (Y.redirect) {
      if (Y.headers.Location = Y.redirect, !Y.status || Y.status < 300 || Y.status >= 400)
        Y.status = 302;
    }
    if (Y.cookie && F1(Y.cookie))
      Y.headers["Set-Cookie"] = SW(Y.cookie);
    if (Y.headers["Set-Cookie"] && Array.isArray(Y.headers["Set-Cookie"]))
      Y.headers = OW(new Headers(Y.headers), Y.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, { status: Y.status, headers: Y.headers });
      case "Object":
      case "Array":
        return Response.json($, Y);
      case undefined:
        if (!$)
          return new Response("", Y);
        return Response.json($, Y);
      case "Response":
        const W = { ...Y.headers };
        if (PW)
          Y.headers = $.headers.toJSON();
        else
          for (let [Z, Q] of $.headers.entries())
            if (Z in Y.headers)
              Y.headers[Z] = Q;
        for (let Z in W)
          $.headers.append(Z, W[Z]);
        return $;
      case "Error":
        return A$($, Y);
      case "Promise":
        return $.then((Z) => B1(Z, Y));
      case "Function":
        return B1($(), Y);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Y);
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123) {
          if (!Y.headers["Content-Type"])
            Y.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Y);
        }
        return new Response(X, Y);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Error":
        return A$($, Y);
      case "Promise":
        return $.then((X) => {
          const Z = K1(X);
          if (Z !== undefined)
            return Z;
          return new Response("");
        });
      case "Function":
        return K1($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(W);
    }
};
var r0 = ($, Y) => {
  if ($ === undefined || $ === null)
    return;
  if (F1(Y.headers) || Y.status !== 200 || Y.redirect || Y.cookie) {
    if (typeof Y.status === "string")
      Y.status = U6[Y.status];
    if (Y.redirect) {
      if (Y.headers.Location = Y.redirect, !Y.status || Y.status < 300 || Y.status >= 400)
        Y.status = 302;
    }
    if (Y.cookie && F1(Y.cookie))
      Y.headers["Set-Cookie"] = SW(Y.cookie);
    if (Y.headers["Set-Cookie"] && Array.isArray(Y.headers["Set-Cookie"]))
      Y.headers = OW(new Headers(Y.headers), Y.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, Y);
      case "Object":
      case "Array":
        return Response.json($, Y);
      case undefined:
        if (!$)
          return;
        return Response.json($, Y);
      case "Response":
        const W = Object.assign({}, Y.headers);
        if (PW)
          Y.headers = $.headers.toJSON();
        else
          for (let [Z, Q] of $.headers.entries())
            if (!(Z in Y.headers))
              Y.headers[Z] = Q;
        for (let Z in W)
          $.headers.append(Z, W[Z]);
        if ($.status !== Y.status)
          Y.status = $.status;
        return $;
      case "Promise":
        return $.then((Z) => {
          const Q = r0(Z, Y);
          if (Q !== undefined)
            return Q;
          return;
        });
      case "Error":
        return A$($, Y);
      case "Function":
        return r0($(), Y);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Y);
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123) {
          if (!Y.headers["Content-Type"])
            Y.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Y);
        }
        return new Response(X, Y);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Promise":
        return $.then((X) => {
          const Z = r0(X, Y);
          if (Z !== undefined)
            return Z;
          return;
        });
      case "Error":
        return A$($, Y);
      case "Function":
        return K1($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof s0)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(W);
    }
};
var K1 = ($) => {
  switch ($?.constructor?.name) {
    case "String":
    case "Blob":
      return new Response($);
    case "Object":
    case "Array":
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      return $;
    case "Error":
      return A$($);
    case "Promise":
      return $.then((W) => {
        const X = K1(W);
        if (X !== undefined)
          return X;
        return new Response("");
      });
    case "Function":
      return K1($());
    case "Number":
    case "Boolean":
      return new Response($.toString());
    default:
      const Y = JSON.stringify($);
      if (Y.charCodeAt(0) === 123)
        return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      return new Response(Y);
  }
};
var A$ = ($, Y) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: Y?.status !== 200 ? Y?.status ?? 500 : 500, headers: Y?.headers });
var pW = X1(A6(), 1);
var B7 = new Headers().toJSON;
var iW = new RegExp(" (\\w+) = context", "g");
var mW = { value: 0 };
var uW = ({ hasTrace: $, hasTraceSet: Y = false, hasTraceChildren: W = false, addFn: X, condition: Z = {} }) => {
  if ($) {
    const Q = W ? "\nawait new Promise(r => {queueMicrotask(() => queueMicrotask(r))})\n" : "\nawait new Promise(r => {queueMicrotask(r)})\n";
    return (J, { name: q, attribute: F = "", unit: D = 0 } = {}) => {
      const K = J.indexOf("."), A = K === -1;
      if (J !== "request" && J !== "response" && !Z[A ? J : J.slice(0, K)])
        return () => {
          if (Y && J === "afterHandle")
            X(Q);
        };
      if (A)
        q ||= J;
      else
        q ||= "anonymous";
      X("\n" + `reporter.emit('event', { 
					id,
					event: '${J}',
					type: 'begin',
					name: '${q}',
					time: performance.now(),
					${A ? `unit: ${D},` : ""}
					${F}
				})`.replace(/(\t| |\n)/g, "") + "\n");
      let I = false;
      return () => {
        if (I)
          return;
        if (I = true, X("\n" + `reporter.emit('event', {
							id,
							event: '${J}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + "\n"), Y && J === "afterHandle")
          X(Q);
      };
    };
  } else
    return () => () => {
    };
};
var w$ = ($) => {
  const Y = $.indexOf(")");
  if ($.charCodeAt(Y + 2) === 61 && $.charCodeAt(Y + 5) !== 123)
    return true;
  return $.includes("return");
};
var A7 = ($, { injectResponse: Y = "" } = {}) => ({ composeValidation: (W, X = `c.${W}`) => $ ? `c.set.status = 400; throw new ValidationError(
'${W}',
${W},
${X}
)` : `c.set.status = 400; return new ValidationError(
	'${W}',
	${W},
	${X}
).toResponse(c.set.headers)`, composeResponseValidation: (W = "r") => {
  const X = $ ? `throw new ValidationError(
'response',
response[c.set.status],
${W}
)` : `return new ValidationError(
'response',
response[c.set.status],
${W}
).toResponse(c.set.headers)`;
  return `\n${Y}
		if(response[c.set.status]?.Check(${W}) === false) { 
	if(!(response instanceof Error))
		${X}
}\n`;
} });
var O0 = ($, Y) => {
  if (Y = Y.trimStart(), Y = Y.replaceAll(/^async /g, ""), /^(\w+)\(/g.test(Y))
    Y = Y.slice(Y.indexOf("("));
  const W = Y.charCodeAt(0) === 40 || Y.startsWith("function") ? Y.slice(Y.indexOf("(") + 1, Y.indexOf(")")) : Y.slice(0, Y.indexOf("=") - 1);
  if (W === "")
    return false;
  const X = W.charCodeAt(0) === 123 ? W.indexOf("...") : -1;
  if (W.charCodeAt(0) === 123) {
    if (W.includes($))
      return true;
    if (X === -1)
      return false;
  }
  if (Y.match(new RegExp(`${W}(.${$}|\\["${$}"\\])`)))
    return true;
  const Z = X !== -1 ? W.slice(X + 3, W.indexOf(" ", X + 3)) : undefined;
  if (Y.match(new RegExp(`${Z}(.${$}|\\["${$}"\\])`)))
    return true;
  const Q = [W];
  if (Z)
    Q.push(Z);
  for (let q of Y.matchAll(iW))
    Q.push(q[1]);
  const J = new RegExp(`{.*?} = (${Q.join("|")})`, "g");
  for (let [q] of Y.matchAll(J))
    if (q.includes(`{ ${$}`) || q.includes(`, ${$}`))
      return true;
  return false;
};
var s1 = ($) => {
  if ($ = $.trimStart(), $ = $.replaceAll(/^async /g, ""), /^(\w+)\(/g.test($))
    $ = $.slice($.indexOf("("));
  const Y = $.charCodeAt(0) === 40 || $.startsWith("function") ? $.slice($.indexOf("(") + 1, $.indexOf(")")) : $.slice(0, $.indexOf("=") - 1);
  if (Y === "")
    return false;
  const W = Y.charCodeAt(0) === 123 ? Y.indexOf("...") : -1, X = W !== -1 ? Y.slice(W + 3, Y.indexOf(" ", W + 3)) : undefined, Z = [Y];
  if (X)
    Z.push(X);
  for (let J of $.matchAll(iW))
    Z.push(J[1]);
  for (let J of Z)
    if (new RegExp(`\\b\\w+\\([^)]*\\b${J}\\b[^)]*\\)`).test($))
      return true;
  const Q = new RegExp(`{.*?} = (${Z.join("|")})`, "g");
  for (let [J] of $.matchAll(Q))
    if (new RegExp(`\\b\\w+\\([^)]*\\b${J}\\b[^)]*\\)`).test($))
      return true;
  return false;
};
var t1 = Symbol.for("TypeBox.Kind");
var h$ = ($, Y) => {
  if (!Y)
    return;
  if ((t1 in Y) && Y[t1] === $)
    return true;
  if (Y.type === "object") {
    const W = Y.properties;
    for (let X of Object.keys(W)) {
      const Z = W[X];
      if (Z.type === "object") {
        if (h$($, Z))
          return true;
      } else if (Z.anyOf) {
        for (let Q = 0;Q < Z.anyOf.length; Q++)
          if (h$($, Z.anyOf[Q]))
            return true;
      }
      if ((t1 in Z) && Z[t1] === $)
        return true;
    }
    return false;
  }
  return Y.properties && (t1 in Y.properties) && Y.properties[t1] === $;
};
var D6 = Symbol.for("TypeBox.Transform");
var b1 = ($) => {
  if (!$)
    return;
  if ($.type === "object") {
    const Y = $.properties;
    for (let W of Object.keys(Y)) {
      const X = Y[W];
      if (X.type === "object") {
        if (b1(X))
          return true;
      } else if (X.anyOf) {
        for (let Q = 0;Q < X.anyOf.length; Q++)
          if (b1(X.anyOf[Q]))
            return true;
      }
      if (D6 in X)
        return true;
    }
    return false;
  }
  return (D6 in $) || $.properties && (D6 in $.properties);
};
var D7 = ($) => {
  if (!$)
    return;
  const Y = $?.schema;
  if (Y && ("anyOf" in Y)) {
    let W = false;
    const X = Y.anyOf[0].type;
    for (let Z of Y.anyOf)
      if (Z.type !== X) {
        W = true;
        break;
      }
    if (!W)
      return X;
  }
  return $.schema?.type;
};
var w7 = /(?:return|=>) \S*\(/g;
var q0 = ($) => {
  if ($.constructor.name === "AsyncFunction")
    return true;
  return $.toString().match(w7);
};
var nW = ({ path: $, method: Y, hooks: W, validator: X, handler: Z, handleError: Q, definitions: J, schema: q, onRequest: F, config: D, reporter: K }) => {
  const A = D.forceErrorEncapsulation || W.error.length > 0 || typeof Bun === "undefined" || W.onResponse.length > 0 || !!W.trace.length, I = W.onResponse.length ? `\n;(async () => {${W.onResponse.map((E, d) => `await res${d}(c)`).join(";")}})();\n` : "", j = W.trace.map((E) => E.toString());
  let M = false;
  if (s1(Z.toString()))
    M = true;
  if (!M)
    for (let [E, d] of Object.entries(W)) {
      if (!Array.isArray(d) || !d.length || !["parse", "transform", "beforeHandle", "afterHandle", "onResponse"].includes(E))
        continue;
      for (let u of d) {
        if (typeof u !== "function")
          continue;
        if (s1(u.toString())) {
          M = true;
          break;
        }
      }
      if (M)
        break;
    }
  const L = { parse: j.some((E) => O0("parse", E)), transform: j.some((E) => O0("transform", E)), handle: j.some((E) => O0("handle", E)), beforeHandle: j.some((E) => O0("beforeHandle", E)), afterHandle: j.some((E) => O0("afterHandle", E)), error: A || j.some((E) => O0("error", E)) }, O = W.trace.length > 0;
  let U = "";
  if (O)
    U += "\nconst id = c.$$requestId\n";
  U += A ? "try {\n" : "";
  const w = X || Y !== "GET" && Y !== "HEAD" ? [Z, ...W.transform, ...W.beforeHandle, ...W.afterHandle].map((E) => E.toString()) : [], b = M || Y !== "GET" && Y !== "HEAD" && W.type !== "none" && (!!X.body || !!W.type || w.some((E) => O0("body", E))), R = M || X.headers || w.some((E) => O0("headers", E)), V = M || X.cookie || w.some((E) => O0("cookie", E)), G = X?.cookie?.schema;
  let h = "";
  if (G?.sign) {
    if (!G.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${Y}) ${$}.`);
    const E = !G.secrets ? undefined : typeof G.secrets === "string" ? G.secrets : G.secrets[0];
    if (h += `const _setCookie = c.set.cookie
		if(_setCookie) {`, G.sign === true)
      h += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = signCookie(cookie.value, '${E}')
			}`;
    else
      for (let d of G.sign)
        h += `if(_setCookie['${d}']?.value) { c.set.cookie['${d}'].value = signCookie(_setCookie['${d}'].value, '${E}') }\n`;
    h += "}\n";
  }
  const { composeValidation: o, composeResponseValidation: $0 } = A7(A);
  if (R)
    U += B7 ? "c.headers = c.request.headers.toJSON()\n" : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  if (V) {
    const E = G ? `{
			secret: ${G.secrets !== undefined ? typeof G.secrets === "string" ? `'${G.secrets}'` : "[" + G.secrets.reduce((d, u) => d + `'${u}',`, "") + "]" : "undefined"},
			sign: ${G.sign === true ? true : G.sign !== undefined ? "[" + G.sign.reduce((d, u) => d + `'${u}',`, "") + "]" : "undefined"}
		}` : "undefined";
    if (R)
      U += `\nc.cookie = parseCookie(c.set, c.headers.cookie, ${E})\n`;
    else
      U += `\nc.cookie = parseCookie(c.set, c.request.headers.get('cookie'), ${E})\n`;
  }
  if (M || X.query || w.some((E) => O0("query", E)))
    U += `const url = c.request.url

		if(c.qi !== -1) {
			c.query ??= parseQuery(url.substring(c.qi + 1))
		} else {
			c.query ??= {}
		}
		`;
  const w0 = W.trace.map((E) => E.toString()), k0 = w0.some((E) => O0("set", E) || s1(E)), F0 = k0 && w0.some((E) => E.includes("children") || s1(E));
  M || W.trace.some((E) => O0("set", E.toString()));
  const v0 = k0 || V || w.some((E) => O0("set", E)) || F.some((E) => O0("set", E.toString())), z0 = uW({ hasTrace: O, hasTraceSet: k0, hasTraceChildren: F0, condition: L, addFn: (E) => {
    U += E;
  } }), p0 = b || k0 || q0(Z) || W.parse.length > 0 || W.afterHandle.some(q0) || W.beforeHandle.some(q0) || W.transform.some(q0), g0 = z0("parse", { unit: W.parse.length });
  if (b) {
    const E = D7(X?.body);
    if (W.type && !Array.isArray(W.type)) {
      if (W.type)
        switch (W.type) {
          case "json":
          case "application/json":
            U += "c.body = await c.request.json()\n";
            break;
          case "text":
          case "text/plain":
            U += "c.body = await c.request.text()\n";
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            U += "c.body = parseQuery(await c.request.text())\n";
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            U += "c.body = await c.request.arrayBuffer()\n";
            break;
          case "formdata":
          case "multipart/form-data":
            U += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}\n`;
            break;
        }
      if (W.parse.length)
        U += "}}";
    } else {
      const u = (() => {
        if (W.parse.length && E && !Array.isArray(W.type)) {
          const t = X?.body?.schema;
          switch (E) {
            case "object":
              if (h$("File", t) || h$("Files", t))
                return `c.body = {}
		
								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue
			
									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
              break;
            default:
              break;
          }
        }
      })();
      if (u)
        U += u;
      else {
        if (U += "\n", U += R ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", U += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n`, W.parse.length) {
          U += "let used = false\n";
          const t = z0("parse", { unit: W.parse.length });
          for (let H0 = 0;H0 < W.parse.length; H0++) {
            const E0 = z0("parse.unit", { name: W.parse[H0].name }), D0 = `bo${H0}`;
            if (H0 !== 0)
              U += "if(!used) {\n";
            if (U += `let ${D0} = parse[${H0}](c, contentType)\n`, U += `if(${D0} instanceof Promise) ${D0} = await ${D0}\n`, U += `if(${D0} !== undefined) { c.body = ${D0}; used = true }\n`, E0(), H0 !== 0)
              U += "}";
          }
          t();
        }
        if (W.parse.length)
          U += "if (!used)";
        U += `
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break
				
					case 'text/plain':
						c.body = await c.request.text()
						break
				
					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break
				
					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break
				
					case 'multipart/form-data':
						c.body = {}
				
						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue
				
							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
				
						break
					}\n`, U += "}\n";
      }
    }
    U += "\n";
  }
  if (g0(), W?.transform) {
    const E = z0("transform", { unit: W.transform.length });
    for (let d = 0;d < W.transform.length; d++) {
      const u = W.transform[d], t = z0("transform.unit", { name: u.name });
      if (u.$elysia === "derive")
        U += q0(W.transform[d]) ? `Object.assign(c, await transform[${d}](c));` : `Object.assign(c, transform[${d}](c));`;
      else
        U += q0(W.transform[d]) ? `await transform[${d}](c);` : `transform[${d}](c);`;
      t();
    }
    E();
  }
  if (X) {
    if (U += "\n", X.headers) {
      if (U += `if(headers.Check(c.headers) === false) {
				${o("headers")}
			}`, b1(X.headers.schema))
        U += "\nc.headers = headers.Decode(c.headers)\n";
    }
    if (X.params) {
      if (U += `if(params.Check(c.params) === false) {
				${o("params")}
			}`, b1(X.params.schema))
        U += "\nc.params = params.Decode(c.params)\n";
    }
    if (X.query) {
      if (U += `if(query.Check(c.query) === false) {
				${o("query")} 
			}`, b1(X.query.schema))
        U += "\nc.query = query.Decode(Object.assign({}, c.query))\n";
    }
    if (X.body) {
      if (U += `if(body.Check(c.body) === false) { 
				${o("body")}
			}`, b1(X.body.schema))
        U += "\nc.body = body.Decode(c.body)\n";
    }
    if (X.cookie) {
      if (U += `const cookieValue = {}
			for(const [key, value] of Object.entries(c.cookie))
				cookieValue[key] = value.value

			if(cookie.Check(cookieValue) === false) {
				${o("cookie", "cookieValue")}
			}`, b1(X.cookie.schema))
        U += "\nc.cookie = params.Decode(c.cookie)\n";
    }
  }
  if (W?.beforeHandle) {
    const E = z0("beforeHandle", { unit: W.beforeHandle.length });
    for (let d = 0;d < W.beforeHandle.length; d++) {
      const u = z0("beforeHandle.unit", { name: W.beforeHandle[d].name }), t = `be${d}`;
      if (!w$(W.beforeHandle[d].toString()))
        U += q0(W.beforeHandle[d]) ? `await beforeHandle[${d}](c);\n` : `beforeHandle[${d}](c);\n`, u();
      else {
        U += q0(W.beforeHandle[d]) ? `let ${t} = await beforeHandle[${d}](c);\n` : `let ${t} = beforeHandle[${d}](c);\n`, u(), U += `if(${t} !== undefined) {\n`;
        const E0 = z0("afterHandle", { unit: W.transform.length });
        if (W.afterHandle) {
          const D0 = t;
          for (let a = 0;a < W.afterHandle.length; a++) {
            const A1 = w$(W.afterHandle[a].toString()), P = z0("afterHandle.unit", { name: W.afterHandle[a].name });
            if (U += `c.response = ${D0}\n`, !A1)
              U += q0(W.afterHandle[a]) ? `await afterHandle[${a}](c, ${D0});\n` : `afterHandle[${a}](c, ${D0});\n`;
            else {
              const _ = `af${a}`;
              U += q0(W.afterHandle[a]) ? `const ${_} = await afterHandle[${a}](c);\n` : `const ${_} = afterHandle[${a}](c);\n`, U += `if(${_} !== undefined) { c.response = ${D0} = ${_} }\n`;
            }
            P();
          }
        }
        if (E0(), X.response)
          U += $0(t);
        U += h, U += `return mapEarlyResponse(${t}, c.set)}\n`;
      }
    }
    E();
  }
  if (W?.afterHandle.length) {
    const E = z0("handle", { name: Z.name });
    if (W.afterHandle.length)
      U += q0(Z) ? "let r = c.response = await handler(c);\n" : "let r = c.response = handler(c);\n";
    else
      U += q0(Z) ? "let r = await handler(c);\n" : "let r = handler(c);\n";
    E();
    const d = z0("afterHandle", { unit: W.afterHandle.length });
    for (let u = 0;u < W.afterHandle.length; u++) {
      const t = `af${u}`, H0 = w$(W.afterHandle[u].toString()), E0 = z0("afterHandle.unit", { name: W.afterHandle[u].name });
      if (!H0)
        U += q0(W.afterHandle[u]) ? `await afterHandle[${u}](c)\n` : `afterHandle[${u}](c)\n`, E0();
      else {
        if (X.response)
          U += q0(W.afterHandle[u]) ? `let ${t} = await afterHandle[${u}](c)\n` : `let ${t} = afterHandle[${u}](c)\n`;
        else
          U += q0(W.afterHandle[u]) ? `let ${t} = mapEarlyResponse(await afterHandle[${u}](c), c.set)\n` : `let ${t} = mapEarlyResponse(afterHandle[${u}](c), c.set)\n`;
        if (E0(), X.response)
          U += `if(${t} !== undefined) {`, U += $0(t), U += `${t} = mapEarlyResponse(${t}, c.set)\n`, U += `if(${t}) {`, d(), U += `return ${t} } }`;
        else
          U += `if(${t}) {`, d(), U += `return ${t}}\n`;
      }
    }
    if (d(), U += "r = c.response\n", X.response)
      U += $0();
    if (U += h, v0)
      U += "return mapResponse(r, c.set)\n";
    else
      U += "return mapCompactResponse(r)\n";
  } else {
    const E = z0("handle", { name: Z.name });
    if (X.response)
      if (U += q0(Z) ? "const r = await handler(c);\n" : "const r = handler(c);\n", E(), U += $0(), z0("afterHandle")(), U += h, v0)
        U += "return mapResponse(r, c.set)\n";
      else
        U += "return mapCompactResponse(r)\n";
    else if (L.handle || V)
      if (U += q0(Z) ? "let r = await handler(c);\n" : "let r = handler(c);\n", E(), z0("afterHandle")(), U += h, v0)
        U += "return mapResponse(r, c.set)\n";
      else
        U += "return mapCompactResponse(r)\n";
    else {
      E();
      const d = q0(Z) ? "await handler(c) " : "handler(c)";
      if (z0("afterHandle")(), v0)
        U += `return mapResponse(${d}, c.set)\n`;
      else
        U += `return mapCompactResponse(${d})\n`;
    }
  }
  if (A || I) {
    if (U += `
} catch(error) {`, !p0)
      U += "return (async () => {";
    U += `const set = c.set

		if (!set.status || set.status < 300) set.status = 500
	`;
    const E = z0("error", { unit: W.error.length });
    if (W.error.length)
      for (let d = 0;d < W.error.length; d++) {
        const u = `er${d}`, t = z0("error.unit", { name: W.error[d].name });
        if (U += `\nlet ${u} = handleErrors[${d}](
					Object.assign(c, {
						error: error,
						code: error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
					})
				)\n`, q0(W.error[d]))
          U += `if (${u} instanceof Promise) ${u} = await ${u}\n`;
        t(), U += `${u} = mapEarlyResponse(${u}, set)\n`, U += `if (${u}) {`, U += `return ${u} }\n`;
      }
    if (E(), U += "return handleError(c, error)\n\n", !p0)
      U += "})()";
    if (U += "}", I || O) {
      U += " finally { ";
      const d = z0("response", { unit: W.onResponse.length });
      U += I, d(), U += "}";
    }
  }
  return U = `const { 
		handler,
		handleError,
		hooks: {
			transform,
			beforeHandle,
			afterHandle,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		reporter,
		requestId,
		parseCookie,
		signCookie
	} = hooks

	${W.onResponse.length ? `const ${W.onResponse.map((E, d) => `res${d} = onResponse[${d}]`).join(",")}` : ""}

	return ${p0 ? "async" : ""} function(c) {
		${q && J ? "c.schema = schema; c.defs = definitions;" : ""}
		${U}
	}`, Function("hooks", U)({ handler: Z, hooks: W, validator: X, handleError: Q, utils: { mapResponse: B1, mapCompactResponse: K1, mapEarlyResponse: r0, parseQuery: pW.parse }, error: { NotFoundError: S1, ValidationError: j0, InternalServerError: f$ }, schema: q, definitions: J, ERROR_CODE: o1, reporter: K, requestId: mW, parseCookie: n$, signCookie: I1 });
};
var w6 = ($) => {
  let Y = "", W = "";
  for (let A of Object.keys($.decorators))
    Y += `,${A}: app.decorators.${A}`;
  const { router: X, staticRouter: Z } = $, Q = $.event.trace.length > 0, J = `
	const route = find(request.method, path) ${X.root.ALL ? '?? find("ALL", path)' : ""}
	if (route === null)
		return ${$.event.error.length ? "app.handleError(ctx, notFound)" : `new Response(error404, {
					status: 404
				})`}

	ctx.params = route.params

	return route.store(ctx)`;
  let q = "";
  for (let [A, { code: I, all: j }] of Object.entries(Z.map))
    q += `case '${A}':\nswitch(request.method) {\n${I}\n${j ?? "default: break map"}}\n\n`;
  const F = $.event.request.some(q0);
  W += `const {
		app,
		app: { store, router, staticRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		reporter
	} = data

	const notFound = new NotFoundError()

	${$.event.request.length ? "const onRequest = app.event.request" : ""}

	${Z.variables}

	const find = router.find.bind(router)
	const handleError = app.handleError.bind(this)

	${$.event.error.length ? "" : "const error404 = notFound.message.toString()"}

	return ${F ? "async" : ""} function map(request) {
	`;
  const D = $.event.trace.map((A) => A.toString()), K = uW({ hasTrace: Q, hasTraceChildren: Q && D.some((A) => A.includes("children") || s1(A)), condition: { request: D.some((A) => O0("request", A) || s1(A)) }, addFn: (A) => {
    W += A;
  } });
  if ($.event.request.length) {
    W += `
			${Q ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					cookie: {},
					headers: {},
					status: 200
				}
				${Q ? ",$$requestId: +id" : ""}
				${Y}
			}
		`;
    const A = K("request", { attribute: "ctx", unit: $.event.request.length });
    W += "try {\n";
    for (let I = 0;I < $.event.request.length; I++) {
      const j = $.event.request[I], M = w$(j.toString()), L = q0(j), O = K("request.unit", { name: $.event.request[I].name }), U = `re${I}`;
      if (M)
        W += `const ${U} = mapEarlyResponse(
					${L ? "await" : ""} onRequest[${I}](ctx),
					ctx.set
				)\n`, O(), W += `if(${U}) return ${U}\n`;
      else
        W += `${L ? "await" : ""} onRequest[${I}](ctx)\n`, O();
    }
    W += `} catch (error) {
			return app.handleError(ctx, error)
		}`, A(), W += `
		const url = request.url,
		s = url.indexOf('/', 11),
		i = ctx.qi = url.indexOf('?', s + 1),
		path = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`;
  } else
    W += `
		const url = request.url,
			s = url.indexOf('/', 11),
			qi = url.indexOf('?', s + 1),
			path = qi === -1
				? url.substring(s)
				: url.substring(s, qi)

		${Q ? "const id = +requestId.value++" : ""}

		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: {},
				status: 200
			}
			${Q ? ",$$requestId: id" : ""}
			${Y}
		}`, K("request", { unit: $.event.request.length, attribute: D.some((A) => O0("context", A)) || D.some((A) => O0("store", A)) || D.some((A) => O0("set", A)) ? "ctx" : "" })();
  return W += `
		map: switch(path) {
			${q}

			default:
				break
		}

		${J}
	}`, $.handleError = K6($), Function("data", W)({ app: $, mapEarlyResponse: r0, NotFoundError: S1, reporter: $.reporter, requestId: mW });
};
var K6 = ($) => {
  let Y = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE
	} = inject

	return ${$.event.error.find(q0) ? "async" : ""} function(context, error) {
		const { set } = context
		`;
  for (let W = 0;W < $.event.error.length; W++) {
    const X = $.event.error[W], Z = `${q0(X) ? "await " : ""}onError[${W}](
			Object.assign(context, {
				code: error.code ?? error[ERROR_CODE] ?? 'UNKNOWN',
				error
			})
		)`;
    if (w$(X.toString()))
      Y += `const r${W} = ${Z}; if(r${W} !== undefined) return mapResponse(r${W}, set)\n`;
    else
      Y += Z + "\n";
  }
  return Y += `if(error.constructor.name === "ValidationError") {
		set.status = error.status ?? 400
		return new Response(
			error.message, 
			{ headers: set.headers, status: set.status }
		)
	} else {
		return new Response(error.message, { headers: set.headers, status: error.status ?? 500 })
	}
}`, Function("inject", Y)({ app: $, mapResponse: B1, ERROR_CODE: o1 });
};
var o$ = X1(A6(), 1);
var j6 = ($) => async (Y) => {
  const W = { cookie: {}, status: 200, headers: {} };
  let X;
  if ($.decorators)
    X = $.decorators, X.request = Y, X.set = W, X.store = $.store;
  else
    X = { set: W, store: $.store, request: Y };
  const Z = Y.url, Q = Z.indexOf("/", 11), J = Z.indexOf("?", Q + 1), q = J === -1 ? Z.substring(Q) : Z.substring(Q, J);
  try {
    for (let O = 0;O < $.event.request.length; O++) {
      const U = $.event.request[O];
      let w = U(X);
      if (w instanceof Promise)
        w = await w;
      if (w = r0(w, W), w)
        return w;
    }
    const F = $.dynamicRouter.find(Y.method, q) ?? $.dynamicRouter.find("ALL", q);
    if (!F)
      throw new S1;
    const { handle: D, hooks: K, validator: A, content: I } = F.store;
    let j;
    if (Y.method !== "GET" && Y.method !== "HEAD")
      if (I)
        switch (I) {
          case "application/json":
            j = await Y.json();
            break;
          case "text/plain":
            j = await Y.text();
            break;
          case "application/x-www-form-urlencoded":
            j = o$.parse(await Y.text());
            break;
          case "application/octet-stream":
            j = await Y.arrayBuffer();
            break;
          case "multipart/form-data":
            j = {};
            const O = await Y.formData();
            for (let U of O.keys()) {
              if (j[U])
                continue;
              const w = O.getAll(U);
              if (w.length === 1)
                j[U] = w[0];
              else
                j[U] = w;
            }
            break;
        }
      else {
        let O = Y.headers.get("content-type");
        if (O) {
          const U = O.indexOf(";");
          if (U !== -1)
            O = O.slice(0, U);
          for (let w = 0;w < $.event.parse.length; w++) {
            let b = $.event.parse[w](X, O);
            if (b instanceof Promise)
              b = await b;
            if (b) {
              j = b;
              break;
            }
          }
          if (j === undefined)
            switch (O) {
              case "application/json":
                j = await Y.json();
                break;
              case "text/plain":
                j = await Y.text();
                break;
              case "application/x-www-form-urlencoded":
                j = o$.parse(await Y.text());
                break;
              case "application/octet-stream":
                j = await Y.arrayBuffer();
                break;
              case "multipart/form-data":
                j = {};
                const w = await Y.formData();
                for (let b of w.keys()) {
                  if (j[b])
                    continue;
                  const R = w.getAll(b);
                  if (R.length === 1)
                    j[b] = R[0];
                  else
                    j[b] = R;
                }
                break;
            }
        }
      }
    X.body = j, X.params = F?.params || undefined, X.query = J === -1 ? {} : o$.parse(Z.substring(J + 1)), X.headers = {};
    for (let [O, U] of Y.headers.entries())
      X.headers[O] = U;
    const M = A?.cookie?.schema;
    X.cookie = n$(X.set, X.headers.cookie, M ? { secret: M.secrets !== undefined ? typeof M.secrets === "string" ? M.secrets : M.secrets.join(",") : undefined, sign: M.sign === true ? true : M.sign !== undefined ? typeof M.sign === "string" ? M.sign : M.sign.join(",") : undefined } : undefined);
    for (let O = 0;O < K.transform.length; O++) {
      const U = K.transform[O](X);
      if (K.transform[O].$elysia === "derive")
        if (U instanceof Promise)
          Object.assign(X, await U);
        else
          Object.assign(X, U);
      else if (U instanceof Promise)
        await U;
    }
    if (A) {
      if (A.headers) {
        const O = {};
        for (let U in Y.headers)
          O[U] = Y.headers.get(U);
        if (A.headers.Check(O) === false)
          throw new j0("header", A.headers, O);
      }
      if (A.params?.Check(X.params) === false)
        throw new j0("params", A.params, X.params);
      if (A.query?.Check(X.query) === false)
        throw new j0("query", A.query, X.query);
      if (A.cookie) {
        const O = {};
        for (let [U, w] of Object.entries(X.cookie))
          O[U] = w.value;
        if (A.cookie?.Check(O) === false)
          throw new j0("cookie", A.cookie, O);
      }
      if (A.body?.Check(j) === false)
        throw new j0("body", A.body, j);
    }
    for (let O = 0;O < K.beforeHandle.length; O++) {
      let U = K.beforeHandle[O](X);
      if (U instanceof Promise)
        U = await U;
      if (U !== undefined) {
        X.response = U;
        for (let b = 0;b < K.afterHandle.length; b++) {
          let R = K.afterHandle[b](X);
          if (R instanceof Promise)
            R = await R;
          if (R)
            U = R;
        }
        const w = r0(U, X.set);
        if (w)
          return w;
      }
    }
    let L = D(X);
    if (L instanceof Promise)
      L = await L;
    if (!K.afterHandle.length) {
      const O = A?.response?.[L.status];
      if (O?.Check(L) === false)
        throw new j0("response", O, L);
    } else {
      X.response = L;
      for (let O = 0;O < K.afterHandle.length; O++) {
        let U = K.afterHandle[O](X);
        if (U instanceof Promise)
          U = await U;
        const w = r0(U, X.set);
        if (w !== undefined) {
          const b = A?.response?.[L.status];
          if (b?.Check(w) === false)
            throw new j0("response", b, w);
          return w;
        }
      }
    }
    if (X.set.cookie && M?.sign) {
      const O = !M.secrets ? undefined : typeof M.secrets === "string" ? M.secrets : M.secrets[0];
      if (M.sign === true)
        for (let [U, w] of Object.entries(X.set.cookie))
          X.set.cookie[U].value = I1(w.value, "${secret}");
      else
        for (let U of M.sign) {
          if (!(U in M.properties))
            continue;
          if (X.set.cookie[U]?.value)
            X.set.cookie[U].value = I1(X.set.cookie[U].value, O);
        }
    }
    return B1(L, X.set);
  } catch (F) {
    if (F.status)
      W.status = F.status;
    return $.handleError(X, F);
  } finally {
    for (let F of $.event.onResponse)
      await F(X);
  }
};
var hW = ($) => async (Y, W) => {
  const X = Object.assign(Y, W);
  X.set = Y.set;
  for (let Z = 0;Z < $.event.error.length; Z++) {
    let Q = $.event.error[Z](X);
    if (Q instanceof Promise)
      Q = await Q;
    if (Q !== undefined && Q !== null)
      return B1(Q, Y.set);
  }
  return new Response(typeof W.cause === "string" ? W.cause : W.message, { headers: Y.set.headers, status: W.status ?? 500 });
};
var R1 = X1(E$(), 1);
var U0 = X1(f0(), 1);
try {
  R1.TypeSystem.Format("email", ($) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test($)), R1.TypeSystem.Format("uuid", ($) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test($)), R1.TypeSystem.Format("date", ($) => !Number.isNaN(new Date($).getTime())), R1.TypeSystem.Format("date-time", ($) => !Number.isNaN(new Date($).getTime()));
} catch ($) {
}
var oW = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var P6 = ($, Y) => {
  if (!(Y instanceof Blob))
    return false;
  if ($.minSize && Y.size < oW($.minSize))
    return false;
  if ($.maxSize && Y.size > oW($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!Y.type.startsWith($.extension))
        return false;
    } else {
      for (let W = 0;W < $.extension.length; W++)
        if (Y.type.startsWith($.extension[W]))
          return true;
      return false;
    }
  return true;
};
var K7 = R1.TypeSystem.Type("Files", ($, Y) => {
  if (!Array.isArray(Y))
    return P6($, Y);
  if ($.minItems && Y.length < $.minItems)
    return false;
  if ($.maxItems && Y.length > $.maxItems)
    return false;
  for (let W = 0;W < Y.length; W++)
    if (!P6($, Y[W]))
      return false;
  return true;
});
var G1 = { Numeric: ($) => U0.Type.Transform(U0.Type.Union([U0.Type.String(), U0.Type.Number($)])).Decode((Y) => {
  const W = +Y;
  if (isNaN(W))
    return Y;
  return W;
}).Encode((Y) => Y), ObjectString: ($, Y) => U0.Type.Transform(U0.Type.Union([U0.Type.String(), U0.Type.Object($, Y)])).Decode((W) => {
  if (typeof W === "string")
    try {
      return JSON.parse(W);
    } catch {
      return W;
    }
  return W;
}).Encode((W) => JSON.stringify(W)), File: R1.TypeSystem.Type("File", P6), Files: ($) => U0.Type.Transform(U0.Type.Union([K7($)])).Decode((Y) => {
  if (Array.isArray(Y))
    return Y;
  return [Y];
}).Encode((Y) => Y), Nullable: ($) => ({ ...$, nullable: true }), MaybeEmpty: ($) => U0.Type.Union([U0.Type.Undefined(), $]), Cookie: ($, Y) => U0.Type.Object($, Y) };
U0.Type.ObjectString = G1.ObjectString;
U0.Type.Numeric = G1.Numeric;
U0.Type.File = ($ = {}) => G1.File({ default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
U0.Type.Files = ($ = {}) => G1.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });
U0.Type.Nullable = ($) => G1.Nullable($);
U0.Type.MaybeEmpty = G1.MaybeEmpty;
U0.Type.Cookie = G1.Cookie;

class c$ {
  config;
  dependencies = {};
  store = {};
  decorators = {};
  definitions = { type: {}, error: {} };
  schema = {};
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], onResponse: [], trace: [], error: [], stop: [] };
  reporter = new G6;
  server = null;
  validator = null;
  router = new E1;
  routes = [];
  staticRouter = { handlers: [], variables: "", map: {}, all: "" };
  dynamicRouter = new E1;
  lazyLoadModules = [];
  path = "";
  constructor($) {
    this.config = { forceErrorEncapsulation: false, prefix: "", aot: true, strictPath: false, scoped: false, cookie: {}, ...$, seed: $?.seed === undefined ? "" : $?.seed };
  }
  add($, Y, W, X, { allowMeta: Z = false, skipPrefix: Q = false } = { allowMeta: false, skipPrefix: false }) {
    if (typeof Y === "string")
      Y = [Y];
    for (let J of Y) {
      if (J = J === "" ? J : J.charCodeAt(0) === 47 ? J : `/${J}`, this.config.prefix && !Q)
        J = this.config.prefix + J;
      if (X?.type)
        switch (X.type) {
          case "text":
            X.type = "text/plain";
            break;
          case "json":
            X.type = "application/json";
            break;
          case "formdata":
            X.type = "multipart/form-data";
            break;
          case "urlencoded":
            X.type = "application/x-www-form-urlencoded";
            break;
          case "arrayBuffer":
            X.type = "application/octet-stream";
            break;
          default:
            break;
        }
      const q = this.definitions.type, F = U1(X?.cookie ?? this.validator?.cookie, { dynamic: !this.config.aot, models: q, additionalProperties: true });
      if (F && F1(this.config.cookie ?? []))
        F.schema = DW(F.schema, this.config.cookie ?? {});
      const D = { body: U1(X?.body ?? this.validator?.body, { dynamic: !this.config.aot, models: q }), headers: U1(X?.headers ?? this.validator?.headers, { dynamic: !this.config.aot, models: q, additionalProperties: true }), params: U1(X?.params ?? this.validator?.params, { dynamic: !this.config.aot, models: q }), query: U1(X?.query ?? this.validator?.query, { dynamic: !this.config.aot, models: q }), cookie: F, response: q6(X?.response ?? this.validator?.response, { dynamic: !this.config.aot, models: q }) }, K = C1(this.event, X), A = J.endsWith("/") ? J.slice(0, J.length - 1) : J + "/";
      if (this.config.aot === false) {
        if (this.dynamicRouter.add($, J, { validator: D, hooks: K, content: X?.type, handle: W }), this.config.strictPath === false)
          this.dynamicRouter.add($, A, { validator: D, hooks: K, content: X?.type, handle: W });
        this.routes.push({ method: $, path: J, composed: null, handler: W, hooks: K });
        return;
      }
      const I = nW({ path: J, method: $, hooks: K, validator: D, handler: W, handleError: this.handleError, onRequest: this.event.request, config: this.config, definitions: Z ? this.definitions.type : undefined, schema: Z ? this.schema : undefined, reporter: this.reporter });
      if (this.routes.push({ method: $, path: J, composed: I, handler: W, hooks: K }), J.indexOf(":") === -1 && J.indexOf("*") === -1) {
        const j = this.staticRouter.handlers.length;
        if (this.staticRouter.handlers.push(I), this.staticRouter.variables += `const st${j} = staticRouter.handlers[${j}]\n`, !this.staticRouter.map[J])
          this.staticRouter.map[J] = { code: "" };
        if ($ === "ALL")
          this.staticRouter.map[J].all = `default: return st${j}(ctx)\n`;
        else
          this.staticRouter.map[J].code += `case '${$}': return st${j}(ctx)\n`;
        if (!this.config.strictPath) {
          if (!this.staticRouter.map[A])
            this.staticRouter.map[A] = { code: "" };
          if ($ === "ALL")
            this.staticRouter.map[A].all = `default: return st${j}(ctx)\n`;
          else
            this.staticRouter.map[A].code += `case '${$}': return st${j}(ctx)\n`;
        }
      } else if (this.router.add($, J, I), !this.config.strictPath)
        this.router.add($, J.endsWith("/") ? J.slice(0, J.length - 1) : J + "/", I);
    }
  }
  onStart($) {
    return this.on("start", $), this;
  }
  onRequest($) {
    return this.on("request", $), this;
  }
  onParse($) {
    return this.on("parse", $), this;
  }
  onTransform($) {
    return this.on("transform", $), this;
  }
  onBeforeHandle($) {
    return this.on("beforeHandle", $), this;
  }
  onAfterHandle($) {
    return this.on("afterHandle", $), this;
  }
  onResponse($) {
    return this.on("response", $), this;
  }
  trace($) {
    return this.reporter.on("event", _6(this.reporter, $)), this.on("trace", $), this;
  }
  addError($, Y) {
    return this.error($, Y);
  }
  error($, Y) {
    switch (typeof $) {
      case "string":
        return Y.prototype[o1] = $, this.definitions.error[$] = Y, this;
      case "function":
        return this.definitions.error = $(this.definitions.error), this;
    }
    for (let [W, X] of Object.entries($))
      X.prototype[o1] = W, this.definitions.error[W] = X;
    return this;
  }
  onError($) {
    return this.on("error", $), this;
  }
  onStop($) {
    return this.on("stop", $), this;
  }
  on($, Y) {
    for (let W of Array.isArray(Y) ? Y : [Y])
      switch (W = wW(W), $) {
        case "start":
          this.event.start.push(W);
          break;
        case "request":
          this.event.request.push(W);
          break;
        case "response":
          this.event.onResponse.push(W);
          break;
        case "parse":
          this.event.parse.splice(this.event.parse.length - 1, 0, W);
          break;
        case "transform":
          this.event.transform.push(W);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(W);
          break;
        case "afterHandle":
          this.event.afterHandle.push(W);
          break;
        case "trace":
          this.event.trace.push(W);
          break;
        case "error":
          this.event.error.push(W);
          break;
        case "stop":
          this.event.stop.push(W);
          break;
      }
    return this;
  }
  group($, Y, W) {
    const X = new c$({ ...this.config, prefix: "" });
    X.store = this.store;
    const Z = typeof Y === "object", Q = (Z ? W : Y)(X);
    if (this.decorators = M1(this.decorators, X.decorators), Q.event.request.length)
      this.event.request = [...this.event.request, ...Q.event.request];
    if (Q.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...Q.event.onResponse];
    return this.model(Q.definitions.type), Object.values(X.routes).forEach(({ method: J, path: q, handler: F, hooks: D }) => {
      if (q = this.config.prefix + $ + q, Z) {
        const K = Y, A = D;
        this.add(J, q, F, C1(K, { ...A, error: !A.error ? Q.event.error : Array.isArray(A.error) ? [...A.error, ...Q.event.error] : [A.error, ...Q.event.error] }));
      } else
        this.add(J, q, F, C1(D, { error: Q.event.error }), { skipPrefix: true });
    }), this;
  }
  guard($, Y) {
    if (!Y)
      return this.event = m$(this.event, $), this.validator = { body: $.body, headers: $.headers, params: $.params, query: $.query, response: $.response }, this;
    const W = new c$;
    W.store = this.store;
    const X = Y(W);
    if (this.decorators = M1(this.decorators, W.decorators), X.event.request.length)
      this.event.request = [...this.event.request, ...X.event.request];
    if (X.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...X.event.onResponse];
    return this.model(X.definitions.type), Object.values(W.routes).forEach(({ method: Z, path: Q, handler: J, hooks: q }) => {
      this.add(Z, Q, J, C1($, { ...q, error: !q.error ? X.event.error : Array.isArray(q.error) ? [...q.error, ...X.event.error] : [q.error, ...X.event.error] }));
    }), this;
  }
  use($) {
    if ($ instanceof Promise)
      return this.lazyLoadModules.push($.then((Y) => {
        if (typeof Y === "function")
          return Y(this);
        if (typeof Y.default === "function")
          return Y.default(this);
        return this._use(Y.default);
      }).then((Y) => Y.compile())), this;
    else
      return this._use($);
    return this;
  }
  _use($) {
    if (typeof $ === "function") {
      const Z = $(this);
      if (Z instanceof Promise)
        return this.lazyLoadModules.push(Z.then((Q) => Q.compile())), this;
      return Z;
    }
    const { name: Y, seed: W } = $.config, X = $.config.scoped;
    if (X) {
      if (Y) {
        if (!(Y in this.dependencies))
          this.dependencies[Y] = [];
        const Z = W !== undefined ? N6(Y + JSON.stringify(W)) : 0;
        if (this.dependencies[Y].some((Q) => Z === Q))
          return this;
        this.dependencies[Y].push(Z);
      }
      if ($.model(this.definitions.type), $.error(this.definitions.error), $.onRequest((Z) => {
        Object.assign(Z, this.decorators), Object.assign(Z.store, this.store);
      }), $.config.aot)
        $.compile();
      return this.mount($.fetch);
    }
    this.decorate($.decorators), this.state($.store), this.model($.definitions.type), this.error($.definitions.error);
    for (let { method: Z, path: Q, handler: J, hooks: q } of Object.values($.routes))
      this.add(Z, Q, J, C1(q, { error: $.event.error }));
    if (!X)
      if (Y) {
        if (!(Y in this.dependencies))
          this.dependencies[Y] = [];
        const Z = W !== undefined ? N6(Y + JSON.stringify(W)) : 0;
        if (this.dependencies[Y].some((Q) => Z === Q))
          return this;
        this.dependencies[Y].push(Z), this.event = m$(this.event, M6($.event), Z);
      } else
        this.event = m$(this.event, M6($.event));
    return this;
  }
  mount($, Y) {
    if (typeof $ === "function" || $.length === 0 || $ === "/") {
      const Z = typeof $ === "function" ? $ : Y, Q = async ({ request: J, path: q }) => Z(new Request("http://a.cc" + q || "/", J));
      return this.all("/", Q, { type: "none" }), this.all("/*", Q, { type: "none" }), this;
    }
    const W = $.length, X = async ({ request: Z, path: Q }) => Y(new Request("http://a.cc" + Q.slice(W) || "/", Z));
    return this.all($, X, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), X, { type: "none" }), this;
  }
  get($, Y, W) {
    return this.add("GET", $, Y, W), this;
  }
  post($, Y, W) {
    return this.add("POST", $, Y, W), this;
  }
  put($, Y, W) {
    return this.add("PUT", $, Y, W), this;
  }
  patch($, Y, W) {
    return this.add("PATCH", $, Y, W), this;
  }
  delete($, Y, W) {
    return this.add("DELETE", $, Y, W), this;
  }
  options($, Y, W) {
    return this.add("OPTIONS", $, Y, W), this;
  }
  all($, Y, W) {
    return this.add("ALL", $, Y, W), this;
  }
  head($, Y, W) {
    return this.add("HEAD", $, Y, W), this;
  }
  connect($, Y, W) {
    return this.add("CONNECT", $, Y, W), this;
  }
  ws($, Y) {
    const W = Y.transformMessage ? Array.isArray(Y.transformMessage) ? Y.transformMessage : [Y.transformMessage] : undefined;
    return this.get($, (X) => {
      const { set: Z, path: Q, qi: J, ...q } = X;
      X.headers, X.query, X.params;
      const F = U1(Y?.body, { models: this.definitions.type }), D = U1(Y?.response, { models: this.definitions.type }), K = (A) => {
        const I = A.charCodeAt(0);
        if (I === 47 || I === 123)
          try {
            A = JSON.parse(A);
          } catch {
          }
        else if (!Number.isNaN(+A))
          A = +A;
        if (W?.length)
          for (let j = 0;j < W.length; j++) {
            const M = W[j](A);
            if (M !== undefined)
              A = M;
          }
        return A;
      };
      if (this.server?.upgrade(X.request, { headers: typeof Y.upgrade === "function" ? Y.upgrade(X) : Y.upgrade, data: { validator: D, open(A) {
        Y.open?.(new c1(A, q));
      }, message: (A, I) => {
        const j = K(I);
        if (F?.Check(j) === false)
          return void A.send(new j0("message", F, j).message);
        Y.message?.(new c1(A, q), j);
      }, drain(A) {
        Y.drain?.(new c1(A, q));
      }, close(A, I, j) {
        Y.close?.(new c1(A, q), I, j);
      } } }))
        return;
      return Z.status = 400, "Expected a websocket connection";
    }, { beforeHandle: Y.beforeHandle, transform: Y.transform, headers: Y.headers, params: Y.params, query: Y.query }), this;
  }
  route($, Y, W, { config: X, ...Z } = { config: { allowMeta: false } }) {
    return this.add($, Y, W, Z, X), this;
  }
  state($, Y) {
    switch (typeof $) {
      case "object":
        return this.store = M1(this.store, $), this;
      case "function":
        return this.store = $(this.store), this;
    }
    if (!($ in this.store))
      this.store[$] = Y;
    return this;
  }
  decorate($, Y) {
    switch (typeof $) {
      case "object":
        return this.decorators = M1(this.decorators, $), this;
      case "function":
        return this.decorators = $(this.decorators), this;
    }
    if (!($ in this.decorators))
      this.decorators[$] = Y;
    return this;
  }
  derive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  model($, Y) {
    switch (typeof $) {
      case "object":
        return Object.entries($).forEach(([W, X]) => {
          if (!(W in this.definitions.type))
            this.definitions.type[W] = X;
        }), this;
      case "function":
        return this.definitions.type = $(this.definitions.type), this;
    }
    return this.definitions.type[$] = Y, this;
  }
  mapDerive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  affix($, Y, W) {
    if (W === "")
      return this;
    const X = ["_", "-", " "], Z = (F) => F[0].toUpperCase() + F.slice(1), Q = $ === "prefix" ? (F, D) => X.includes(F.at(-1) ?? "") ? F + D : F + Z(D) : X.includes(W.at(-1) ?? "") ? (F, D) => D + F : (F, D) => D + Z(F), J = (F) => {
      const D = {};
      switch (F) {
        case "decorator":
          for (let K in this.decorators)
            D[Q(W, K)] = this.decorators[K];
          this.decorators = D;
          break;
        case "state":
          for (let K in this.store)
            D[Q(W, K)] = this.store[K];
          this.store = D;
          break;
        case "model":
          for (let K in this.definitions.type)
            D[Q(W, K)] = this.definitions.type[K];
          this.definitions.type = D;
          break;
        case "error":
          for (let K in this.definitions.error)
            D[Q(W, K)] = this.definitions.error[K];
          this.definitions.error = D;
          break;
      }
    }, q = Array.isArray(Y) ? Y : [Y];
    for (let F of q.some((D) => D === "all") ? ["decorator", "state", "model", "error"] : q)
      J(F);
    return this;
  }
  prefix($, Y) {
    return this.affix("prefix", $, Y);
  }
  suffix($, Y) {
    return this.affix("suffix", $, Y);
  }
  compile() {
    if (this.fetch = this.config.aot ? w6(this) : j6(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => (this.fetch = this.config.aot ? w6(this) : j6(this))($);
  handleError = async ($, Y) => (this.handleError = this.config.aot ? K6(this) : hW(this))($, Y);
  outerErrorHandler = ($) => new Response($.message || $.name || "Error", { status: $?.status ?? 500 });
  listen = ($, Y) => {
    if (!Bun)
      throw new Error("Bun to run");
    if (this.compile(), typeof $ === "string") {
      if ($ = +$.trim(), Number.isNaN($))
        throw new Error("Port must be a numeric value");
    }
    const W = this.fetch, X = typeof $ === "object" ? { development: !N$, ...this.config.serve, ...$, websocket: { ...this.config.websocket, ...W6 }, fetch: W, error: this.outerErrorHandler } : { development: !N$, ...this.config.serve, websocket: { ...this.config.websocket, ...W6 }, port: $, fetch: W, error: this.outerErrorHandler };
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (this.server = Bun?.serve(X), this.event.start.length) {
      const Z = Object.assign(this.decorators, { store: this.store, app: this });
      for (let Q = 0;Q < this.event.start.length; Q++)
        this.event.start[Q](Z);
    }
    if (Y)
      Y(this.server);
    return Promise.all(this.lazyLoadModules).then(() => {
      Bun?.gc(false);
    }), this;
  };
  stop = async () => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server.stop(), this.event.stop.length) {
      const $ = Object.assign(this.decorators, { store: this.store, app: this });
      for (let Y = 0;Y < this.event.stop.length; Y++)
        await this.event.stop[Y]($);
    }
  };
  get modules() {
    return Promise.all(this.lazyLoadModules);
  }
}
var export_t = U0.Type;

// node_modules/@libsql/hrana-cli
var setErrorMap = function(map) {
  overrideErrorMap = map;
};
var getErrorMap = function() {
  return overrideErrorMap;
};
var addIssueToContext = function(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
};
var processCreateParams = function(params) {
  if (!params)
    return {};
  const { errorMap, invalid_type_error, required_error, description } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap)
    return { errorMap, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== undefined ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== undefined ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
};
var isValidIP = function(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
};
var floatSafeRemainder = function(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
};
var deepPartialify = function(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
};
var mergeValues = function(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
};
var createZodEnum = function(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
};
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};

class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === undefined ? undefined : params.async) !== null && _a !== undefined ? _a : false,
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
        async: true
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^([A-Z0-9_+-]+\.?)*[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z\$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z\$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z\$`);
    }
  }
};

class ZodString extends ZodType {
  constructor() {
    super(...arguments);
    this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
    this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
    this.trim = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
    this.toLowerCase = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
    this.toUpperCase = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      offset: (_a = options === null || options === undefined ? undefined : options.offset) !== null && _a !== undefined ? _a : false,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === undefined ? undefined : options.position,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === undefined ? undefined : _b.call(_a, issue, ctx).message) !== null && _c !== undefined ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};

class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== undefined ? _a : fatal) !== null && _b !== undefined ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/@libsql/hrana-client/lib-esm/en
var h = function(e) {
  let t = e.runtimeEnvStrict ?? e.runtimeEnv ?? process.env;
  if (!!e.skipValidation)
    return t;
  let a = typeof e.client == "object" ? e.client : {}, l = typeof e.server == "object" ? e.server : {}, c = typeof e.shared == "object" ? e.shared : {}, d = z.object(a), v = z.object(l), i = z.object(c), T = e.isServer ?? typeof window > "u", f = d.merge(i), x = v.merge(i).merge(d), o = T ? x.safeParse(t) : f.safeParse(t), y = e.onValidationError ?? ((n) => {
    throw console.error("\u274C Invalid environment variables:", n.flatten().fieldErrors), new Error("Invalid environment variables");
  }), p = e.onInvalidAccess ?? ((n) => {
    throw new Error("\u274C Attempted to access a server-side environment variable on the client");
  });
  return o.success === false ? y(o.error) : new Proxy(o.data, { get(n, r) {
    if (typeof r == "string")
      return !T && e.clientPrefix && !r.startsWith(e.clientPrefix) && i.shape[r] === undefined ? p(r) : n[r];
  } });
};

// node_modules/@libsq
var env = h({
  server: {
    LOG_LEVEL: z.enum(["debug", "info", "warn", "error"]),
    DATABASE_CONNECTION_TYPE: z.enum(["local", "remote", "local-replica"]),
    DATABASE_URL: z.string().min(1),
    DATABASE_AUTH_TOKEN: z.string().optional().refine((s) => {
      const type = "remote";
      return type === "remote" || type === "local-replica" ? s && s.length > 0 : true;
    }),
    NODE_ENV: z.enum(["development", "production"]),
    GITHUB_CLIENT_ID: z.string(),
    GITHUB_CLIENT_SECRET: z.string()
  },
  runtimeEnv: process.env
});
var args = {};
var config = {
  env,
  args
};

// node_modules/@libsql/hrana-client/lib-e
var parseCookie = (str) => {
  const obj = {};
  let index = 0;
  while (index < str.length) {
    const eqIdx = str.indexOf("=", index);
    if (eqIdx === -1) {
      break;
    }
    let endIdx = str.indexOf(";", index);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    const key = str.slice(index, eqIdx).trim();
    if (!(key in obj)) {
      let val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.charCodeAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key] = tryDecode(val);
    }
    index = endIdx + 1;
  }
  return obj;
};
var serializeCookie = (name, val, options) => {
  const opt = options ?? {};
  const enc = opt.encode ?? encodeURIComponent;
  const value = enc(val);
  let str = name + "=" + value;
  if (opt.maxAge != null) {
    const maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    const expires = opt.expires;
    str += "; Expires=" + expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.priority) {
    const priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low":
        str += "; Priority=Low";
        break;
      case "medium":
        str += "; Priority=Medium";
        break;
      case "high":
        str += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (opt.sameSite) {
    const sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
};
var tryDecode = (str) => {
  try {
    return decodeURIComponent(str);
  } catch (e) {
    return str;
  }
};

// node_modules/@libsql/hrana-client/lib-
var DEFAULT_SESSION_COOKIE_NAME = "auth_session";
var defaultSessionCookieAttributes = {
  sameSite: "lax",
  path: "/"
};
var createSessionCookie = (session, options) => {
  let expires;
  if (session === null) {
    expires = 0;
  } else if (options.cookie.expires !== false) {
    expires = session.idlePeriodExpiresAt.getTime();
  } else {
    expires = Date.now() + 1000 * 60 * 60 * 24 * 365;
  }
  return new Cookie(options.cookie.name ?? DEFAULT_SESSION_COOKIE_NAME, session?.sessionId ?? "", {
    ...options.cookie.attributes ?? defaultSessionCookieAttributes,
    httpOnly: true,
    expires: new Date(expires),
    secure: options.env === "PROD"
  });
};

class Cookie {
  constructor(name, value, options) {
    this.name = name;
    this.value = value;
    this.attributes = options;
  }
  name;
  value;
  attributes;
  serialize = () => {
    return serializeCookie(this.name, this.value, this.attributes);
  };
}

// node_modules/@libsql/hrana-client/li
var logError = (message) => {
  console.log("\x1B[31m%s\x1B[31m", `[LUCIA_ERROR] ${message}`);
};

// node_modules/@libsql/hrana-client/lib
class LuciaError extends Error {
  constructor(errorMsg, detail) {
    super(errorMsg);
    this.message = errorMsg;
    this.detail = detail ?? "";
  }
  detail;
  message;
}

// node_modules/@libsql/hrana-client/lib-e
var pbkdf2 = async (password, salt, options) => {
  const pwKey = await crypto.subtle.importKey("raw", password, "PBKDF2", false, ["deriveBits"]);
  const keyBuffer = await crypto.subtle.deriveBits({
    name: "PBKDF2",
    hash: "SHA-256",
    salt,
    iterations: options.c
  }, pwKey, options.dkLen * 8);
  return new Uint8Array(keyBuffer);
};

// node_modules/@libsql/hrana-client/lib-e
function checkOpts(defaults, opts) {
  const merged = Object.assign(defaults, opts);
  return merged;
}
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var nextTick = async () => {
};
var asyncLoop = async (iters, tick, cb) => {
  let ts = Date.now();
  for (let i = 0;i < iters; i++) {
    cb(i);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick();
    ts += diff;
  }
};

// node_modules/@libsql/hrana-client/lib-e
var rotl = (a, b) => a << b | a >>> 32 - b;
var XorAndSalsa = (prev, pi, input, ii, out, oi) => {
  const y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  const y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  const y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  const y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  const y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  const y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  const y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  const y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0;i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
};
var BlockMix = (input, ii, out, oi, r) => {
  let head = oi + 0;
  let tail = oi + 16 * r;
  for (let i = 0;i < 16; i++)
    out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
  for (let i = 0;i < r; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
};
var scryptInit = async (password, salt, _opts) => {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  if (onProgress !== undefined && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N + p);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = await pbkdf2(password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  const V = u32(new Uint8Array(blockSize * N));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
};
var scrypt_default = async (password, salt, opts) => {
  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = await scryptInit(password, salt, opts);
  for (let pi = 0;pi < p; pi++) {
    const Pi = blockSize32 * pi;
    for (let i = 0;i < blockSize32; i++)
      V[i] = B32[Pi + i];
    let pos = 0;
    await asyncLoop(N - 1, asyncTick, (i) => {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    });
    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
    blockMixCb();
    await asyncLoop(N, asyncTick, (i) => {
      const j = B32[Pi + blockSize32 - 16] % N;
      for (let k = 0;k < blockSize32; k++)
        tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi, r);
      blockMixCb();
    });
  }
  const res = await pbkdf2(password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
};

// node_modules/@libsql/hrana-client/lib-e
var getRandomValues = (bytes) => {
  return crypto.getRandomValues(new Uint8Array(bytes));
};
var DEFAULT_ALPHABET = "abcdefghijklmnopqrstuvwxyz1234567890";
var generateRandomString = (size, alphabet = DEFAULT_ALPHABET) => {
  const mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
  const step = -~(1.6 * mask * size / alphabet.length);
  let bytes = getRandomValues(step);
  let id = "";
  let index = 0;
  while (id.length !== size) {
    id += alphabet[bytes[index] & mask] ?? "";
    index += 1;
    if (index > bytes.length) {
      bytes = getRandomValues(step);
      index = 0;
    }
  }
  return id;
};

// node_modules/@libsql/hrana-client/lib-e
var generateScryptHash = async (s) => {
  const salt = generateRandomString(16);
  const key = await hashWithScrypt(s.normalize("NFKC"), salt);
  return `s2:${salt}:${key}`;
};
var hashWithScrypt = async (s, salt, blockSize = 16) => {
  const keyUint8Array = await scrypt_default(new TextEncoder().encode(s), new TextEncoder().encode(salt), {
    N: 16384,
    r: blockSize,
    p: 1,
    dkLen: 64
  });
  return convertUint8ArrayToHex(keyUint8Array);
};
var validateScryptHash = async (s, hash) => {
  if (hash.startsWith("$2a")) {
    throw new LuciaError("AUTH_OUTDATED_PASSWORD");
  }
  const arr = hash.split(":");
  if (arr.length === 2) {
    const [salt2, key2] = arr;
    const targetKey = await hashWithScrypt(s.normalize("NFKC"), salt2, 8);
    const result = constantTimeEqual(targetKey, key2);
    return result;
  }
  if (arr.length !== 3)
    return false;
  const [version, salt, key] = arr;
  if (version === "s2") {
    const targetKey = await hashWithScrypt(s.normalize("NFKC"), salt);
    const result = constantTimeEqual(targetKey, key);
    return result;
  }
  return false;
};
var constantTimeEqual = (a, b) => {
  if (a.length !== b.length) {
    return false;
  }
  const aUint8Array = new TextEncoder().encode(a);
  const bUint8Array = new TextEncoder().encode(b);
  let c = 0;
  for (let i = 0;i < a.length; i++) {
    c |= aUint8Array[i] ^ bUint8Array[i];
  }
  return c === 0;
};
var convertUint8ArrayToHex = (arr) => {
  return [...arr].map((x) => x.toString(16).padStart(2, "0")).join("");
};

// node_modules/@libsql/hrana-client/lib
var isWithinExpiration = (expiresInMs) => {
  const currentTime = Date.now();
  if (currentTime > expiresInMs)
    return false;
  return true;
};

// node_modules/@libsql/hrana-client/lib-e
var isValidDatabaseSession = (databaseSession) => {
  return isWithinExpiration(databaseSession.idle_expires);
};

// node_modules/@libsql/hrana-client/lib-
var DEBUG_GLOBAL = "__lucia_debug_mode";
var ESCAPE = "\x1B";
var DEFAULT_TEXT_FORMAT = "\x1B[0m";
var DEFAULT_FG_BG = `${ESCAPE}[0m`;
var RED_CODE = 9;
var LUCIA_COLOR_CODE = 63;
var WHITE_CODE = 231;
var GREEN_CODE = 34;
var CYAN_CODE = 6;
var YELLOW_CODE = 3;
var PURPLE_CODE = 5;
var BLUE_CODE = 4;
var globalContext = globalThis;
globalContext[DEBUG_GLOBAL] = false;
var format = (text, format2, removeFormat) => {
  return `${format2}${text}${removeFormat ? removeFormat : DEFAULT_TEXT_FORMAT}`;
};
var bgFormat = (text, colorCode) => {
  return format(text, `${ESCAPE}[48;5;${colorCode}m`, DEFAULT_FG_BG);
};
var fgFormat = (text, colorCode) => {
  return format(text, `${ESCAPE}[38;5;${colorCode}m`, DEFAULT_FG_BG);
};
var bg = {
  lucia: (text) => bgFormat(text, LUCIA_COLOR_CODE),
  red: (text) => bgFormat(text, RED_CODE),
  white: (text) => bgFormat(text, WHITE_CODE),
  green: (text) => bgFormat(text, GREEN_CODE),
  cyan: (text) => bgFormat(text, CYAN_CODE),
  yellow: (text) => bgFormat(text, YELLOW_CODE),
  purple: (text) => bgFormat(text, PURPLE_CODE),
  blue: (text) => bgFormat(text, BLUE_CODE)
};
var fg = {
  lucia: (text) => fgFormat(text, LUCIA_COLOR_CODE),
  red: (text) => fgFormat(text, RED_CODE),
  white: (text) => fgFormat(text, WHITE_CODE),
  green: (text) => fgFormat(text, GREEN_CODE),
  cyan: (text) => fgFormat(text, CYAN_CODE),
  yellow: (text) => fgFormat(text, YELLOW_CODE),
  purple: (text) => fgFormat(text, PURPLE_CODE),
  blue: (text) => fgFormat(text, BLUE_CODE),
  default: (text) => format(text, DEFAULT_TEXT_FORMAT)
};
var bold = (text) => {
  return format(text, `${ESCAPE}[1m`, `${ESCAPE}[22m`);
};
var dim = (text) => {
  return format(text, `${ESCAPE}[2m`, `${ESCAPE}[22m`);
};
var isDebugModeEnabled = () => {
  return Boolean(globalContext[DEBUG_GLOBAL]);
};
var linebreak = () => console.log("");
var createCategory = (name, themeTextColor) => {
  const createLogger = (textColor = fg.default) => {
    return (text, subtext) => {
      if (!isDebugModeEnabled())
        return;
      if (subtext) {
        return log(themeTextColor(`[${name}]`), `${textColor(text)}`, subtext);
      }
      log(themeTextColor(`[${name}]`), `${textColor(text)}`);
    };
  };
  return {
    info: createLogger(),
    notice: createLogger(fg.yellow),
    fail: createLogger(fg.red),
    success: createLogger(fg.green)
  };
};
var enableDebugMode = () => {
  globalContext[DEBUG_GLOBAL] = true;
};
var disableDebugMode = () => {
  globalContext[DEBUG_GLOBAL] = false;
};
var debug = {
  init: (debugEnabled) => {
    if (debugEnabled) {
      enableDebugMode();
      linebreak();
      console.log(` ${bg.lucia(bold(fg.white(" lucia ")))}  ${fg.lucia(bold("Debug mode enabled"))}`);
    } else {
      disableDebugMode();
    }
  },
  request: {
    init: (method, href) => {
      if (!isDebugModeEnabled())
        return;
      linebreak();
      const getUrl = () => {
        try {
          const url = new URL(href);
          return url.origin + url.pathname;
        } catch {
          return href;
        }
      };
      log(bg.cyan(bold(fg.white(" request "))), fg.cyan(`${method.toUpperCase()} ${getUrl()}`));
    },
    ...createCategory("request", fg.cyan)
  },
  session: createCategory("session", fg.purple),
  key: createCategory("key", fg.blue)
};
var log = (type, text, subtext) => {
  if (!subtext) {
    return console.log(`${dim(new Date().toLocaleTimeString())}  ${type} ${text}`);
  }
  console.log(`${dim(new Date().toLocaleTimeString())}  ${type} ${text} ${dim(subtext)}`);
};

// node_modules/@libsql/hrana-client/lib-es
var createHeadersFromObject = (headersObject) => {
  const headers = new Headers;
  for (const [key, value] of Object.entries(headersObject)) {
    if (value === null || value === undefined)
      continue;
    if (typeof value === "string") {
      headers.set(key, value);
    } else {
      for (const item of value) {
        headers.append(key, item);
      }
    }
  }
  return headers;
};

// node_modules/@libsql/hrana-client/li
var isAllowedOrigin = (origin, host, allowedSubdomains) => {
  const originHost = new URL(origin).host;
  const baseDomain = getBaseDomain(host);
  if (host.length < 1 || origin.length < 1)
    return false;
  if (originHost === host)
    return true;
  if (allowedSubdomains === "*") {
    if (originHost.endsWith(`.${baseDomain}`))
      return true;
    return false;
  }
  for (const subdomain of allowedSubdomains) {
    const allowedHostPermutation = subdomain === null ? baseDomain : [subdomain, baseDomain].join(".");
    if (allowedHostPermutation === originHost)
      return true;
  }
  return false;
};
var getBaseDomain = (host) => {
  if (host.startsWith("localhost:"))
    return host;
  return host.split(".").slice(-2).join(".");
};
var safeParseUrl = (url) => {
  try {
    return new URL(url);
  } catch {
    return null;
  }
};

// node_modules/@libsql/hrana-client/lib-e
class AuthRequest {
  auth;
  requestContext;
  constructor(auth, config2) {
    debug.request.init(config2.requestContext.request.method, config2.requestContext.request.url ?? "(url unknown)");
    this.auth = auth;
    this.requestContext = config2.requestContext;
    const csrfProtectionConfig = typeof config2.csrfProtection === "object" ? config2.csrfProtection : {};
    const csrfProtectionEnabled = config2.csrfProtection !== false;
    if (!csrfProtectionEnabled || isValidRequestOrigin(this.requestContext.request, csrfProtectionConfig)) {
      this.storedSessionId = this.requestContext.sessionCookie ?? auth.readSessionCookie(this.requestContext.request.headers.get("Cookie"));
    } else {
      this.storedSessionId = null;
    }
    this.bearerToken = auth.readBearerToken(this.requestContext.request.headers.get("Authorization"));
  }
  validatePromise = null;
  validateBearerTokenPromise = null;
  storedSessionId;
  bearerToken;
  setSession = (session) => {
    const sessionId = session?.sessionId ?? null;
    if (this.storedSessionId === sessionId)
      return;
    this.validatePromise = null;
    this.setSessionCookie(session);
  };
  maybeSetSession = (session) => {
    try {
      this.setSession(session);
    } catch {
    }
  };
  setSessionCookie = (session) => {
    const sessionId = session?.sessionId ?? null;
    if (this.storedSessionId === sessionId)
      return;
    this.storedSessionId = sessionId;
    this.requestContext.setCookie(this.auth.createSessionCookie(session));
    if (session) {
      debug.request.notice("Session cookie stored", session.sessionId);
    } else {
      debug.request.notice("Session cookie deleted");
    }
  };
  validate = async () => {
    if (this.validatePromise) {
      debug.request.info("Using cached result for session validation");
      return this.validatePromise;
    }
    this.validatePromise = new Promise(async (resolve2) => {
      if (!this.storedSessionId)
        return resolve2(null);
      try {
        const session = await this.auth.validateSession(this.storedSessionId);
        if (session.fresh) {
          this.maybeSetSession(session);
        }
        return resolve2(session);
      } catch (e) {
        if (e instanceof LuciaError && e.message === "AUTH_INVALID_SESSION_ID") {
          this.maybeSetSession(null);
          return resolve2(null);
        }
        throw e;
      }
    });
    return await this.validatePromise;
  };
  validateBearerToken = async () => {
    if (this.validateBearerTokenPromise) {
      debug.request.info("Using cached result for bearer token validation");
      return this.validatePromise;
    }
    this.validatePromise = new Promise(async (resolve2) => {
      if (!this.bearerToken)
        return resolve2(null);
      try {
        const session = await this.auth.validateSession(this.bearerToken);
        return resolve2(session);
      } catch (e) {
        if (e instanceof LuciaError) {
          return resolve2(null);
        }
        throw e;
      }
    });
    return await this.validatePromise;
  };
}
var isValidRequestOrigin = (request2, config2) => {
  const whitelist = ["GET", "HEAD", "OPTIONS", "TRACE"];
  if (whitelist.some((val) => val === request2.method.toUpperCase())) {
    return true;
  }
  const requestOrigin = request2.headers.get("Origin");
  if (!requestOrigin)
    return false;
  if (!requestOrigin) {
    debug.request.fail("No request origin available");
    return false;
  }
  let host = null;
  if (config2.host !== undefined) {
    host = config2.host ?? null;
  } else if (request2.url !== null && request2.url !== undefined) {
    host = safeParseUrl(request2.url)?.host ?? null;
  } else {
    host = request2.headers.get(config2.hostHeader ?? "Host");
  }
  if (host !== null && isAllowedOrigin(requestOrigin, host, config2.allowedSubDomains ?? [])) {
    debug.request.info("Valid request origin", requestOrigin);
    return true;
  }
  debug.request.info("Invalid request origin", requestOrigin);
  return false;
};
var transformRequestContext = ({ request: request2, setCookie, sessionCookie }) => {
  return {
    request: {
      url: request2.url,
      method: request2.method,
      headers: "authorization" in request2.headers ? createHeadersFromObject(request2.headers) : request2.headers
    },
    setCookie,
    sessionCookie: sessionCookie ?? request2.storedSessionCookie
  };
};

// node_modules/@libsql/hrana-client/lib-esm/e
var lucia = () => {
  return ({ args: args2 }) => args2[0];
};

// node_modules/@libsql/hrana-client/lib-e
var createAdapter = (adapter) => {
  if (!("user" in adapter))
    return adapter(LuciaError);
  let userAdapter = adapter.user(LuciaError);
  let sessionAdapter = adapter.session(LuciaError);
  if ("getSessionAndUser" in userAdapter) {
    const { getSessionAndUser: _, ...extractedUserAdapter } = userAdapter;
    userAdapter = extractedUserAdapter;
  }
  if ("getSessionAndUser" in sessionAdapter) {
    const { getSessionAndUser: _, ...extractedSessionAdapter } = sessionAdapter;
    sessionAdapter = extractedSessionAdapter;
  }
  return {
    ...userAdapter,
    ...sessionAdapter
  };
};

// node_modules/@libsql/hrana-client/lib-es
var createKeyId = (providerId, providerUserId) => {
  if (providerId.includes(":")) {
    throw new TypeError("Provider id must not include any colons (:)");
  }
  return `${providerId}:${providerUserId}`;
};

// node_modules/@libsql/hrana-client/lib
var lucia2 = (config2) => {
  return new Auth(config2);
};
var validateConfiguration = (config2) => {
  const adapterProvided = config2.adapter;
  if (!adapterProvided) {
    logError('Adapter is not defined in configuration ("config.adapter")');
    process.exit(1);
  }
};

class Auth {
  adapter;
  sessionCookieConfig;
  sessionExpiresIn;
  csrfProtection;
  env;
  passwordHash = {
    generate: generateScryptHash,
    validate: validateScryptHash
  };
  middleware = lucia();
  experimental;
  constructor(config2) {
    validateConfiguration(config2);
    this.adapter = createAdapter(config2.adapter);
    this.env = config2.env;
    this.sessionExpiresIn = {
      activePeriod: config2.sessionExpiresIn?.activePeriod ?? 1000 * 60 * 60 * 24,
      idlePeriod: config2.sessionExpiresIn?.idlePeriod ?? 1000 * 60 * 60 * 24 * 14
    };
    this.getUserAttributes = (databaseUser) => {
      const defaultTransform = () => {
        return {};
      };
      const transform = config2.getUserAttributes ?? defaultTransform;
      return transform(databaseUser);
    };
    this.getSessionAttributes = (databaseSession) => {
      const defaultTransform = () => {
        return {};
      };
      const transform = config2.getSessionAttributes ?? defaultTransform;
      return transform(databaseSession);
    };
    this.csrfProtection = config2.csrfProtection ?? true;
    this.sessionCookieConfig = config2.sessionCookie ?? {};
    if (config2.passwordHash) {
      this.passwordHash = config2.passwordHash;
    }
    if (config2.middleware) {
      this.middleware = config2.middleware;
    }
    this.experimental = {
      debugMode: config2.experimental?.debugMode ?? false
    };
    debug.init(this.experimental.debugMode);
  }
  getUserAttributes;
  getSessionAttributes;
  transformDatabaseUser = (databaseUser) => {
    const attributes = this.getUserAttributes(databaseUser);
    return {
      ...attributes,
      userId: databaseUser.id
    };
  };
  transformDatabaseKey = (databaseKey) => {
    const [providerId, ...providerUserIdSegments] = databaseKey.id.split(":");
    const providerUserId = providerUserIdSegments.join(":");
    const userId = databaseKey.user_id;
    const isPasswordDefined = !!databaseKey.hashed_password;
    return {
      providerId,
      providerUserId,
      userId,
      passwordDefined: isPasswordDefined
    };
  };
  transformDatabaseSession = (databaseSession, context) => {
    const attributes = this.getSessionAttributes(databaseSession);
    const active = isWithinExpiration(databaseSession.active_expires);
    return {
      ...attributes,
      user: context.user,
      sessionId: databaseSession.id,
      activePeriodExpiresAt: new Date(Number(databaseSession.active_expires)),
      idlePeriodExpiresAt: new Date(Number(databaseSession.idle_expires)),
      state: active ? "active" : "idle",
      fresh: context.fresh
    };
  };
  getDatabaseUser = async (userId) => {
    const databaseUser = await this.adapter.getUser(userId);
    if (!databaseUser) {
      throw new LuciaError("AUTH_INVALID_USER_ID");
    }
    return databaseUser;
  };
  getDatabaseSession = async (sessionId) => {
    const databaseSession = await this.adapter.getSession(sessionId);
    if (!databaseSession) {
      debug.session.fail("Session not found", sessionId);
      throw new LuciaError("AUTH_INVALID_SESSION_ID");
    }
    if (!isValidDatabaseSession(databaseSession)) {
      debug.session.fail(`Session expired at ${new Date(Number(databaseSession.idle_expires))}`, sessionId);
      throw new LuciaError("AUTH_INVALID_SESSION_ID");
    }
    return databaseSession;
  };
  getDatabaseSessionAndUser = async (sessionId) => {
    if (this.adapter.getSessionAndUser) {
      const [databaseSession2, databaseUser2] = await this.adapter.getSessionAndUser(sessionId);
      if (!databaseSession2) {
        debug.session.fail("Session not found", sessionId);
        throw new LuciaError("AUTH_INVALID_SESSION_ID");
      }
      if (!isValidDatabaseSession(databaseSession2)) {
        debug.session.fail(`Session expired at ${new Date(Number(databaseSession2.idle_expires))}`, sessionId);
        throw new LuciaError("AUTH_INVALID_SESSION_ID");
      }
      return [databaseSession2, databaseUser2];
    }
    const databaseSession = await this.getDatabaseSession(sessionId);
    const databaseUser = await this.getDatabaseUser(databaseSession.user_id);
    return [databaseSession, databaseUser];
  };
  validateSessionIdArgument = (sessionId) => {
    if (!sessionId) {
      debug.session.fail("Empty session id");
      throw new LuciaError("AUTH_INVALID_SESSION_ID");
    }
  };
  getNewSessionExpiration = (sessionExpiresIn) => {
    const activePeriodExpiresAt = new Date(new Date().getTime() + (sessionExpiresIn?.activePeriod ?? this.sessionExpiresIn.activePeriod));
    const idlePeriodExpiresAt = new Date(activePeriodExpiresAt.getTime() + (sessionExpiresIn?.idlePeriod ?? this.sessionExpiresIn.idlePeriod));
    return { activePeriodExpiresAt, idlePeriodExpiresAt };
  };
  getUser = async (userId) => {
    const databaseUser = await this.getDatabaseUser(userId);
    const user = this.transformDatabaseUser(databaseUser);
    return user;
  };
  createUser = async (options) => {
    const userId = options.userId ?? generateRandomString(15);
    const userAttributes = options.attributes ?? {};
    const databaseUser = {
      ...userAttributes,
      id: userId
    };
    if (options.key === null) {
      await this.adapter.setUser(databaseUser, null);
      return this.transformDatabaseUser(databaseUser);
    }
    const keyId = createKeyId(options.key.providerId, options.key.providerUserId);
    const password = options.key.password;
    const hashedPassword = password === null ? null : await this.passwordHash.generate(password);
    await this.adapter.setUser(databaseUser, {
      id: keyId,
      user_id: userId,
      hashed_password: hashedPassword
    });
    return this.transformDatabaseUser(databaseUser);
  };
  updateUserAttributes = async (userId, attributes) => {
    await this.adapter.updateUser(userId, attributes);
    return await this.getUser(userId);
  };
  deleteUser = async (userId) => {
    await this.adapter.deleteSessionsByUserId(userId);
    await this.adapter.deleteKeysByUserId(userId);
    await this.adapter.deleteUser(userId);
  };
  useKey = async (providerId, providerUserId, password) => {
    const keyId = createKeyId(providerId, providerUserId);
    const databaseKey = await this.adapter.getKey(keyId);
    if (!databaseKey) {
      debug.key.fail("Key not found", keyId);
      throw new LuciaError("AUTH_INVALID_KEY_ID");
    }
    const hashedPassword = databaseKey.hashed_password;
    if (hashedPassword !== null) {
      debug.key.info("Key includes password");
      if (!password) {
        debug.key.fail("Key password not provided", keyId);
        throw new LuciaError("AUTH_INVALID_PASSWORD");
      }
      const validPassword = await this.passwordHash.validate(password, hashedPassword);
      if (!validPassword) {
        debug.key.fail("Incorrect key password", password);
        throw new LuciaError("AUTH_INVALID_PASSWORD");
      }
      debug.key.notice("Validated key password");
    } else {
      if (password !== null) {
        debug.key.fail("Incorrect key password", password);
        throw new LuciaError("AUTH_INVALID_PASSWORD");
      }
      debug.key.info("No password included in key");
    }
    debug.key.success("Validated key", keyId);
    return this.transformDatabaseKey(databaseKey);
  };
  getSession = async (sessionId) => {
    this.validateSessionIdArgument(sessionId);
    const [databaseSession, databaseUser] = await this.getDatabaseSessionAndUser(sessionId);
    const user = this.transformDatabaseUser(databaseUser);
    return this.transformDatabaseSession(databaseSession, {
      user,
      fresh: false
    });
  };
  getAllUserSessions = async (userId) => {
    const [user, databaseSessions] = await Promise.all([
      this.getUser(userId),
      await this.adapter.getSessionsByUserId(userId)
    ]);
    const validStoredUserSessions = databaseSessions.filter((databaseSession) => {
      return isValidDatabaseSession(databaseSession);
    }).map((databaseSession) => {
      return this.transformDatabaseSession(databaseSession, {
        user,
        fresh: false
      });
    });
    return validStoredUserSessions;
  };
  validateSession = async (sessionId) => {
    this.validateSessionIdArgument(sessionId);
    const [databaseSession, databaseUser] = await this.getDatabaseSessionAndUser(sessionId);
    const user = this.transformDatabaseUser(databaseUser);
    const session2 = this.transformDatabaseSession(databaseSession, {
      user,
      fresh: false
    });
    if (session2.state === "active") {
      debug.session.success("Validated session", session2.sessionId);
      return session2;
    }
    const { activePeriodExpiresAt, idlePeriodExpiresAt } = this.getNewSessionExpiration();
    await this.adapter.updateSession(session2.sessionId, {
      active_expires: activePeriodExpiresAt.getTime(),
      idle_expires: idlePeriodExpiresAt.getTime()
    });
    const renewedDatabaseSession = {
      ...session2,
      idlePeriodExpiresAt,
      activePeriodExpiresAt,
      fresh: true
    };
    return renewedDatabaseSession;
  };
  createSession = async (options) => {
    const { activePeriodExpiresAt, idlePeriodExpiresAt } = this.getNewSessionExpiration();
    const userId = options.userId;
    const sessionId = options?.sessionId ?? generateRandomString(40);
    const attributes = options.attributes;
    const databaseSession = {
      ...attributes,
      id: sessionId,
      user_id: userId,
      active_expires: activePeriodExpiresAt.getTime(),
      idle_expires: idlePeriodExpiresAt.getTime()
    };
    const [user] = await Promise.all([
      this.getUser(userId),
      this.adapter.setSession(databaseSession)
    ]);
    return this.transformDatabaseSession(databaseSession, {
      user,
      fresh: false
    });
  };
  updateSessionAttributes = async (sessionId, attributes) => {
    this.validateSessionIdArgument(sessionId);
    await this.adapter.updateSession(sessionId, attributes);
    return this.getSession(sessionId);
  };
  invalidateSession = async (sessionId) => {
    this.validateSessionIdArgument(sessionId);
    await this.adapter.deleteSession(sessionId);
    debug.session.notice("Invalidated session", sessionId);
  };
  invalidateAllUserSessions = async (userId) => {
    await this.adapter.deleteSessionsByUserId(userId);
  };
  deleteDeadUserSessions = async (userId) => {
    const databaseSessions = await this.adapter.getSessionsByUserId(userId);
    const deadSessionIds = databaseSessions.filter((databaseSession) => {
      return !isValidDatabaseSession(databaseSession);
    }).map((databaseSession) => databaseSession.id);
    await Promise.all(deadSessionIds.map((deadSessionId) => {
      this.adapter.deleteSession(deadSessionId);
    }));
  };
  validateRequestOrigin = (request4) => {
    if (request4.method === null) {
      debug.request.fail("Request method unavailable");
      throw new LuciaError("AUTH_INVALID_REQUEST");
    }
    if (request4.url === null) {
      debug.request.fail("Request url unavailable");
      throw new LuciaError("AUTH_INVALID_REQUEST");
    }
    if (request4.method.toUpperCase() !== "GET" && request4.method.toUpperCase() !== "HEAD") {
      const requestOrigin = request4.headers.origin;
      if (!requestOrigin) {
        debug.request.fail("No request origin available");
        throw new LuciaError("AUTH_INVALID_REQUEST");
      }
      try {
        const url3 = safeParseUrl(request4.url);
        const allowedSubDomains = typeof this.csrfProtection === "object" ? this.csrfProtection.allowedSubDomains ?? [] : [];
        if (url3 === null || !isAllowedOrigin(requestOrigin, url3.origin, allowedSubDomains)) {
          throw new LuciaError("AUTH_INVALID_REQUEST");
        }
        debug.request.info("Valid request origin", requestOrigin);
      } catch {
        debug.request.fail("Invalid origin string", requestOrigin);
        throw new LuciaError("AUTH_INVALID_REQUEST");
      }
    } else {
      debug.request.notice("Skipping CSRF check");
    }
  };
  readSessionCookie = (cookieHeader) => {
    if (!cookieHeader) {
      debug.request.info("No session cookie found");
      return null;
    }
    const cookies = parseCookie(cookieHeader);
    const sessionCookieName = this.sessionCookieConfig.name ?? DEFAULT_SESSION_COOKIE_NAME;
    const sessionId = cookies[sessionCookieName] ?? null;
    if (sessionId) {
      debug.request.info("Found session cookie", sessionId);
    } else {
      debug.request.info("No session cookie found");
    }
    return sessionId;
  };
  readBearerToken = (authorizationHeader) => {
    if (!authorizationHeader) {
      debug.request.info("No token found in authorization header");
      return null;
    }
    const [authScheme, token] = authorizationHeader.split(" ");
    if (authScheme !== "Bearer") {
      debug.request.fail("Invalid authorization header auth scheme", authScheme);
      return null;
    }
    return token ?? null;
  };
  handleRequest = (...args2) => {
    const middleware2 = this.middleware;
    const sessionCookieName = this.sessionCookieConfig.name ?? DEFAULT_SESSION_COOKIE_NAME;
    return new AuthRequest(this, {
      csrfProtection: this.csrfProtection,
      requestContext: transformRequestContext(middleware2({
        args: args2,
        env: this.env,
        sessionCookieName
      }))
    });
  };
  createSessionCookie = (session2) => {
    return createSessionCookie(session2, {
      env: this.env,
      cookie: this.sessionCookieConfig
    });
  };
  createKey = async (options) => {
    const keyId = createKeyId(options.providerId, options.providerUserId);
    let hashedPassword = null;
    if (options.password !== null) {
      hashedPassword = await this.passwordHash.generate(options.password);
    }
    const userId = options.userId;
    await this.adapter.setKey({
      id: keyId,
      user_id: userId,
      hashed_password: hashedPassword
    });
    return {
      providerId: options.providerId,
      providerUserId: options.providerUserId,
      passwordDefined: !!options.password,
      userId
    };
  };
  deleteKey = async (providerId, providerUserId) => {
    const keyId = createKeyId(providerId, providerUserId);
    await this.adapter.deleteKey(keyId);
  };
  getKey = async (providerId, providerUserId) => {
    const keyId = createKeyId(providerId, providerUserId);
    const databaseKey = await this.adapter.getKey(keyId);
    if (!databaseKey) {
      throw new LuciaError("AUTH_INVALID_KEY_ID");
    }
    const key = this.transformDatabaseKey(databaseKey);
    return key;
  };
  getAllUserKeys = async (userId) => {
    const [databaseKeys] = await Promise.all([
      await this.adapter.getKeysByUserId(userId),
      this.getUser(userId)
    ]);
    return databaseKeys.map((databaseKey) => this.transformDatabaseKey(databaseKey));
  };
  updateKeyPassword = async (providerId, providerUserId, password) => {
    const keyId = createKeyId(providerId, providerUserId);
    const hashedPassword = password === null ? null : await this.passwordHash.generate(password);
    await this.adapter.updateKey(keyId, {
      hashed_password: hashedPassword
    });
    return await this.getKey(providerId, providerUserId);
  };
}
// node_modules/@libsql/hrana-client/lib-esm/encoding/
var import_pino2 = __toESM(require_pino(), 1);

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/util
var import_pino = __toESM(require_pino(), 1);
function serializeRequest(request4) {
  return {
    method: request4.method,
    url: request4.url,
    referrer: request4.referrer
  };
}
var serializers = {
  request: serializeRequest,
  err: import_pino.stdSerializers.err
};

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/uti
function isContext(object) {
  const context = object;
  return context.request && context.store;
}
function isRequest(object) {
  const request4 = object;
  return request4.url && request4.method;
}
var formatters = {
  log(object) {
    if (isContext(object)) {
      const context = object;
      return { request: context.request };
    } else if (isRequest(object)) {
      return serializeRequest(object);
    }
    return object;
  }
};
// node_modules/@libsql/hrana-client/lib-esm/encoding/
function createPinoLogger(options = {}) {
  if (!options.level) {
    options.level = "info";
  }
  if (!options.formatters) {
    options.formatters = formatters;
  }
  if (!options.serializers) {
    options.serializers = serializers;
  }
  const streamOptions = options;
  if ("file" in options) {
    streamOptions.stream = import_pino2.default.destination(options.file);
    delete options.file;
  }
  return import_pino2.default(options, streamOptions.stream);
}
var plugin = function(options) {
  if (!options.contextKeyName) {
    options.contextKeyName = "log";
  }
  const { contextKeyName, ...loggerOptions } = options;
  return new c$({
    name: "@bogeychan/elysia-logger"
  }).derive((ctx) => {
    let log3 = createPinoLogger(loggerOptions);
    if (typeof options.customProps === "function") {
      log3 = log3.child(options.customProps(ctx));
    }
    return {
      [contextKeyName]: log3
    };
  });
};
var logger = (options = {}) => plugin(options);

// node_modules/@libsql/hrana-client/lib-
var minitz = function(y, m, d, h2, i, s, tz, throwOnInvalid) {
  return minitz.fromTZ(minitz.tp(y, m, d, h2, i, s, tz), throwOnInvalid);
};
var getTimezoneOffset = function(timeZone, date3 = new Date) {
  const tz = date3.toLocaleString("en-US", { timeZone, timeZoneName: "short" }).split(" ").slice(-1)[0];
  const dateString = date3.toLocaleString("en-US").replace(/[\u202f]/, " ");
  return Date.parse(`${dateString} GMT`) - Date.parse(`${dateString} ${tz}`);
};
var parseISOLocal = function(dtStr, tz) {
  const pd = new Date(Date.parse(dtStr));
  if (isNaN(pd)) {
    throw new Error("minitz: Invalid ISO8601 passed to parser.");
  }
  const stringEnd = dtStr.substring(9);
  if (dtStr.includes("Z") || stringEnd.includes("-") || stringEnd.includes("+")) {
    return minitz.tp(pd.getUTCFullYear(), pd.getUTCMonth() + 1, pd.getUTCDate(), pd.getUTCHours(), pd.getUTCMinutes(), pd.getUTCSeconds(), "Etc/UTC");
  } else {
    return minitz.tp(pd.getFullYear(), pd.getMonth() + 1, pd.getDate(), pd.getHours(), pd.getMinutes(), pd.getSeconds(), tz);
  }
};
var CronOptions = function(options) {
  if (options === undefined) {
    options = {};
  }
  delete options.name;
  options.legacyMode = options.legacyMode === undefined ? true : options.legacyMode;
  options.paused = options.paused === undefined ? false : options.paused;
  options.maxRuns = options.maxRuns === undefined ? Infinity : options.maxRuns;
  options.catch = options.catch === undefined ? false : options.catch;
  options.interval = options.interval === undefined ? 0 : parseInt(options.interval, 10);
  options.utcOffset = options.utcOffset === undefined ? undefined : parseInt(options.utcOffset, 10);
  options.unref = options.unref === undefined ? false : options.unref;
  if (options.startAt) {
    options.startAt = new CronDate(options.startAt, options.timezone);
  }
  if (options.stopAt) {
    options.stopAt = new CronDate(options.stopAt, options.timezone);
  }
  if (options.interval !== null) {
    if (isNaN(options.interval)) {
      throw new Error("CronOptions: Supplied value for interval is not a number");
    } else if (options.interval < 0) {
      throw new Error("CronOptions: Supplied value for interval can not be negative");
    }
  }
  if (options.utcOffset !== undefined) {
    if (isNaN(options.utcOffset)) {
      throw new Error("CronOptions: Invalid value passed for utcOffset, should be number representing minutes offset from UTC.");
    } else if (options.utcOffset < -870 || options.utcOffset > 870) {
      throw new Error("CronOptions: utcOffset out of bounds.");
    }
    if (options.utcOffset !== undefined && options.timezone) {
      throw new Error("CronOptions: Combining 'utcOffset' with 'timezone' is not allowed.");
    }
  }
  if (options.unref !== true && options.unref !== false) {
    throw new Error("CronOptions: Unref should be either true, false or undefined(false).");
  }
  return options;
};
var CronDate = function(d, tz) {
  this.tz = tz;
  if (d && d instanceof Date) {
    if (!isNaN(d)) {
      this.fromDate(d);
    } else {
      throw new TypeError("CronDate: Invalid date passed to CronDate constructor");
    }
  } else if (d === undefined) {
    this.fromDate(new Date);
  } else if (d && typeof d === "string") {
    this.fromString(d);
  } else if (d instanceof CronDate) {
    this.fromCronDate(d);
  } else {
    throw new TypeError("CronDate: Invalid type (" + typeof d + ") passed to CronDate constructor");
  }
};
var CronPattern = function(pattern, timezone) {
  this.pattern = pattern;
  this.timezone = timezone;
  this.second = Array(60).fill(0);
  this.minute = Array(60).fill(0);
  this.hour = Array(24).fill(0);
  this.day = Array(31).fill(0);
  this.month = Array(12).fill(0);
  this.dayOfWeek = Array(8).fill(0);
  this.lastDayOfMonth = false;
  this.lastWeekdayOfMonth = false;
  this.starDOM = false;
  this.starDOW = false;
  this.parse();
};
var isFunction = function(v) {
  return Object.prototype.toString.call(v) === "[object Function]" || typeof v === "function" || v instanceof Function;
};
var unrefTimer = function(timer) {
  if (typeof Deno !== "undefined" && typeof Deno.unrefTimer !== "undefined") {
    Deno.unrefTimer(timer);
  } else if (timer && typeof timer.unref !== "undefined") {
    timer.unref();
  }
};
var Cron = function(pattern, fnOrOptions1, fnOrOptions2) {
  if (!(this instanceof Cron)) {
    return new Cron(pattern, fnOrOptions1, fnOrOptions2);
  }
  let options, func;
  if (isFunction(fnOrOptions1)) {
    func = fnOrOptions1;
  } else if (typeof fnOrOptions1 === "object") {
    options = fnOrOptions1;
  } else if (fnOrOptions1 !== undefined) {
    throw new Error("Cron: Invalid argument passed for optionsIn. Should be one of function, or object (options).");
  }
  if (isFunction(fnOrOptions2)) {
    func = fnOrOptions2;
  } else if (typeof fnOrOptions2 === "object") {
    options = fnOrOptions2;
  } else if (fnOrOptions2 !== undefined) {
    throw new Error("Cron: Invalid argument passed for funcIn. Should be one of function, or object (options).");
  }
  this.name = options ? options.name : undefined;
  this.options = CronOptions(options);
  this._states = { kill: false, blocking: false, previousRun: undefined, currentRun: undefined, once: undefined, currentTimeout: undefined, maxRuns: options ? options.maxRuns : undefined, paused: options ? options.paused : false, pattern: undefined };
  if (pattern && (pattern instanceof Date || typeof pattern === "string" && pattern.indexOf(":") > 0)) {
    this._states.once = new CronDate(pattern, this.options.timezone || this.options.utcOffset);
  } else {
    this._states.pattern = new CronPattern(pattern, this.options.timezone);
  }
  if (this.name) {
    const existing = scheduledJobs.find((j) => j.name === this.name);
    if (existing) {
      throw new Error("Cron: Tried to initialize new named job '" + this.name + "', but name already taken.");
    } else {
      scheduledJobs.push(this);
    }
  }
  if (func !== undefined) {
    this.fn = func;
    this.schedule();
  }
  return this;
};
minitz.fromTZISO = (localTimeStr, tz, throwOnInvalid) => {
  return minitz.fromTZ(parseISOLocal(localTimeStr, tz), throwOnInvalid);
};
minitz.fromTZ = function(tp, throwOnInvalid) {
  const inDate = new Date(Date.UTC(tp.y, tp.m - 1, tp.d, tp.h, tp.i, tp.s)), offset = getTimezoneOffset(tp.tz, inDate), dateGuess = new Date(inDate.getTime() - offset), dateOffsGuess = getTimezoneOffset(tp.tz, dateGuess);
  if (dateOffsGuess - offset === 0) {
    return dateGuess;
  } else {
    const dateGuess2 = new Date(inDate.getTime() - dateOffsGuess), dateOffsGuess2 = getTimezoneOffset(tp.tz, dateGuess2);
    if (dateOffsGuess2 - dateOffsGuess === 0) {
      return dateGuess2;
    } else if (!throwOnInvalid && dateOffsGuess2 - dateOffsGuess > 0) {
      return dateGuess2;
    } else if (!throwOnInvalid) {
      return dateGuess;
    } else {
      throw new Error("Invalid date passed to fromTZ()");
    }
  }
};
minitz.toTZ = function(d, tzStr) {
  const localDateString = d.toLocaleString("en-US", { timeZone: tzStr }).replace(/[\u202f]/, " ");
  const td = new Date(localDateString);
  return { y: td.getFullYear(), m: td.getMonth() + 1, d: td.getDate(), h: td.getHours(), i: td.getMinutes(), s: td.getSeconds(), tz: tzStr };
};
minitz.tp = (y, m, d, h2, i, s, tz) => {
  return { y, m, d, h: h2, i, s, tz };
};
minitz.minitz = minitz;
var DaysOfMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var RecursionSteps = [["month", "year", 0], ["day", "month", -1], ["hour", "day", 0], ["minute", "hour", 0], ["second", "minute", 0]];
CronDate.prototype.fromDate = function(inDate) {
  if (this.tz !== undefined) {
    if (typeof this.tz === "number") {
      this.ms = inDate.getUTCMilliseconds();
      this.second = inDate.getUTCSeconds();
      this.minute = inDate.getUTCMinutes() + this.tz;
      this.hour = inDate.getUTCHours();
      this.day = inDate.getUTCDate();
      this.month = inDate.getUTCMonth();
      this.year = inDate.getUTCFullYear();
      this.apply();
    } else {
      const d = minitz.toTZ(inDate, this.tz);
      this.ms = inDate.getMilliseconds();
      this.second = d.s;
      this.minute = d.i;
      this.hour = d.h;
      this.day = d.d;
      this.month = d.m - 1;
      this.year = d.y;
    }
  } else {
    this.ms = inDate.getMilliseconds();
    this.second = inDate.getSeconds();
    this.minute = inDate.getMinutes();
    this.hour = inDate.getHours();
    this.day = inDate.getDate();
    this.month = inDate.getMonth();
    this.year = inDate.getFullYear();
  }
};
CronDate.prototype.fromCronDate = function(d) {
  this.tz = d.tz;
  this.year = d.year;
  this.month = d.month;
  this.day = d.day;
  this.hour = d.hour;
  this.minute = d.minute;
  this.second = d.second;
  this.ms = d.ms;
};
CronDate.prototype.apply = function() {
  if (this.month > 11 || this.day > DaysOfMonth[this.month] || this.hour > 59 || this.minute > 59 || this.second > 59 || this.hour < 0 || this.minute < 0 || this.second < 0) {
    const d = new Date(Date.UTC(this.year, this.month, this.day, this.hour, this.minute, this.second, this.ms));
    this.ms = d.getUTCMilliseconds();
    this.second = d.getUTCSeconds();
    this.minute = d.getUTCMinutes();
    this.hour = d.getUTCHours();
    this.day = d.getUTCDate();
    this.month = d.getUTCMonth();
    this.year = d.getUTCFullYear();
    return true;
  } else {
    return false;
  }
};
CronDate.prototype.fromString = function(str) {
  return this.fromDate(minitz.fromTZISO(str, this.tz));
};
CronDate.prototype.findNext = function(options, target, pattern, offset) {
  const originalTarget = this[target];
  let lastDayOfMonth;
  if (pattern.lastDayOfMonth || pattern.lastWeekdayOfMonth) {
    if (this.month !== 1) {
      lastDayOfMonth = DaysOfMonth[this.month];
    } else {
      lastDayOfMonth = new Date(Date.UTC(this.year, this.month + 1, 0, 0, 0, 0, 0)).getUTCDate();
    }
  }
  const fDomWeekDay = !pattern.starDOW && target == "day" ? new Date(Date.UTC(this.year, this.month, 1, 0, 0, 0, 0)).getUTCDay() : undefined;
  for (let i = this[target] + offset;i < pattern[target].length; i++) {
    let match = pattern[target][i];
    if (target === "day" && pattern.lastDayOfMonth && i - offset == lastDayOfMonth) {
      match = true;
    }
    if (target === "day" && !pattern.starDOW) {
      let dowMatch = pattern.dayOfWeek[(fDomWeekDay + (i - offset - 1)) % 7];
      if (dowMatch && pattern.lastWeekdayOfMonth) {
        dowMatch = dowMatch && i - offset > lastDayOfMonth - 7;
      }
      if (options.legacyMode && !pattern.starDOM) {
        match = match || dowMatch;
      } else {
        match = match && dowMatch;
      }
    }
    if (match) {
      this[target] = i - offset;
      return originalTarget !== this[target] ? 2 : 1;
    }
  }
  return 3;
};
CronDate.prototype.recurse = function(pattern, options, doing) {
  const res = this.findNext(options, RecursionSteps[doing][0], pattern, RecursionSteps[doing][2]);
  if (res > 1) {
    let resetLevel = doing + 1;
    while (resetLevel < RecursionSteps.length) {
      this[RecursionSteps[resetLevel][0]] = -RecursionSteps[resetLevel][2];
      resetLevel++;
    }
    if (res === 3) {
      this[RecursionSteps[doing][1]]++;
      this[RecursionSteps[doing][0]] = -RecursionSteps[doing][2];
      this.apply();
      return this.recurse(pattern, options, 0);
    } else if (this.apply()) {
      return this.recurse(pattern, options, doing - 1);
    }
  }
  doing += 1;
  if (doing >= RecursionSteps.length) {
    return this;
  } else if (this.year >= 3000) {
    return null;
  } else {
    return this.recurse(pattern, options, doing);
  }
};
CronDate.prototype.increment = function(pattern, options, hasPreviousRun) {
  this.second += options.interval > 1 && hasPreviousRun ? options.interval : 1;
  this.ms = 0;
  this.apply();
  return this.recurse(pattern, options, 0);
};
CronDate.prototype.getDate = function(internal) {
  if (internal || this.tz === undefined) {
    return new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.ms);
  } else {
    if (typeof this.tz === "number") {
      return new Date(Date.UTC(this.year, this.month, this.day, this.hour, this.minute - this.tz, this.second, this.ms));
    } else {
      return minitz(this.year, this.month + 1, this.day, this.hour, this.minute, this.second, this.tz);
    }
  }
};
CronDate.prototype.getTime = function() {
  return this.getDate().getTime();
};
CronPattern.prototype.parse = function() {
  if (!(typeof this.pattern === "string" || this.pattern.constructor === String)) {
    throw new TypeError("CronPattern: Pattern has to be of type string.");
  }
  if (this.pattern.indexOf("@") >= 0)
    this.pattern = this.handleNicknames(this.pattern).trim();
  const parts = this.pattern.replace(/\s+/g, " ").split(" ");
  if (parts.length < 5 || parts.length > 6) {
    throw new TypeError("CronPattern: invalid configuration format ('" + this.pattern + "'), exacly five or six space separated parts required.");
  }
  if (parts.length === 5) {
    parts.unshift("0");
  }
  if (parts[3].indexOf("L") >= 0) {
    parts[3] = parts[3].replace("L", "");
    this.lastDayOfMonth = true;
  }
  if (parts[5].indexOf("L") >= 0) {
    parts[5] = parts[5].replace("L", "");
    this.lastWeekdayOfMonth = true;
  }
  if (parts[3] == "*") {
    this.starDOM = true;
  }
  if (parts[4].length >= 3)
    parts[4] = this.replaceAlphaMonths(parts[4]);
  if (parts[5].length >= 3)
    parts[5] = this.replaceAlphaDays(parts[5]);
  if (parts[5] == "*") {
    this.starDOW = true;
  }
  if (this.pattern.indexOf("?") >= 0) {
    const initDate = new CronDate(new Date, this.timezone).getDate(true);
    parts[0] = parts[0].replace("?", initDate.getSeconds());
    parts[1] = parts[1].replace("?", initDate.getMinutes());
    parts[2] = parts[2].replace("?", initDate.getHours());
    if (!this.starDOM)
      parts[3] = parts[3].replace("?", initDate.getDate());
    parts[4] = parts[4].replace("?", initDate.getMonth() + 1);
    if (!this.starDOW)
      parts[5] = parts[5].replace("?", initDate.getDay());
  }
  this.throwAtIllegalCharacters(parts);
  this.partToArray("second", parts[0], 0);
  this.partToArray("minute", parts[1], 0);
  this.partToArray("hour", parts[2], 0);
  this.partToArray("day", parts[3], -1);
  this.partToArray("month", parts[4], -1);
  this.partToArray("dayOfWeek", parts[5], 0);
  if (this.dayOfWeek[7]) {
    this.dayOfWeek[0] = 1;
  }
};
CronPattern.prototype.partToArray = function(type, conf, valueIndexOffset) {
  const arr = this[type];
  if (conf === "*")
    return arr.fill(1);
  const split = conf.split(",");
  if (split.length > 1) {
    for (let i = 0;i < split.length; i++) {
      this.partToArray(type, split[i], valueIndexOffset);
    }
  } else if (conf.indexOf("-") !== -1 && conf.indexOf("/") !== -1) {
    this.handleRangeWithStepping(conf, type, valueIndexOffset);
  } else if (conf.indexOf("-") !== -1) {
    this.handleRange(conf, type, valueIndexOffset);
  } else if (conf.indexOf("/") !== -1) {
    this.handleStepping(conf, type, valueIndexOffset);
  } else if (conf !== "") {
    this.handleNumber(conf, type, valueIndexOffset);
  }
};
CronPattern.prototype.throwAtIllegalCharacters = function(parts) {
  const reValidCron = /[^/*0-9,-]+/;
  for (let i = 0;i < parts.length; i++) {
    if (reValidCron.test(parts[i])) {
      throw new TypeError("CronPattern: configuration entry " + i + " (" + parts[i] + ") contains illegal characters.");
    }
  }
};
CronPattern.prototype.handleNumber = function(conf, type, valueIndexOffset) {
  const i = parseInt(conf, 10) + valueIndexOffset;
  if (isNaN(i)) {
    throw new TypeError("CronPattern: " + type + " is not a number: '" + conf + "'");
  }
  if (i < 0 || i >= this[type].length) {
    throw new TypeError("CronPattern: " + type + " value out of range: '" + conf + "'");
  }
  this[type][i] = 1;
};
CronPattern.prototype.handleRangeWithStepping = function(conf, type, valueIndexOffset) {
  const matches = conf.match(/^(\d+)-(\d+)\/(\d+)$/);
  if (matches === null)
    throw new TypeError("CronPattern: Syntax error, illegal range with stepping: '" + conf + "'");
  let [, lower, upper, steps] = matches;
  lower = parseInt(lower, 10) + valueIndexOffset;
  upper = parseInt(upper, 10) + valueIndexOffset;
  steps = parseInt(steps, 10);
  if (isNaN(lower))
    throw new TypeError("CronPattern: Syntax error, illegal lower range (NaN)");
  if (isNaN(upper))
    throw new TypeError("CronPattern: Syntax error, illegal upper range (NaN)");
  if (isNaN(steps))
    throw new TypeError("CronPattern: Syntax error, illegal stepping: (NaN)");
  if (steps === 0)
    throw new TypeError("CronPattern: Syntax error, illegal stepping: 0");
  if (steps > this[type].length)
    throw new TypeError("CronPattern: Syntax error, steps cannot be greater than maximum value of part (" + this[type].length + ")");
  if (lower < 0 || upper >= this[type].length)
    throw new TypeError("CronPattern: Value out of range: '" + conf + "'");
  if (lower > upper)
    throw new TypeError("CronPattern: From value is larger than to value: '" + conf + "'");
  for (let i = lower;i <= upper; i += steps) {
    this[type][i] = 1;
  }
};
CronPattern.prototype.handleRange = function(conf, type, valueIndexOffset) {
  const split = conf.split("-");
  if (split.length !== 2) {
    throw new TypeError("CronPattern: Syntax error, illegal range: '" + conf + "'");
  }
  const lower = parseInt(split[0], 10) + valueIndexOffset, upper = parseInt(split[1], 10) + valueIndexOffset;
  if (isNaN(lower)) {
    throw new TypeError("CronPattern: Syntax error, illegal lower range (NaN)");
  } else if (isNaN(upper)) {
    throw new TypeError("CronPattern: Syntax error, illegal upper range (NaN)");
  }
  if (lower < 0 || upper >= this[type].length) {
    throw new TypeError("CronPattern: Value out of range: '" + conf + "'");
  }
  if (lower > upper) {
    throw new TypeError("CronPattern: From value is larger than to value: '" + conf + "'");
  }
  for (let i = lower;i <= upper; i++) {
    this[type][i] = 1;
  }
};
CronPattern.prototype.handleStepping = function(conf, type) {
  const split = conf.split("/");
  if (split.length !== 2) {
    throw new TypeError("CronPattern: Syntax error, illegal stepping: '" + conf + "'");
  }
  let start = 0;
  if (split[0] !== "*") {
    start = parseInt(split[0], 10);
  }
  const steps = parseInt(split[1], 10);
  if (isNaN(steps))
    throw new TypeError("CronPattern: Syntax error, illegal stepping: (NaN)");
  if (steps === 0)
    throw new TypeError("CronPattern: Syntax error, illegal stepping: 0");
  if (steps > this[type].length)
    throw new TypeError("CronPattern: Syntax error, max steps for part is (" + this[type].length + ")");
  for (let i = start;i < this[type].length; i += steps) {
    this[type][i] = 1;
  }
};
CronPattern.prototype.replaceAlphaDays = function(conf) {
  return conf.replace(/-sun/gi, "-7").replace(/sun/gi, "0").replace(/mon/gi, "1").replace(/tue/gi, "2").replace(/wed/gi, "3").replace(/thu/gi, "4").replace(/fri/gi, "5").replace(/sat/gi, "6");
};
CronPattern.prototype.replaceAlphaMonths = function(conf) {
  return conf.replace(/jan/gi, "1").replace(/feb/gi, "2").replace(/mar/gi, "3").replace(/apr/gi, "4").replace(/may/gi, "5").replace(/jun/gi, "6").replace(/jul/gi, "7").replace(/aug/gi, "8").replace(/sep/gi, "9").replace(/oct/gi, "10").replace(/nov/gi, "11").replace(/dec/gi, "12");
};
CronPattern.prototype.handleNicknames = function(pattern) {
  const cleanPattern = pattern.trim().toLowerCase();
  if (cleanPattern === "@yearly" || cleanPattern === "@annually") {
    return "0 0 1 1 *";
  } else if (cleanPattern === "@monthly") {
    return "0 0 1 * *";
  } else if (cleanPattern === "@weekly") {
    return "0 0 * * 0";
  } else if (cleanPattern === "@daily") {
    return "0 0 * * *";
  } else if (cleanPattern === "@hourly") {
    return "0 * * * *";
  } else {
    return pattern;
  }
};
var maxDelay = 30 * 1000;
var scheduledJobs = [];
Cron.prototype.nextRun = function(prev) {
  const next = this._next(prev);
  return next ? next.getDate() : null;
};
Cron.prototype.nextRuns = function(n, previous) {
  if (n > this._states.maxRuns) {
    n = this._states.maxRuns;
  }
  const enumeration = [];
  let prev = previous || this._states.currentRun;
  while (n-- && (prev = this.nextRun(prev))) {
    enumeration.push(prev);
  }
  return enumeration;
};
Cron.prototype.getPattern = function() {
  return this._states.pattern ? this._states.pattern.pattern : undefined;
};
Cron.prototype.isRunning = function() {
  const msLeft = this.msToNext(this._states.currentRun);
  const isRunning = !this._states.paused;
  const isScheduled = this.fn !== undefined;
  const notIsKilled = !this._states.kill;
  return isRunning && isScheduled && notIsKilled && msLeft !== null;
};
Cron.prototype.isStopped = function() {
  return this._states.kill;
};
Cron.prototype.isBusy = function() {
  return this._states.blocking;
};
Cron.prototype.currentRun = function() {
  return this._states.currentRun ? this._states.currentRun.getDate() : null;
};
Cron.prototype.previousRun = function() {
  return this._states.previousRun ? this._states.previousRun.getDate() : null;
};
Cron.prototype.msToNext = function(prev) {
  const next = this._next(prev);
  prev = new CronDate(prev, this.options.timezone || this.options.utcOffset);
  if (next) {
    return next.getTime(true) - prev.getTime(true);
  } else {
    return null;
  }
};
Cron.prototype.stop = function() {
  this._states.kill = true;
  if (this._states.currentTimeout) {
    clearTimeout(this._states.currentTimeout);
  }
  const jobIndex = scheduledJobs.indexOf(this);
  if (jobIndex >= 0) {
    scheduledJobs.splice(jobIndex, 1);
  }
};
Cron.prototype.pause = function() {
  this._states.paused = true;
  return !this._states.kill;
};
Cron.prototype.resume = function() {
  this._states.paused = false;
  return !this._states.kill;
};
Cron.prototype.schedule = function(func, partial) {
  if (func && this.fn) {
    throw new Error("Cron: It is not allowed to schedule two functions using the same Croner instance.");
  } else if (func) {
    this.fn = func;
  }
  let waitMs = this.msToNext(partial ? partial : this._states.currentRun);
  const target = this.nextRun(partial ? partial : this._states.currentRun);
  if (waitMs === null || target === null)
    return this;
  if (waitMs > maxDelay) {
    waitMs = maxDelay;
  }
  this._states.currentTimeout = setTimeout(() => this._checkTrigger(target), waitMs);
  if (this._states.currentTimeout && this.options.unref) {
    unrefTimer(this._states.currentTimeout);
  }
  return this;
};
Cron.prototype._trigger = async function(initiationDate) {
  this._states.blocking = true;
  this._states.currentRun = new CronDate(undefined, this.options.timezone || this.options.utcOffset);
  if (this.options.catch) {
    try {
      await this.fn(this, this.options.context);
    } catch (_e) {
      if (isFunction(this.options.catch)) {
        this.options.catch(_e, this);
      }
    }
  } else {
    await this.fn(this, this.options.context);
  }
  this._states.previousRun = new CronDate(initiationDate, this.options.timezone || this.options.utcOffset);
  this._states.blocking = false;
};
Cron.prototype.trigger = async function() {
  await this._trigger();
};
Cron.prototype._checkTrigger = function(target) {
  const now = new Date, shouldRun = !this._states.paused && now.getTime() >= target, isBlocked = this._states.blocking && this.options.protect;
  if (shouldRun && !isBlocked) {
    this._states.maxRuns--;
    this._trigger();
  } else {
    if (shouldRun && isBlocked && isFunction(this.options.protect)) {
      setTimeout(() => this.options.protect(this), 0);
    }
  }
  this.schedule(undefined, now);
};
Cron.prototype._next = function(prev) {
  const hasPreviousRun = prev || this._states.currentRun ? true : false;
  prev = new CronDate(prev, this.options.timezone || this.options.utcOffset);
  if (this.options.startAt && prev && prev.getTime() < this.options.startAt.getTime()) {
    prev = this.options.startAt;
  }
  const nextRun = this._states.once || new CronDate(prev, this.options.timezone || this.options.utcOffset).increment(this._states.pattern, this.options, hasPreviousRun);
  if (this._states.once && this._states.once.getTime() <= prev.getTime()) {
    return null;
  } else if (nextRun === null || this._states.maxRuns <= 0 || this._states.kill || this.options.stopAt && nextRun.getTime() >= this.options.stopAt.getTime()) {
    return null;
  } else {
    return nextRun;
  }
};
Cron.Cron = Cron;
Cron.scheduledJobs = scheduledJobs;

// node_modules/@libsql/hrana-client/lib-esm
var cron = ({ pattern, name, run, ...options }) => (app) => {
  if (!pattern)
    throw new Error("pattern is required");
  if (!name)
    throw new Error("name is required");
  return app.state("cron", {
    ...app.store?.cron ?? {},
    [name]: new Cron(pattern, options, () => run(app.store))
  });
};

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/util.j
var eW2 = Object.create;
var { defineProperty: S62, getPrototypeOf: $X2, getOwnPropertyNames: YX2 } = Object;
var WX2 = Object.prototype.hasOwnProperty;
var X12 = ($, Y, W) => {
  W = $ != null ? eW2($X2($)) : {};
  const X = Y || !$ || !$.__esModule ? S62(W, "default", { value: $, enumerable: true }) : W;
  for (let Z of YX2($))
    if (!WX2.call(X, Z))
      S62(X, Z, { get: () => $[Z], enumerable: true });
  return X;
};
var J02 = ($, Y) => () => (Y || $((Y = { exports: {} }).exports, Y), Y.exports);
var R62 = J02((O7, a$) => {
  var r1 = function() {
  }, QX = function($, Y, W) {
    this.fn = $, this.context = Y, this.once = W || false;
  }, I6 = function($, Y, W, X, Z) {
    if (typeof W !== "function")
      throw new TypeError("The listener must be a function");
    var Q = new QX(W, X || $, Z), J = _0 ? _0 + Y : Y;
    if (!$._events[J])
      $._events[J] = Q, $._eventsCount++;
    else if (!$._events[J].fn)
      $._events[J].push(Q);
    else
      $._events[J] = [$._events[J], Q];
    return $;
  }, K$ = function($, Y) {
    if (--$._eventsCount === 0)
      $._events = new r1;
    else
      delete $._events[Y];
  }, R0 = function() {
    this._events = new r1, this._eventsCount = 0;
  }, ZX = Object.prototype.hasOwnProperty, _0 = "~";
  if (Object.create) {
    if (r1.prototype = Object.create(null), !new r1().__proto__)
      _0 = false;
  }
  R0.prototype.eventNames = function $() {
    var Y = [], W, X;
    if (this._eventsCount === 0)
      return Y;
    for (X in W = this._events)
      if (ZX.call(W, X))
        Y.push(_0 ? X.slice(1) : X);
    if (Object.getOwnPropertySymbols)
      return Y.concat(Object.getOwnPropertySymbols(W));
    return Y;
  };
  R0.prototype.listeners = function $(Y) {
    var W = _0 ? _0 + Y : Y, X = this._events[W];
    if (!X)
      return [];
    if (X.fn)
      return [X.fn];
    for (var Z = 0, Q = X.length, J = new Array(Q);Z < Q; Z++)
      J[Z] = X[Z].fn;
    return J;
  };
  R0.prototype.listenerCount = function $(Y) {
    var W = _0 ? _0 + Y : Y, X = this._events[W];
    if (!X)
      return 0;
    if (X.fn)
      return 1;
    return X.length;
  };
  R0.prototype.emit = function $(Y, W, X, Z, Q, J) {
    var q = _0 ? _0 + Y : Y;
    if (!this._events[q])
      return false;
    var F = this._events[q], D = arguments.length, K, A;
    if (F.fn) {
      if (F.once)
        this.removeListener(Y, F.fn, undefined, true);
      switch (D) {
        case 1:
          return F.fn.call(F.context), true;
        case 2:
          return F.fn.call(F.context, W), true;
        case 3:
          return F.fn.call(F.context, W, X), true;
        case 4:
          return F.fn.call(F.context, W, X, Z), true;
        case 5:
          return F.fn.call(F.context, W, X, Z, Q), true;
        case 6:
          return F.fn.call(F.context, W, X, Z, Q, J), true;
      }
      for (A = 1, K = new Array(D - 1);A < D; A++)
        K[A - 1] = arguments[A];
      F.fn.apply(F.context, K);
    } else {
      var I = F.length, j;
      for (A = 0;A < I; A++) {
        if (F[A].once)
          this.removeListener(Y, F[A].fn, undefined, true);
        switch (D) {
          case 1:
            F[A].fn.call(F[A].context);
            break;
          case 2:
            F[A].fn.call(F[A].context, W);
            break;
          case 3:
            F[A].fn.call(F[A].context, W, X);
            break;
          case 4:
            F[A].fn.call(F[A].context, W, X, Z);
            break;
          default:
            if (!K)
              for (j = 1, K = new Array(D - 1);j < D; j++)
                K[j - 1] = arguments[j];
            F[A].fn.apply(F[A].context, K);
        }
      }
    }
    return true;
  };
  R0.prototype.on = function $(Y, W, X) {
    return I6(this, Y, W, X, false);
  };
  R0.prototype.once = function $(Y, W, X) {
    return I6(this, Y, W, X, true);
  };
  R0.prototype.removeListener = function $(Y, W, X, Z) {
    var Q = _0 ? _0 + Y : Y;
    if (!this._events[Q])
      return this;
    if (!W)
      return K$(this, Q), this;
    var J = this._events[Q];
    if (J.fn) {
      if (J.fn === W && (!Z || J.once) && (!X || J.context === X))
        K$(this, Q);
    } else {
      for (var q = 0, F = [], D = J.length;q < D; q++)
        if (J[q].fn !== W || Z && !J[q].once || X && J[q].context !== X)
          F.push(J[q]);
      if (F.length)
        this._events[Q] = F.length === 1 ? F[0] : F;
      else
        K$(this, Q);
    }
    return this;
  };
  R0.prototype.removeAllListeners = function $(Y) {
    var W;
    if (Y) {
      if (W = _0 ? _0 + Y : Y, this._events[W])
        K$(this, W);
    } else
      this._events = new r1, this._eventsCount = 0;
    return this;
  };
  R0.prototype.off = R0.prototype.removeListener;
  R0.prototype.addListener = R0.prototype.on;
  R0.prefixed = _0;
  R0.EventEmitter = R0;
  if (typeof a$ !== "undefined")
    a$.exports = R0;
});
var V02 = J02((d6) => {
  var JX = function($) {
    return j$($) && (Symbol.asyncIterator in $);
  }, zX = function($) {
    return j$($) && (Symbol.iterator in $);
  }, HX = function($) {
    return ArrayBuffer.isView($);
  }, qX = function($) {
    return $ instanceof Promise;
  }, MX = function($) {
    return $ instanceof Uint8Array;
  }, NX = function($) {
    return $ instanceof Date && Number.isFinite($.getTime());
  }, UX = function($, Y) {
    return Y in $;
  }, FX = function($) {
    return j$($) && f6($.constructor) && $.constructor.name === "Object";
  }, j$ = function($) {
    return $ !== null && typeof $ === "object";
  }, BX = function($) {
    return Array.isArray($) && !ArrayBuffer.isView($);
  }, E6 = function($) {
    return $ === undefined;
  }, V6 = function($) {
    return $ === null;
  }, x6 = function($) {
    return typeof $ === "boolean";
  }, e$ = function($) {
    return typeof $ === "number";
  }, AX = function($) {
    return e$($) && Number.isInteger($);
  }, k6 = function($) {
    return typeof $ === "bigint";
  }, g6 = function($) {
    return typeof $ === "string";
  }, f6 = function($) {
    return typeof $ === "function";
  }, T6 = function($) {
    return typeof $ === "symbol";
  }, DX = function($) {
    return k6($) || x6($) || V6($) || e$($) || g6($) || T6($) || E6($);
  };
  Object.defineProperty(d6, "__esModule", { value: true });
  d6.IsValueType = d6.IsSymbol = d6.IsFunction = d6.IsString = d6.IsBigInt = d6.IsInteger = d6.IsNumber = d6.IsBoolean = d6.IsNull = d6.IsUndefined = d6.IsArray = d6.IsObject = d6.IsPlainObject = d6.HasPropertyKey = d6.IsDate = d6.IsUint8Array = d6.IsPromise = d6.IsTypedArray = d6.IsIterator = d6.IsAsyncIterator = undefined;
  d6.IsAsyncIterator = JX;
  d6.IsIterator = zX;
  d6.IsTypedArray = HX;
  d6.IsPromise = qX;
  d6.IsUint8Array = MX;
  d6.IsDate = NX;
  d6.HasPropertyKey = UX;
  d6.IsPlainObject = FX;
  d6.IsObject = j$;
  d6.IsArray = BX;
  d6.IsUndefined = E6;
  d6.IsNull = V6;
  d6.IsBoolean = x6;
  d6.IsNumber = e$;
  d6.IsInteger = AX;
  d6.IsBigInt = k6;
  d6.IsString = g6;
  d6.IsFunction = f6;
  d6.IsSymbol = T6;
  d6.IsValueType = DX;
});
var f02 = J02((m6) => {
  Object.defineProperty(m6, "__esModule", { value: true });
  m6.Type = m6.JsonType = m6.JavaScriptTypeBuilder = m6.JsonTypeBuilder = m6.TypeBuilder = m6.TypeBuilderError = m6.TransformEncodeBuilder = m6.TransformDecodeBuilder = m6.TemplateLiteralDslParser = m6.TemplateLiteralGenerator = m6.TemplateLiteralGeneratorError = m6.TemplateLiteralFinite = m6.TemplateLiteralFiniteError = m6.TemplateLiteralParser = m6.TemplateLiteralParserError = m6.TemplateLiteralResolver = m6.TemplateLiteralPattern = m6.TemplateLiteralPatternError = m6.UnionResolver = m6.KeyArrayResolver = m6.KeyArrayResolverError = m6.KeyResolver = m6.ObjectMap = m6.Intrinsic = m6.IndexedAccessor = m6.TypeClone = m6.TypeExtends = m6.TypeExtendsResult = m6.TypeExtendsError = m6.ExtendsUndefined = m6.TypeGuard = m6.TypeGuardUnknownTypeError = m6.ValueGuard = m6.FormatRegistry = m6.TypeBoxError = m6.TypeRegistry = m6.PatternStringExact = m6.PatternNumberExact = m6.PatternBooleanExact = m6.PatternString = m6.PatternNumber = m6.PatternBoolean = m6.Kind = m6.Hint = m6.Optional = m6.Readonly = m6.Transform = undefined;
  m6.Transform = Symbol.for("TypeBox.Transform");
  m6.Readonly = Symbol.for("TypeBox.Readonly");
  m6.Optional = Symbol.for("TypeBox.Optional");
  m6.Hint = Symbol.for("TypeBox.Hint");
  m6.Kind = Symbol.for("TypeBox.Kind");
  m6.PatternBoolean = "(true|false)";
  m6.PatternNumber = "(0|[1-9][0-9]*)";
  m6.PatternString = "(.*)";
  m6.PatternBooleanExact = `^${m6.PatternBoolean}$`;
  m6.PatternNumberExact = `^${m6.PatternNumber}$`;
  m6.PatternStringExact = `^${m6.PatternString}$`;
  var $8;
  (function($) {
    const Y = new Map;
    function W() {
      return new Map(Y);
    }
    $.Entries = W;
    function X() {
      return Y.clear();
    }
    $.Clear = X;
    function Z(F) {
      return Y.delete(F);
    }
    $.Delete = Z;
    function Q(F) {
      return Y.has(F);
    }
    $.Has = Q;
    function J(F, D) {
      Y.set(F, D);
    }
    $.Set = J;
    function q(F) {
      return Y.get(F);
    }
    $.Get = q;
  })($8 || (m6.TypeRegistry = $8 = {}));

  class e0 extends Error {
    constructor($) {
      super($);
    }
  }
  m6.TypeBoxError = e0;
  var v6;
  (function($) {
    const Y = new Map;
    function W() {
      return new Map(Y);
    }
    $.Entries = W;
    function X() {
      return Y.clear();
    }
    $.Clear = X;
    function Z(F) {
      return Y.delete(F);
    }
    $.Delete = Z;
    function Q(F) {
      return Y.has(F);
    }
    $.Has = Q;
    function J(F, D) {
      Y.set(F, D);
    }
    $.Set = J;
    function q(F) {
      return Y.get(F);
    }
    $.Get = q;
  })(v6 || (m6.FormatRegistry = v6 = {}));
  var x;
  (function($) {
    function Y(D) {
      return Array.isArray(D);
    }
    $.IsArray = Y;
    function W(D) {
      return typeof D === "bigint";
    }
    $.IsBigInt = W;
    function X(D) {
      return typeof D === "boolean";
    }
    $.IsBoolean = X;
    function Z(D) {
      return D === null;
    }
    $.IsNull = Z;
    function Q(D) {
      return typeof D === "number";
    }
    $.IsNumber = Q;
    function J(D) {
      return typeof D === "object" && D !== null;
    }
    $.IsObject = J;
    function q(D) {
      return typeof D === "string";
    }
    $.IsString = q;
    function F(D) {
      return D === undefined;
    }
    $.IsUndefined = F;
  })(x || (m6.ValueGuard = x = {}));

  class i6 extends e0 {
  }
  m6.TypeGuardUnknownTypeError = i6;
  var B;
  (function($) {
    function Y(M) {
      try {
        return new RegExp(M), true;
      } catch {
        return false;
      }
    }
    function W(M) {
      if (!x.IsString(M))
        return false;
      for (let l = 0;l < M.length; l++) {
        const S0 = M.charCodeAt(l);
        if (S0 >= 7 && S0 <= 13 || S0 === 27 || S0 === 127)
          return false;
      }
      return true;
    }
    function X(M) {
      return J(M) || X0(M);
    }
    function Z(M) {
      return x.IsUndefined(M) || x.IsBigInt(M);
    }
    function Q(M) {
      return x.IsUndefined(M) || x.IsNumber(M);
    }
    function J(M) {
      return x.IsUndefined(M) || x.IsBoolean(M);
    }
    function q(M) {
      return x.IsUndefined(M) || x.IsString(M);
    }
    function F(M) {
      return x.IsUndefined(M) || x.IsString(M) && W(M) && Y(M);
    }
    function D(M) {
      return x.IsUndefined(M) || x.IsString(M) && W(M);
    }
    function K(M) {
      return x.IsUndefined(M) || X0(M);
    }
    function A(M) {
      return G(M, "Any") && q(M.$id);
    }
    $.TAny = A;
    function I(M) {
      return G(M, "Array") && M.type === "array" && q(M.$id) && X0(M.items) && Q(M.minItems) && Q(M.maxItems) && J(M.uniqueItems) && K(M.contains) && Q(M.minContains) && Q(M.maxContains);
    }
    $.TArray = I;
    function j(M) {
      return G(M, "AsyncIterator") && M.type === "AsyncIterator" && q(M.$id) && X0(M.items);
    }
    $.TAsyncIterator = j;
    function N(M) {
      return G(M, "BigInt") && M.type === "bigint" && q(M.$id) && Z(M.exclusiveMaximum) && Z(M.exclusiveMinimum) && Z(M.maximum) && Z(M.minimum) && Z(M.multipleOf);
    }
    $.TBigInt = N;
    function L(M) {
      return G(M, "Boolean") && M.type === "boolean" && q(M.$id);
    }
    $.TBoolean = L;
    function O(M) {
      return G(M, "Constructor") && M.type === "Constructor" && q(M.$id) && x.IsArray(M.parameters) && M.parameters.every((l) => X0(l)) && X0(M.returns);
    }
    $.TConstructor = O;
    function U(M) {
      return G(M, "Date") && M.type === "Date" && q(M.$id) && Q(M.exclusiveMaximumTimestamp) && Q(M.exclusiveMinimumTimestamp) && Q(M.maximumTimestamp) && Q(M.minimumTimestamp) && Q(M.multipleOfTimestamp);
    }
    $.TDate = U;
    function w(M) {
      return G(M, "Function") && M.type === "Function" && q(M.$id) && x.IsArray(M.parameters) && M.parameters.every((l) => X0(l)) && X0(M.returns);
    }
    $.TFunction = w;
    function R(M) {
      return G(M, "Integer") && M.type === "integer" && q(M.$id) && Q(M.exclusiveMaximum) && Q(M.exclusiveMinimum) && Q(M.maximum) && Q(M.minimum) && Q(M.multipleOf);
    }
    $.TInteger = R;
    function b(M) {
      return G(M, "Intersect") && (x.IsString(M.type) && M.type !== "object" ? false : true) && x.IsArray(M.allOf) && M.allOf.every((l) => X0(l) && !D0(l)) && q(M.type) && (J(M.unevaluatedProperties) || K(M.unevaluatedProperties)) && q(M.$id);
    }
    $.TIntersect = b;
    function V(M) {
      return G(M, "Iterator") && M.type === "Iterator" && q(M.$id) && X0(M.items);
    }
    $.TIterator = V;
    function G(M, l) {
      return n(M) && M[m6.Kind] === l;
    }
    $.TKindOf = G;
    function n(M) {
      return x.IsObject(M) && (m6.Kind in M) && x.IsString(M[m6.Kind]);
    }
    $.TKind = n;
    function o(M) {
      return w0(M) && x.IsString(M.const);
    }
    $.TLiteralString = o;
    function $0(M) {
      return w0(M) && x.IsNumber(M.const);
    }
    $.TLiteralNumber = $0;
    function h0(M) {
      return w0(M) && x.IsBoolean(M.const);
    }
    $.TLiteralBoolean = h0;
    function w0(M) {
      return G(M, "Literal") && q(M.$id) && (x.IsBoolean(M.const) || x.IsNumber(M.const) || x.IsString(M.const));
    }
    $.TLiteral = w0;
    function k0(M) {
      return G(M, "Never") && x.IsObject(M.not) && Object.getOwnPropertyNames(M.not).length === 0;
    }
    $.TNever = k0;
    function F0(M) {
      return G(M, "Not") && X0(M.not);
    }
    $.TNot = F0;
    function v0(M) {
      return G(M, "Null") && M.type === "null" && q(M.$id);
    }
    $.TNull = v0;
    function z0(M) {
      return G(M, "Number") && M.type === "number" && q(M.$id) && Q(M.exclusiveMaximum) && Q(M.exclusiveMinimum) && Q(M.maximum) && Q(M.minimum) && Q(M.multipleOf);
    }
    $.TNumber = z0;
    function p0(M) {
      return G(M, "Object") && M.type === "object" && q(M.$id) && x.IsObject(M.properties) && X(M.additionalProperties) && Q(M.minProperties) && Q(M.maxProperties) && Object.entries(M.properties).every(([l, S0]) => W(l) && X0(S0));
    }
    $.TObject = p0;
    function g0(M) {
      return G(M, "Promise") && M.type === "Promise" && q(M.$id) && X0(M.item);
    }
    $.TPromise = g0;
    function M0(M) {
      return G(M, "Record") && M.type === "object" && q(M.$id) && X(M.additionalProperties) && x.IsObject(M.patternProperties) && ((l) => {
        const S0 = Object.getOwnPropertyNames(l.patternProperties);
        return S0.length === 1 && Y(S0[0]) && x.IsObject(l.patternProperties) && X0(l.patternProperties[S0[0]]);
      })(M);
    }
    $.TRecord = M0;
    function E(M) {
      return x.IsObject(M) && (m6.Hint in M) && M[m6.Hint] === "Recursive";
    }
    $.TRecursive = E;
    function d(M) {
      return G(M, "Ref") && q(M.$id) && x.IsString(M.$ref);
    }
    $.TRef = d;
    function u(M) {
      return G(M, "String") && M.type === "string" && q(M.$id) && Q(M.minLength) && Q(M.maxLength) && F(M.pattern) && D(M.format);
    }
    $.TString = u;
    function t(M) {
      return G(M, "Symbol") && M.type === "symbol" && q(M.$id);
    }
    $.TSymbol = t;
    function H0(M) {
      return G(M, "TemplateLiteral") && M.type === "string" && x.IsString(M.pattern) && M.pattern[0] === "^" && M.pattern[M.pattern.length - 1] === "$";
    }
    $.TTemplateLiteral = H0;
    function E0(M) {
      return G(M, "This") && q(M.$id) && x.IsString(M.$ref);
    }
    $.TThis = E0;
    function D0(M) {
      return x.IsObject(M) && (m6.Transform in M);
    }
    $.TTransform = D0;
    function a(M) {
      return G(M, "Tuple") && M.type === "array" && q(M.$id) && x.IsNumber(M.minItems) && x.IsNumber(M.maxItems) && M.minItems === M.maxItems && (x.IsUndefined(M.items) && x.IsUndefined(M.additionalItems) && M.minItems === 0 || x.IsArray(M.items) && M.items.every((l) => X0(l)));
    }
    $.TTuple = a;
    function B12(M) {
      return G(M, "Undefined") && M.type === "undefined" && q(M.$id);
    }
    $.TUndefined = B12;
    function P(M) {
      return _(M) && M.anyOf.every((l) => o(l) || $0(l));
    }
    $.TUnionLiteral = P;
    function _(M) {
      return G(M, "Union") && q(M.$id) && x.IsObject(M) && x.IsArray(M.anyOf) && M.anyOf.every((l) => X0(l));
    }
    $.TUnion = _;
    function S(M) {
      return G(M, "Uint8Array") && M.type === "Uint8Array" && q(M.$id) && Q(M.minByteLength) && Q(M.maxByteLength);
    }
    $.TUint8Array = S;
    function p(M) {
      return G(M, "Unknown") && q(M.$id);
    }
    $.TUnknown = p;
    function f(M) {
      return G(M, "Unsafe");
    }
    $.TUnsafe = f;
    function T(M) {
      return G(M, "Void") && M.type === "void" && q(M.$id);
    }
    $.TVoid = T;
    function W0(M) {
      return x.IsObject(M) && M[m6.Readonly] === "Readonly";
    }
    $.TReadonly = W0;
    function K0(M) {
      return x.IsObject(M) && M[m6.Optional] === "Optional";
    }
    $.TOptional = K0;
    function X0(M) {
      return x.IsObject(M) && (A(M) || I(M) || L(M) || N(M) || j(M) || O(M) || U(M) || w(M) || R(M) || b(M) || V(M) || w0(M) || k0(M) || F0(M) || v0(M) || z0(M) || p0(M) || g0(M) || M0(M) || d(M) || u(M) || t(M) || H0(M) || E0(M) || a(M) || B12(M) || _(M) || S(M) || p(M) || f(M) || T(M) || n(M) && $8.Has(M[m6.Kind]));
    }
    $.TSchema = X0;
  })(B || (m6.TypeGuard = B = {}));
  var p6;
  (function($) {
    function Y(W) {
      return W[m6.Kind] === "Intersect" ? W.allOf.every((X) => Y(X)) : W[m6.Kind] === "Union" ? W.anyOf.some((X) => Y(X)) : W[m6.Kind] === "Undefined" ? true : W[m6.Kind] === "Not" ? !Y(W.not) : false;
    }
    $.Check = Y;
  })(p6 || (m6.ExtendsUndefined = p6 = {}));

  class Z8 extends e0 {
  }
  m6.TypeExtendsError = Z8;
  var C;
  (function($) {
    $[$.Union = 0] = "Union", $[$.True = 1] = "True", $[$.False = 2] = "False";
  })(C || (m6.TypeExtendsResult = C = {}));
  var K12;
  (function($) {
    function Y(z2) {
      return z2 === C.False ? z2 : C.True;
    }
    function W(z2) {
      throw new Z8(z2);
    }
    function X(z2) {
      return B.TNever(z2) || B.TIntersect(z2) || B.TUnion(z2) || B.TUnknown(z2) || B.TAny(z2);
    }
    function Z(z2, H) {
      return B.TNever(H) ? G(z2, H) : B.TIntersect(H) ? w(z2, H) : B.TUnion(H) ? s$(z2, H) : B.TUnknown(H) ? O6(z2, H) : B.TAny(H) ? Q(z2, H) : W("StructuralRight");
    }
    function Q(z2, H) {
      return C.True;
    }
    function J(z2, H) {
      return B.TIntersect(H) ? w(z2, H) : B.TUnion(H) && H.anyOf.some((Y0) => B.TAny(Y0) || B.TUnknown(Y0)) ? C.True : B.TUnion(H) ? C.Union : B.TUnknown(H) ? C.True : B.TAny(H) ? C.True : C.Union;
    }
    function q(z2, H) {
      return B.TUnknown(z2) ? C.False : B.TAny(z2) ? C.Union : B.TNever(z2) ? C.True : C.False;
    }
    function F(z2, H) {
      return B.TObject(H) && H0(H) ? C.True : X(H) ? Z(z2, H) : !B.TArray(H) ? C.False : Y(Q0(z2.items, H.items));
    }
    function D(z2, H) {
      return X(H) ? Z(z2, H) : !B.TAsyncIterator(H) ? C.False : Y(Q0(z2.items, H.items));
    }
    function K(z2, H) {
      return X(H) ? Z(z2, H) : B.TObject(H) ? a(z2, H) : B.TRecord(H) ? p(z2, H) : B.TBigInt(H) ? C.True : C.False;
    }
    function A(z2, H) {
      return B.TLiteral(z2) && x.IsBoolean(z2.const) ? C.True : B.TBoolean(z2) ? C.True : C.False;
    }
    function I(z2, H) {
      return X(H) ? Z(z2, H) : B.TObject(H) ? a(z2, H) : B.TRecord(H) ? p(z2, H) : B.TBoolean(H) ? C.True : C.False;
    }
    function j(z2, H) {
      return X(H) ? Z(z2, H) : B.TObject(H) ? a(z2, H) : !B.TConstructor(H) ? C.False : z2.parameters.length > H.parameters.length ? C.False : !z2.parameters.every((Y0, n0) => Y(Q0(H.parameters[n0], Y0)) === C.True) ? C.False : Y(Q0(z2.returns, H.returns));
    }
    function N(z2, H) {
      return X(H) ? Z(z2, H) : B.TObject(H) ? a(z2, H) : B.TRecord(H) ? p(z2, H) : B.TDate(H) ? C.True : C.False;
    }
    function L(z2, H) {
      return X(H) ? Z(z2, H) : B.TObject(H) ? a(z2, H) : !B.TFunction(H) ? C.False : z2.parameters.length > H.parameters.length ? C.False : !z2.parameters.every((Y0, n0) => Y(Q0(H.parameters[n0], Y0)) === C.True) ? C.False : Y(Q0(z2.returns, H.returns));
    }
    function O(z2, H) {
      return B.TLiteral(z2) && x.IsNumber(z2.const) ? C.True : B.TNumber(z2) || B.TInteger(z2) ? C.True : C.False;
    }
    function U(z2, H) {
      return B.TInteger(H) || B.TNumber(H) ? C.True : X(H) ? Z(z2, H) : B.TObject(H) ? a(z2, H) : B.TRecord(H) ? p(z2, H) : C.False;
    }
    function w(z2, H) {
      return H.allOf.every((Y0) => Q0(z2, Y0) === C.True) ? C.True : C.False;
    }
    function R(z2, H) {
      return z2.allOf.some((Y0) => Q0(Y0, H) === C.True) ? C.True : C.False;
    }
    function b(z2, H) {
      return X(H) ? Z(z2, H) : !B.TIterator(H) ? C.False : Y(Q0(z2.items, H.items));
    }
    function V(z2, H) {
      return B.TLiteral(H) && H.const === z2.const ? C.True : X(H) ? Z(z2, H) : B.TObject(H) ? a(z2, H) : B.TRecord(H) ? p(z2, H) : B.TString(H) ? T(z2, H) : B.TNumber(H) ? w0(z2, H) : B.TInteger(H) ? O(z2, H) : B.TBoolean(H) ? A(z2, H) : C.False;
    }
    function G(z2, H) {
      return C.False;
    }
    function n(z2, H) {
      return C.True;
    }
    function o(z2) {
      let [H, Y0] = [z2, 0];
      while (true) {
        if (!B.TNot(H))
          break;
        H = H.not, Y0 += 1;
      }
      return Y0 % 2 === 0 ? H : m6.Type.Unknown();
    }
    function $0(z2, H) {
      return B.TNot(z2) ? Q0(o(z2), H) : B.TNot(H) ? Q0(z2, o(H)) : W("Invalid fallthrough for Not");
    }
    function h0(z2, H) {
      return X(H) ? Z(z2, H) : B.TObject(H) ? a(z2, H) : B.TRecord(H) ? p(z2, H) : B.TNull(H) ? C.True : C.False;
    }
    function w0(z2, H) {
      return B.TLiteralNumber(z2) ? C.True : B.TNumber(z2) || B.TInteger(z2) ? C.True : C.False;
    }
    function k0(z2, H) {
      return X(H) ? Z(z2, H) : B.TObject(H) ? a(z2, H) : B.TRecord(H) ? p(z2, H) : B.TInteger(H) || B.TNumber(H) ? C.True : C.False;
    }
    function F0(z2, H) {
      return Object.getOwnPropertyNames(z2.properties).length === H;
    }
    function v0(z2) {
      return H0(z2);
    }
    function z0(z2) {
      return F0(z2, 0) || F0(z2, 1) && ("description" in z2.properties) && B.TUnion(z2.properties.description) && z2.properties.description.anyOf.length === 2 && (B.TString(z2.properties.description.anyOf[0]) && B.TUndefined(z2.properties.description.anyOf[1]) || B.TString(z2.properties.description.anyOf[1]) && B.TUndefined(z2.properties.description.anyOf[0]));
    }
    function p0(z2) {
      return F0(z2, 0);
    }
    function g0(z2) {
      return F0(z2, 0);
    }
    function M0(z2) {
      return F0(z2, 0);
    }
    function E(z2) {
      return F0(z2, 0);
    }
    function d(z2) {
      return H0(z2);
    }
    function u(z2) {
      const H = m6.Type.Number();
      return F0(z2, 0) || F0(z2, 1) && ("length" in z2.properties) && Y(Q0(z2.properties.length, H)) === C.True;
    }
    function t(z2) {
      return F0(z2, 0);
    }
    function H0(z2) {
      const H = m6.Type.Number();
      return F0(z2, 0) || F0(z2, 1) && ("length" in z2.properties) && Y(Q0(z2.properties.length, H)) === C.True;
    }
    function E0(z2) {
      const H = m6.Type.Function([m6.Type.Any()], m6.Type.Any());
      return F0(z2, 0) || F0(z2, 1) && ("then" in z2.properties) && Y(Q0(z2.properties.then, H)) === C.True;
    }
    function D0(z2, H) {
      return Q0(z2, H) === C.False ? C.False : B.TOptional(z2) && !B.TOptional(H) ? C.False : C.True;
    }
    function a(z2, H) {
      return B.TUnknown(z2) ? C.False : B.TAny(z2) ? C.Union : B.TNever(z2) || B.TLiteralString(z2) && v0(H) || B.TLiteralNumber(z2) && p0(H) || B.TLiteralBoolean(z2) && g0(H) || B.TSymbol(z2) && z0(H) || B.TBigInt(z2) && M0(H) || B.TString(z2) && v0(H) || B.TSymbol(z2) && z0(H) || B.TNumber(z2) && p0(H) || B.TInteger(z2) && p0(H) || B.TBoolean(z2) && g0(H) || B.TUint8Array(z2) && d(H) || B.TDate(z2) && E(H) || B.TConstructor(z2) && t(H) || B.TFunction(z2) && u(H) ? C.True : B.TRecord(z2) && B.TString(_(z2)) ? (() => {
        return H[m6.Hint] === "Record" ? C.True : C.False;
      })() : B.TRecord(z2) && B.TNumber(_(z2)) ? (() => {
        return F0(H, 0) ? C.True : C.False;
      })() : C.False;
    }
    function B12(z2, H) {
      return X(H) ? Z(z2, H) : B.TRecord(H) ? p(z2, H) : !B.TObject(H) ? C.False : (() => {
        for (let Y0 of Object.getOwnPropertyNames(H.properties)) {
          if (!(Y0 in z2.properties))
            return C.False;
          if (D0(z2.properties[Y0], H.properties[Y0]) === C.False)
            return C.False;
        }
        return C.True;
      })();
    }
    function P(z2, H) {
      return X(H) ? Z(z2, H) : B.TObject(H) && E0(H) ? C.True : !B.TPromise(H) ? C.False : Y(Q0(z2.item, H.item));
    }
    function _(z2) {
      return m6.PatternNumberExact in z2.patternProperties ? m6.Type.Number() : (m6.PatternStringExact in z2.patternProperties) ? m6.Type.String() : W("Unknown record key pattern");
    }
    function S(z2) {
      return m6.PatternNumberExact in z2.patternProperties ? z2.patternProperties[m6.PatternNumberExact] : (m6.PatternStringExact in z2.patternProperties) ? z2.patternProperties[m6.PatternStringExact] : W("Unable to get record value schema");
    }
    function p(z2, H) {
      const [Y0, n0] = [_(H), S(H)];
      return B.TLiteralString(z2) && B.TNumber(Y0) && Y(Q0(z2, n0)) === C.True ? C.True : B.TUint8Array(z2) && B.TNumber(Y0) ? Q0(z2, n0) : B.TString(z2) && B.TNumber(Y0) ? Q0(z2, n0) : B.TArray(z2) && B.TNumber(Y0) ? Q0(z2, n0) : B.TObject(z2) ? (() => {
        for (let aW of Object.getOwnPropertyNames(z2.properties))
          if (D0(n0, z2.properties[aW]) === C.False)
            return C.False;
        return C.True;
      })() : C.False;
    }
    function f(z2, H) {
      return X(H) ? Z(z2, H) : B.TObject(H) ? a(z2, H) : !B.TRecord(H) ? C.False : Q0(S(z2), S(H));
    }
    function T(z2, H) {
      return B.TLiteral(z2) && x.IsString(z2.const) ? C.True : B.TString(z2) ? C.True : C.False;
    }
    function W0(z2, H) {
      return X(H) ? Z(z2, H) : B.TObject(H) ? a(z2, H) : B.TRecord(H) ? p(z2, H) : B.TString(H) ? C.True : C.False;
    }
    function K0(z2, H) {
      return X(H) ? Z(z2, H) : B.TObject(H) ? a(z2, H) : B.TRecord(H) ? p(z2, H) : B.TSymbol(H) ? C.True : C.False;
    }
    function X0(z2, H) {
      return B.TTemplateLiteral(z2) ? Q0(Z1.Resolve(z2), H) : B.TTemplateLiteral(H) ? Q0(z2, Z1.Resolve(H)) : W("Invalid fallthrough for TemplateLiteral");
    }
    function M(z2, H) {
      return B.TArray(H) && z2.items !== undefined && z2.items.every((Y0) => Q0(Y0, H.items) === C.True);
    }
    function l(z2, H) {
      return B.TNever(z2) ? C.True : B.TUnknown(z2) ? C.False : B.TAny(z2) ? C.Union : C.False;
    }
    function S0(z2, H) {
      return X(H) ? Z(z2, H) : B.TObject(H) && H0(H) ? C.True : B.TArray(H) && M(z2, H) ? C.True : !B.TTuple(H) ? C.False : x.IsUndefined(z2.items) && !x.IsUndefined(H.items) || !x.IsUndefined(z2.items) && x.IsUndefined(H.items) ? C.False : x.IsUndefined(z2.items) && !x.IsUndefined(H.items) ? C.True : z2.items.every((Y0, n0) => Q0(Y0, H.items[n0]) === C.True) ? C.True : C.False;
    }
    function l$(z2, H) {
      return X(H) ? Z(z2, H) : B.TObject(H) ? a(z2, H) : B.TRecord(H) ? p(z2, H) : B.TUint8Array(H) ? C.True : C.False;
    }
    function t$(z2, H) {
      return X(H) ? Z(z2, H) : B.TObject(H) ? a(z2, H) : B.TRecord(H) ? p(z2, H) : B.TVoid(H) ? tW(z2, H) : B.TUndefined(H) ? C.True : C.False;
    }
    function s$(z2, H) {
      return H.anyOf.some((Y0) => Q0(z2, Y0) === C.True) ? C.True : C.False;
    }
    function cW(z2, H) {
      return z2.anyOf.every((Y0) => Q0(Y0, H) === C.True) ? C.True : C.False;
    }
    function O6(z2, H) {
      return C.True;
    }
    function lW(z2, H) {
      return B.TNever(H) ? G(z2, H) : B.TIntersect(H) ? w(z2, H) : B.TUnion(H) ? s$(z2, H) : B.TAny(H) ? Q(z2, H) : B.TString(H) ? T(z2, H) : B.TNumber(H) ? w0(z2, H) : B.TInteger(H) ? O(z2, H) : B.TBoolean(H) ? A(z2, H) : B.TArray(H) ? q(z2, H) : B.TTuple(H) ? l(z2, H) : B.TObject(H) ? a(z2, H) : B.TUnknown(H) ? C.True : C.False;
    }
    function tW(z2, H) {
      return B.TUndefined(z2) ? C.True : B.TUndefined(z2) ? C.True : C.False;
    }
    function sW(z2, H) {
      return B.TIntersect(H) ? w(z2, H) : B.TUnion(H) ? s$(z2, H) : B.TUnknown(H) ? O6(z2, H) : B.TAny(H) ? Q(z2, H) : B.TObject(H) ? a(z2, H) : B.TVoid(H) ? C.True : C.False;
    }
    function Q0(z2, H) {
      return B.TTemplateLiteral(z2) || B.TTemplateLiteral(H) ? X0(z2, H) : B.TNot(z2) || B.TNot(H) ? $0(z2, H) : B.TAny(z2) ? J(z2, H) : B.TArray(z2) ? F(z2, H) : B.TBigInt(z2) ? K(z2, H) : B.TBoolean(z2) ? I(z2, H) : B.TAsyncIterator(z2) ? D(z2, H) : B.TConstructor(z2) ? j(z2, H) : B.TDate(z2) ? N(z2, H) : B.TFunction(z2) ? L(z2, H) : B.TInteger(z2) ? U(z2, H) : B.TIntersect(z2) ? R(z2, H) : B.TIterator(z2) ? b(z2, H) : B.TLiteral(z2) ? V(z2, H) : B.TNever(z2) ? n(z2, H) : B.TNull(z2) ? h0(z2, H) : B.TNumber(z2) ? k0(z2, H) : B.TObject(z2) ? B12(z2, H) : B.TRecord(z2) ? f(z2, H) : B.TString(z2) ? W0(z2, H) : B.TSymbol(z2) ? K0(z2, H) : B.TTuple(z2) ? S0(z2, H) : B.TPromise(z2) ? P(z2, H) : B.TUint8Array(z2) ? l$(z2, H) : B.TUndefined(z2) ? t$(z2, H) : B.TUnion(z2) ? cW(z2, H) : B.TUnknown(z2) ? lW(z2, H) : B.TVoid(z2) ? sW(z2, H) : W(`Unknown left type operand '${z2[m6.Kind]}'`);
    }
    function rW(z2, H) {
      return Q0(z2, H);
    }
    $.Extends = rW;
  })(K12 || (m6.TypeExtends = K12 = {}));
  var i;
  (function($) {
    function Y(J) {
      const q = Object.getOwnPropertyNames(J).reduce((D, K) => ({ ...D, [K]: X(J[K]) }), {}), F = Object.getOwnPropertySymbols(J).reduce((D, K) => ({ ...D, [K]: X(J[K]) }), {});
      return { ...q, ...F };
    }
    function W(J) {
      return J.map((q) => X(q));
    }
    function X(J) {
      return x.IsArray(J) ? W(J) : x.IsObject(J) ? Y(J) : J;
    }
    function Z(J) {
      return J.map((q) => Q(q));
    }
    $.Rest = Z;
    function Q(J, q = {}) {
      return { ...X(J), ...q };
    }
    $.Type = Q;
  })(i || (m6.TypeClone = i = {}));
  var Y8;
  (function($) {
    function Y(j) {
      return j.map((N) => {
        const { [m6.Optional]: L, ...O } = i.Type(N);
        return O;
      });
    }
    function W(j) {
      return j.every((N) => B.TOptional(N));
    }
    function X(j) {
      return j.some((N) => B.TOptional(N));
    }
    function Z(j) {
      return W(j.allOf) ? m6.Type.Optional(m6.Type.Intersect(Y(j.allOf))) : j;
    }
    function Q(j) {
      return X(j.anyOf) ? m6.Type.Optional(m6.Type.Union(Y(j.anyOf))) : j;
    }
    function J(j) {
      return j[m6.Kind] === "Intersect" ? Z(j) : j[m6.Kind] === "Union" ? Q(j) : j;
    }
    function q(j, N) {
      const L = j.allOf.reduce((O, U) => {
        const w = A(U, N);
        return w[m6.Kind] === "Never" ? O : [...O, w];
      }, []);
      return J(m6.Type.Intersect(L));
    }
    function F(j, N) {
      const L = j.anyOf.map((O) => A(O, N));
      return J(m6.Type.Union(L));
    }
    function D(j, N) {
      const L = j.properties[N];
      return x.IsUndefined(L) ? m6.Type.Never() : m6.Type.Union([L]);
    }
    function K(j, N) {
      const L = j.items;
      if (x.IsUndefined(L))
        return m6.Type.Never();
      const O = L[N];
      if (x.IsUndefined(O))
        return m6.Type.Never();
      return O;
    }
    function A(j, N) {
      return j[m6.Kind] === "Intersect" ? q(j, N) : j[m6.Kind] === "Union" ? F(j, N) : j[m6.Kind] === "Object" ? D(j, N) : j[m6.Kind] === "Tuple" ? K(j, N) : m6.Type.Never();
    }
    function I(j, N, L = {}) {
      const O = N.map((U) => A(j, U.toString()));
      return J(m6.Type.Union(O, L));
    }
    $.Resolve = I;
  })(Y8 || (m6.IndexedAccessor = Y8 = {}));
  var V1;
  (function($) {
    function Y(K) {
      const [A, I] = [K.slice(0, 1), K.slice(1)];
      return `${A.toLowerCase()}${I}`;
    }
    function W(K) {
      const [A, I] = [K.slice(0, 1), K.slice(1)];
      return `${A.toUpperCase()}${I}`;
    }
    function X(K) {
      return K.toUpperCase();
    }
    function Z(K) {
      return K.toLowerCase();
    }
    function Q(K, A) {
      const I = f1.ParseExact(K.pattern);
      if (!T1.Check(I))
        return { ...K, pattern: J(K.pattern, A) };
      const L = [...d1.Generate(I)].map((w) => m6.Type.Literal(w)), O = q(L, A), U = m6.Type.Union(O);
      return m6.Type.TemplateLiteral([U]);
    }
    function J(K, A) {
      return typeof K === "string" ? A === "Uncapitalize" ? Y(K) : A === "Capitalize" ? W(K) : A === "Uppercase" ? X(K) : A === "Lowercase" ? Z(K) : K : K.toString();
    }
    function q(K, A) {
      if (K.length === 0)
        return [];
      const [I, ...j] = K;
      return [D(I, A), ...q(j, A)];
    }
    function F(K, A) {
      return B.TTemplateLiteral(K) ? Q(K, A) : B.TUnion(K) ? m6.Type.Union(q(K.anyOf, A)) : B.TLiteral(K) ? m6.Type.Literal(J(K.const, A)) : K;
    }
    function D(K, A) {
      return F(K, A);
    }
    $.Map = D;
  })(V1 || (m6.Intrinsic = V1 = {}));
  var x1;
  (function($) {
    function Y(J, q) {
      return m6.Type.Intersect(J.allOf.map((F) => Z(F, q)), { ...J });
    }
    function W(J, q) {
      return m6.Type.Union(J.anyOf.map((F) => Z(F, q)), { ...J });
    }
    function X(J, q) {
      return q(J);
    }
    function Z(J, q) {
      return J[m6.Kind] === "Intersect" ? Y(J, q) : J[m6.Kind] === "Union" ? W(J, q) : J[m6.Kind] === "Object" ? X(J, q) : J;
    }
    function Q(J, q, F) {
      return { ...Z(i.Type(J), q), ...F };
    }
    $.Map = Q;
  })(x1 || (m6.ObjectMap = x1 = {}));
  var P$;
  (function($) {
    function Y(D) {
      return D[0] === "^" && D[D.length - 1] === "$" ? D.slice(1, D.length - 1) : D;
    }
    function W(D, K) {
      return D.allOf.reduce((A, I) => [...A, ...J(I, K)], []);
    }
    function X(D, K) {
      const A = D.anyOf.map((I) => J(I, K));
      return [...A.reduce((I, j) => j.map((N) => A.every((L) => L.includes(N)) ? I.add(N) : I)[0], new Set)];
    }
    function Z(D, K) {
      return Object.getOwnPropertyNames(D.properties);
    }
    function Q(D, K) {
      return K.includePatterns ? Object.getOwnPropertyNames(D.patternProperties) : [];
    }
    function J(D, K) {
      return B.TIntersect(D) ? W(D, K) : B.TUnion(D) ? X(D, K) : B.TObject(D) ? Z(D, K) : B.TRecord(D) ? Q(D, K) : [];
    }
    function q(D, K) {
      return [...new Set(J(D, K))];
    }
    $.ResolveKeys = q;
    function F(D) {
      return `^(${q(D, { includePatterns: true }).map((I) => `(${Y(I)})`).join("|")})$`;
    }
    $.ResolvePattern = F;
  })(P$ || (m6.KeyResolver = P$ = {}));

  class Q8 extends e0 {
  }
  m6.KeyArrayResolverError = Q8;
  var a1;
  (function($) {
    function Y(W) {
      return Array.isArray(W) ? W : B.TUnionLiteral(W) ? W.anyOf.map((X) => X.const.toString()) : B.TLiteral(W) ? [W.const] : B.TTemplateLiteral(W) ? (() => {
        const X = f1.ParseExact(W.pattern);
        if (!T1.Check(X))
          throw new Q8("Cannot resolve keys from infinite template expression");
        return [...d1.Generate(X)];
      })() : [];
    }
    $.Resolve = Y;
  })(a1 || (m6.KeyArrayResolver = a1 = {}));
  var W8;
  (function($) {
    function* Y(X) {
      for (let Z of X.anyOf)
        if (Z[m6.Kind] === "Union")
          yield* Y(Z);
        else
          yield Z;
    }
    function W(X) {
      return m6.Type.Union([...Y(X)], { ...X });
    }
    $.Resolve = W;
  })(W8 || (m6.UnionResolver = W8 = {}));

  class J8 extends e0 {
  }
  m6.TemplateLiteralPatternError = J8;
  var O$;
  (function($) {
    function Y(Q) {
      throw new J8(Q);
    }
    function W(Q) {
      return Q.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function X(Q, J) {
      return B.TTemplateLiteral(Q) ? Q.pattern.slice(1, Q.pattern.length - 1) : B.TUnion(Q) ? `(${Q.anyOf.map((q) => X(q, J)).join("|")})` : B.TNumber(Q) ? `${J}${m6.PatternNumber}` : B.TInteger(Q) ? `${J}${m6.PatternNumber}` : B.TBigInt(Q) ? `${J}${m6.PatternNumber}` : B.TString(Q) ? `${J}${m6.PatternString}` : B.TLiteral(Q) ? `${J}${W(Q.const.toString())}` : B.TBoolean(Q) ? `${J}${m6.PatternBoolean}` : Y(`Unexpected Kind '${Q[m6.Kind]}'`);
    }
    function Z(Q) {
      return `^${Q.map((J) => X(J, "")).join("")}\$`;
    }
    $.Create = Z;
  })(O$ || (m6.TemplateLiteralPattern = O$ = {}));
  var Z1;
  (function($) {
    function Y(W) {
      const X = f1.ParseExact(W.pattern);
      if (!T1.Check(X))
        return m6.Type.String();
      const Z = [...d1.Generate(X)].map((Q) => m6.Type.Literal(Q));
      return m6.Type.Union(Z);
    }
    $.Resolve = Y;
  })(Z1 || (m6.TemplateLiteralResolver = Z1 = {}));

  class S$ extends e0 {
  }
  m6.TemplateLiteralParserError = S$;
  var f1;
  (function($) {
    function Y(j, N, L) {
      return j[N] === L && j.charCodeAt(N - 1) !== 92;
    }
    function W(j, N) {
      return Y(j, N, "(");
    }
    function X(j, N) {
      return Y(j, N, ")");
    }
    function Z(j, N) {
      return Y(j, N, "|");
    }
    function Q(j) {
      if (!(W(j, 0) && X(j, j.length - 1)))
        return false;
      let N = 0;
      for (let L = 0;L < j.length; L++) {
        if (W(j, L))
          N += 1;
        if (X(j, L))
          N -= 1;
        if (N === 0 && L !== j.length - 1)
          return false;
      }
      return true;
    }
    function J(j) {
      return j.slice(1, j.length - 1);
    }
    function q(j) {
      let N = 0;
      for (let L = 0;L < j.length; L++) {
        if (W(j, L))
          N += 1;
        if (X(j, L))
          N -= 1;
        if (Z(j, L) && N === 0)
          return true;
      }
      return false;
    }
    function F(j) {
      for (let N = 0;N < j.length; N++)
        if (W(j, N))
          return true;
      return false;
    }
    function D(j) {
      let [N, L] = [0, 0];
      const O = [];
      for (let w = 0;w < j.length; w++) {
        if (W(j, w))
          N += 1;
        if (X(j, w))
          N -= 1;
        if (Z(j, w) && N === 0) {
          const R = j.slice(L, w);
          if (R.length > 0)
            O.push(A(R));
          L = w + 1;
        }
      }
      const U = j.slice(L);
      if (U.length > 0)
        O.push(A(U));
      if (O.length === 0)
        return { type: "const", const: "" };
      if (O.length === 1)
        return O[0];
      return { type: "or", expr: O };
    }
    function K(j) {
      function N(U, w) {
        if (!W(U, w))
          throw new S$("TemplateLiteralParser: Index must point to open parens");
        let R = 0;
        for (let b = w;b < U.length; b++) {
          if (W(U, b))
            R += 1;
          if (X(U, b))
            R -= 1;
          if (R === 0)
            return [w, b];
        }
        throw new S$("TemplateLiteralParser: Unclosed group parens in expression");
      }
      function L(U, w) {
        for (let R = w;R < U.length; R++)
          if (W(U, R))
            return [w, R];
        return [w, U.length];
      }
      const O = [];
      for (let U = 0;U < j.length; U++)
        if (W(j, U)) {
          const [w, R] = N(j, U), b = j.slice(w, R + 1);
          O.push(A(b)), U = R;
        } else {
          const [w, R] = L(j, U), b = j.slice(w, R);
          if (b.length > 0)
            O.push(A(b));
          U = R - 1;
        }
      return O.length === 0 ? { type: "const", const: "" } : O.length === 1 ? O[0] : { type: "and", expr: O };
    }
    function A(j) {
      return Q(j) ? A(J(j)) : q(j) ? D(j) : F(j) ? K(j) : { type: "const", const: j };
    }
    $.Parse = A;
    function I(j) {
      return A(j.slice(1, j.length - 1));
    }
    $.ParseExact = I;
  })(f1 || (m6.TemplateLiteralParser = f1 = {}));

  class z8 extends e0 {
  }
  m6.TemplateLiteralFiniteError = z8;
  var T1;
  (function($) {
    function Y(J) {
      throw new z8(J);
    }
    function W(J) {
      return J.type === "or" && J.expr.length === 2 && J.expr[0].type === "const" && J.expr[0].const === "0" && J.expr[1].type === "const" && J.expr[1].const === "[1-9][0-9]*";
    }
    function X(J) {
      return J.type === "or" && J.expr.length === 2 && J.expr[0].type === "const" && J.expr[0].const === "true" && J.expr[1].type === "const" && J.expr[1].const === "false";
    }
    function Z(J) {
      return J.type === "const" && J.const === ".*";
    }
    function Q(J) {
      return X(J) ? true : W(J) || Z(J) ? false : J.type === "and" ? J.expr.every((q) => Q(q)) : J.type === "or" ? J.expr.every((q) => Q(q)) : J.type === "const" ? true : Y("Unknown expression type");
    }
    $.Check = Q;
  })(T1 || (m6.TemplateLiteralFinite = T1 = {}));

  class H8 extends e0 {
  }
  m6.TemplateLiteralGeneratorError = H8;
  var d1;
  (function($) {
    function* Y(J) {
      if (J.length === 1)
        return yield* J[0];
      for (let q of J[0])
        for (let F of Y(J.slice(1)))
          yield `${q}${F}`;
    }
    function* W(J) {
      return yield* Y(J.expr.map((q) => [...Q(q)]));
    }
    function* X(J) {
      for (let q of J.expr)
        yield* Q(q);
    }
    function* Z(J) {
      return yield J.const;
    }
    function* Q(J) {
      return J.type === "and" ? yield* W(J) : J.type === "or" ? yield* X(J) : J.type === "const" ? yield* Z(J) : (() => {
        throw new H8("Unknown expression");
      })();
    }
    $.Generate = Q;
  })(d1 || (m6.TemplateLiteralGenerator = d1 = {}));
  var X8;
  (function($) {
    function* Y(Q) {
      const J = Q.trim().replace(/"|'/g, "");
      return J === "boolean" ? yield m6.Type.Boolean() : J === "number" ? yield m6.Type.Number() : J === "bigint" ? yield m6.Type.BigInt() : J === "string" ? yield m6.Type.String() : yield (() => {
        const q = J.split("|").map((F) => m6.Type.Literal(F.trim()));
        return q.length === 0 ? m6.Type.Never() : q.length === 1 ? q[0] : m6.Type.Union(q);
      })();
    }
    function* W(Q) {
      if (Q[1] !== "{") {
        const J = m6.Type.Literal("$"), q = X(Q.slice(1));
        return yield* [J, ...q];
      }
      for (let J = 2;J < Q.length; J++)
        if (Q[J] === "}") {
          const q = Y(Q.slice(2, J)), F = X(Q.slice(J + 1));
          return yield* [...q, ...F];
        }
      yield m6.Type.Literal(Q);
    }
    function* X(Q) {
      for (let J = 0;J < Q.length; J++)
        if (Q[J] === "$") {
          const q = m6.Type.Literal(Q.slice(0, J)), F = W(Q.slice(J));
          return yield* [q, ...F];
        }
      yield m6.Type.Literal(Q);
    }
    function Z(Q) {
      return [...X(Q)];
    }
    $.Parse = Z;
  })(X8 || (m6.TemplateLiteralDslParser = X8 = {}));

  class q8 {
    constructor($) {
      this.schema = $;
    }
    Decode($) {
      return new M8(this.schema, $);
    }
  }
  m6.TransformDecodeBuilder = q8;

  class M8 {
    constructor($, Y) {
      this.schema = $, this.decode = Y;
    }
    Encode($) {
      const Y = i.Type(this.schema);
      return B.TTransform(Y) ? (() => {
        const Z = { Encode: (Q) => Y[m6.Transform].Encode($(Q)), Decode: (Q) => this.decode(Y[m6.Transform].Decode(Q)) };
        return { ...Y, [m6.Transform]: Z };
      })() : (() => {
        const W = { Decode: this.decode, Encode: $ };
        return { ...Y, [m6.Transform]: W };
      })();
    }
  }
  m6.TransformEncodeBuilder = M8;
  var TX = 0;

  class N8 extends e0 {
  }
  m6.TypeBuilderError = N8;

  class U8 {
    Create($) {
      return $;
    }
    Throw($) {
      throw new N8($);
    }
    Discard($, Y) {
      return Y.reduce((W, X) => {
        const { [X]: Z, ...Q } = W;
        return Q;
      }, $);
    }
    Strict($) {
      return JSON.parse(JSON.stringify($));
    }
  }
  m6.TypeBuilder = U8;

  class L$ extends U8 {
    ReadonlyOptional($) {
      return this.Readonly(this.Optional($));
    }
    Readonly($) {
      return { ...i.Type($), [m6.Readonly]: "Readonly" };
    }
    Optional($) {
      return { ...i.Type($), [m6.Optional]: "Optional" };
    }
    Any($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Any" });
    }
    Array($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Array", type: "array", items: i.Type($) });
    }
    Boolean($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Boolean", type: "boolean" });
    }
    Capitalize($, Y = {}) {
      return { ...V1.Map(i.Type($), "Capitalize"), ...Y };
    }
    Composite($, Y) {
      const W = m6.Type.Intersect($, {}), Z = P$.ResolveKeys(W, { includePatterns: false }).reduce((Q, J) => ({ ...Q, [J]: m6.Type.Index(W, [J]) }), {});
      return m6.Type.Object(Z, Y);
    }
    Enum($, Y = {}) {
      const W = Object.getOwnPropertyNames($).filter((Q) => isNaN(Q)).map((Q) => $[Q]), Z = [...new Set(W)].map((Q) => m6.Type.Literal(Q));
      return this.Union(Z, { ...Y, [m6.Hint]: "Enum" });
    }
    Extends($, Y, W, X, Z = {}) {
      switch (K12.Extends($, Y)) {
        case C.Union:
          return this.Union([i.Type(W, Z), i.Type(X, Z)]);
        case C.True:
          return i.Type(W, Z);
        case C.False:
          return i.Type(X, Z);
      }
    }
    Exclude($, Y, W = {}) {
      return B.TTemplateLiteral($) ? this.Exclude(Z1.Resolve($), Y, W) : B.TTemplateLiteral(Y) ? this.Exclude($, Z1.Resolve(Y), W) : B.TUnion($) ? (() => {
        const X = $.anyOf.filter((Z) => K12.Extends(Z, Y) === C.False);
        return X.length === 1 ? i.Type(X[0], W) : this.Union(X, W);
      })() : K12.Extends($, Y) !== C.False ? this.Never(W) : i.Type($, W);
    }
    Extract($, Y, W = {}) {
      return B.TTemplateLiteral($) ? this.Extract(Z1.Resolve($), Y, W) : B.TTemplateLiteral(Y) ? this.Extract($, Z1.Resolve(Y), W) : B.TUnion($) ? (() => {
        const X = $.anyOf.filter((Z) => K12.Extends(Z, Y) !== C.False);
        return X.length === 1 ? i.Type(X[0], W) : this.Union(X, W);
      })() : K12.Extends($, Y) !== C.False ? i.Type($, W) : this.Never(W);
    }
    Index($, Y, W = {}) {
      return B.TArray($) && B.TNumber(Y) ? (() => {
        return i.Type($.items, W);
      })() : B.TTuple($) && B.TNumber(Y) ? (() => {
        const Z = (x.IsUndefined($.items) ? [] : $.items).map((Q) => i.Type(Q));
        return this.Union(Z, W);
      })() : (() => {
        const X = a1.Resolve(Y), Z = i.Type($);
        return Y8.Resolve(Z, X, W);
      })();
    }
    Integer($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Integer", type: "integer" });
    }
    Intersect($, Y = {}) {
      if ($.length === 0)
        return m6.Type.Never();
      if ($.length === 1)
        return i.Type($[0], Y);
      if ($.some((Q) => B.TTransform(Q)))
        this.Throw("Cannot intersect transform types");
      const W = $.every((Q) => B.TObject(Q)), X = i.Rest($), Z = B.TSchema(Y.unevaluatedProperties) ? { unevaluatedProperties: i.Type(Y.unevaluatedProperties) } : {};
      return Y.unevaluatedProperties === false || B.TSchema(Y.unevaluatedProperties) || W ? this.Create({ ...Y, ...Z, [m6.Kind]: "Intersect", type: "object", allOf: X }) : this.Create({ ...Y, ...Z, [m6.Kind]: "Intersect", allOf: X });
    }
    KeyOf($, Y = {}) {
      return B.TRecord($) ? (() => {
        const W = Object.getOwnPropertyNames($.patternProperties)[0];
        return W === m6.PatternNumberExact ? this.Number(Y) : W === m6.PatternStringExact ? this.String(Y) : this.Throw("Unable to resolve key type from Record key pattern");
      })() : B.TTuple($) ? (() => {
        const X = (x.IsUndefined($.items) ? [] : $.items).map((Z, Q) => m6.Type.Literal(Q.toString()));
        return this.Union(X, Y);
      })() : B.TArray($) ? (() => {
        return this.Number(Y);
      })() : (() => {
        const W = P$.ResolveKeys($, { includePatterns: false });
        if (W.length === 0)
          return this.Never(Y);
        const X = W.map((Z) => this.Literal(Z));
        return this.Union(X, Y);
      })();
    }
    Literal($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Literal", const: $, type: typeof $ });
    }
    Lowercase($, Y = {}) {
      return { ...V1.Map(i.Type($), "Lowercase"), ...Y };
    }
    Never($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Never", not: {} });
    }
    Not($, Y) {
      return this.Create({ ...Y, [m6.Kind]: "Not", not: i.Type($) });
    }
    Null($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Null", type: "null" });
    }
    Number($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Number", type: "number" });
    }
    Object($, Y = {}) {
      const W = Object.getOwnPropertyNames($), X = W.filter((q) => B.TOptional($[q])), Z = W.filter((q) => !X.includes(q)), Q = B.TSchema(Y.additionalProperties) ? { additionalProperties: i.Type(Y.additionalProperties) } : {}, J = W.reduce((q, F) => ({ ...q, [F]: i.Type($[F]) }), {});
      return Z.length > 0 ? this.Create({ ...Y, ...Q, [m6.Kind]: "Object", type: "object", properties: J, required: Z }) : this.Create({ ...Y, ...Q, [m6.Kind]: "Object", type: "object", properties: J });
    }
    Omit($, Y, W = {}) {
      const X = a1.Resolve(Y);
      return x1.Map(this.Discard(i.Type($), ["$id", m6.Transform]), (Z) => {
        if (x.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((Q) => !X.includes(Q)), Z.required.length === 0)
            delete Z.required;
        }
        for (let Q of Object.getOwnPropertyNames(Z.properties))
          if (X.includes(Q))
            delete Z.properties[Q];
        return this.Create(Z);
      }, W);
    }
    Partial($, Y = {}) {
      return x1.Map(this.Discard(i.Type($), ["$id", m6.Transform]), (W) => {
        const X = Object.getOwnPropertyNames(W.properties).reduce((Z, Q) => {
          return { ...Z, [Q]: this.Optional(W.properties[Q]) };
        }, {});
        return this.Object(X, this.Discard(W, ["required"]));
      }, Y);
    }
    Pick($, Y, W = {}) {
      const X = a1.Resolve(Y);
      return x1.Map(this.Discard(i.Type($), ["$id", m6.Transform]), (Z) => {
        if (x.IsArray(Z.required)) {
          if (Z.required = Z.required.filter((Q) => X.includes(Q)), Z.required.length === 0)
            delete Z.required;
        }
        for (let Q of Object.getOwnPropertyNames(Z.properties))
          if (!X.includes(Q))
            delete Z.properties[Q];
        return this.Create(Z);
      }, W);
    }
    Record($, Y, W = {}) {
      return B.TTemplateLiteral($) ? (() => {
        const X = f1.ParseExact($.pattern);
        return T1.Check(X) ? this.Object([...d1.Generate(X)].reduce((Z, Q) => ({ ...Z, [Q]: i.Type(Y) }), {}), W) : this.Create({ ...W, [m6.Kind]: "Record", type: "object", patternProperties: { [$.pattern]: i.Type(Y) } });
      })() : B.TUnion($) ? (() => {
        const X = W8.Resolve($);
        if (B.TUnionLiteral(X)) {
          const Z = X.anyOf.reduce((Q, J) => ({ ...Q, [J.const]: i.Type(Y) }), {});
          return this.Object(Z, { ...W, [m6.Hint]: "Record" });
        } else
          this.Throw("Record key of type union contains non-literal types");
      })() : B.TLiteral($) ? (() => {
        return x.IsString($.const) || x.IsNumber($.const) ? this.Object({ [$.const]: i.Type(Y) }, W) : this.Throw("Record key of type literal is not of type string or number");
      })() : B.TInteger($) || B.TNumber($) ? (() => {
        return this.Create({ ...W, [m6.Kind]: "Record", type: "object", patternProperties: { [m6.PatternNumberExact]: i.Type(Y) } });
      })() : B.TString($) ? (() => {
        const X = x.IsUndefined($.pattern) ? m6.PatternStringExact : $.pattern;
        return this.Create({ ...W, [m6.Kind]: "Record", type: "object", patternProperties: { [X]: i.Type(Y) } });
      })() : this.Never();
    }
    Recursive($, Y = {}) {
      if (x.IsUndefined(Y.$id))
        Y.$id = `T${TX++}`;
      const W = $({ [m6.Kind]: "This", $ref: `${Y.$id}` });
      return W.$id = Y.$id, this.Create({ ...Y, [m6.Hint]: "Recursive", ...W });
    }
    Ref($, Y = {}) {
      if (x.IsString($))
        return this.Create({ ...Y, [m6.Kind]: "Ref", $ref: $ });
      if (x.IsUndefined($.$id))
        this.Throw("Reference target type must specify an $id");
      return this.Create({ ...Y, [m6.Kind]: "Ref", $ref: $.$id });
    }
    Required($, Y = {}) {
      return x1.Map(this.Discard(i.Type($), ["$id", m6.Transform]), (W) => {
        const X = Object.getOwnPropertyNames(W.properties).reduce((Z, Q) => {
          return { ...Z, [Q]: this.Discard(W.properties[Q], [m6.Optional]) };
        }, {});
        return this.Object(X, W);
      }, Y);
    }
    Rest($) {
      return B.TTuple($) && !x.IsUndefined($.items) ? i.Rest($.items) : B.TIntersect($) ? i.Rest($.allOf) : B.TUnion($) ? i.Rest($.anyOf) : [];
    }
    String($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "String", type: "string" });
    }
    TemplateLiteral($, Y = {}) {
      const W = x.IsString($) ? O$.Create(X8.Parse($)) : O$.Create($);
      return this.Create({ ...Y, [m6.Kind]: "TemplateLiteral", type: "string", pattern: W });
    }
    Transform($) {
      return new q8($);
    }
    Tuple($, Y = {}) {
      const [W, X, Z] = [false, $.length, $.length], Q = i.Rest($), J = $.length > 0 ? { ...Y, [m6.Kind]: "Tuple", type: "array", items: Q, additionalItems: W, minItems: X, maxItems: Z } : { ...Y, [m6.Kind]: "Tuple", type: "array", minItems: X, maxItems: Z };
      return this.Create(J);
    }
    Uncapitalize($, Y = {}) {
      return { ...V1.Map(i.Type($), "Uncapitalize"), ...Y };
    }
    Union($, Y = {}) {
      return B.TTemplateLiteral($) ? Z1.Resolve($) : (() => {
        const W = $;
        if (W.length === 0)
          return this.Never(Y);
        if (W.length === 1)
          return this.Create(i.Type(W[0], Y));
        const X = i.Rest(W);
        return this.Create({ ...Y, [m6.Kind]: "Union", anyOf: X });
      })();
    }
    Unknown($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Unknown" });
    }
    Unsafe($ = {}) {
      return this.Create({ ...$, [m6.Kind]: $[m6.Kind] || "Unsafe" });
    }
    Uppercase($, Y = {}) {
      return { ...V1.Map(i.Type($), "Uppercase"), ...Y };
    }
  }
  m6.JsonTypeBuilder = L$;

  class F8 extends L$ {
    AsyncIterator($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "AsyncIterator", type: "AsyncIterator", items: i.Type($) });
    }
    Awaited($, Y = {}) {
      const W = (X) => X.length > 0 ? (() => {
        const [Z, ...Q] = X;
        return [this.Awaited(Z), ...W(Q)];
      })() : X;
      return B.TIntersect($) ? m6.Type.Intersect(W($.allOf)) : B.TUnion($) ? m6.Type.Union(W($.anyOf)) : B.TPromise($) ? this.Awaited($.item) : i.Type($, Y);
    }
    BigInt($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "BigInt", type: "bigint" });
    }
    ConstructorParameters($, Y = {}) {
      return this.Tuple([...$.parameters], { ...Y });
    }
    Constructor($, Y, W) {
      const [X, Z] = [i.Rest($), i.Type(Y)];
      return this.Create({ ...W, [m6.Kind]: "Constructor", type: "Constructor", parameters: X, returns: Z });
    }
    Date($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Date", type: "Date" });
    }
    Function($, Y, W) {
      const [X, Z] = [i.Rest($), i.Type(Y)];
      return this.Create({ ...W, [m6.Kind]: "Function", type: "Function", parameters: X, returns: Z });
    }
    InstanceType($, Y = {}) {
      return i.Type($.returns, Y);
    }
    Iterator($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Iterator", type: "Iterator", items: i.Type($) });
    }
    Parameters($, Y = {}) {
      return this.Tuple($.parameters, { ...Y });
    }
    Promise($, Y = {}) {
      return this.Create({ ...Y, [m6.Kind]: "Promise", type: "Promise", item: i.Type($) });
    }
    RegExp($, Y = {}) {
      const W = x.IsString($) ? $ : $.source;
      return this.Create({ ...Y, [m6.Kind]: "String", type: "string", pattern: W });
    }
    RegEx($, Y = {}) {
      return this.RegExp($, Y);
    }
    ReturnType($, Y = {}) {
      return i.Type($.returns, Y);
    }
    Symbol($) {
      return this.Create({ ...$, [m6.Kind]: "Symbol", type: "symbol" });
    }
    Undefined($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Undefined", type: "undefined" });
    }
    Uint8Array($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Uint8Array", type: "Uint8Array" });
    }
    Void($ = {}) {
      return this.Create({ ...$, [m6.Kind]: "Void", type: "void" });
    }
  }
  m6.JavaScriptTypeBuilder = F8;
  m6.JsonType = new L$;
  m6.Type = new F8;
});
var P82 = J02((o6) => {
  var w8 = function($, Y) {
    switch (Y) {
      case y.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case y.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${$.maxContains} matching values`;
      case y.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${$.minContains} matching values`;
      case y.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${$.maxItems}`;
      case y.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${$.minItems}`;
      case y.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case y.ValueErrorType.Array:
        return "Expected array";
      case y.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case y.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.BigInt:
        return "Expected bigint";
      case y.ValueErrorType.Boolean:
        return "Expected boolean";
      case y.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${$.exclusiveMinimumTimestamp}`;
      case y.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${$.exclusiveMaximumTimestamp}`;
      case y.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${$.minimumTimestamp}`;
      case y.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${$.maximumTimestamp}`;
      case y.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${$.multipleOfTimestamp}`;
      case y.ValueErrorType.Date:
        return "Expected Date";
      case y.ValueErrorType.Function:
        return "Expected function";
      case y.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.Integer:
        return "Expected integer";
      case y.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case y.ValueErrorType.Intersect:
        return "Expected all values to match";
      case y.ValueErrorType.Iterator:
        return "Expected Iterator";
      case y.ValueErrorType.Literal:
        return `Expected ${typeof $.const === "string" ? `'${$.const}'` : $.const}`;
      case y.ValueErrorType.Never:
        return "Never";
      case y.ValueErrorType.Not:
        return "Value should not match";
      case y.ValueErrorType.Null:
        return "Expected null";
      case y.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${$.exclusiveMaximum}`;
      case y.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${$.exclusiveMinimum}`;
      case y.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${$.maximum}`;
      case y.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${$.minimum}`;
      case y.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${$.multipleOf}`;
      case y.ValueErrorType.Number:
        return "Expected number";
      case y.ValueErrorType.Object:
        return "Expected object";
      case y.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case y.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${$.maxProperties} properties`;
      case y.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${$.minProperties} properties`;
      case y.ValueErrorType.ObjectRequiredProperty:
        return "Required property";
      case y.ValueErrorType.Promise:
        return "Expected Promise";
      case y.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${$.format}'`;
      case y.ValueErrorType.StringFormat:
        return `Expected string to match '${$.format}' format`;
      case y.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${$.maxLength}`;
      case y.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${$.minLength}`;
      case y.ValueErrorType.StringPattern:
        return `Expected string to match '${$.pattern}'`;
      case y.ValueErrorType.String:
        return "Expected string";
      case y.ValueErrorType.Symbol:
        return "Expected symbol";
      case y.ValueErrorType.TupleLength:
        return `Expected tuple to have ${$.maxItems || 0} elements`;
      case y.ValueErrorType.Tuple:
        return "Expected tuple";
      case y.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${$.maxByteLength}`;
      case y.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${$.minByteLength}`;
      case y.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case y.ValueErrorType.Undefined:
        return "Expected undefined";
      case y.ValueErrorType.Union:
        return "Expected union value";
      case y.ValueErrorType.Void:
        return "Expected void";
      case y.ValueErrorType.Kind:
        return `Expected kind '${$[Q1.Kind]}'`;
      default:
        return "Unknown error type";
    }
  };
  Object.defineProperty(o6, "__esModule", { value: true });
  o6.DefaultErrorFunction = o6.TypeSystemPolicy = o6.TypeSystemErrorFunction = o6.TypeSystem = o6.TypeSystemDuplicateFormat = o6.TypeSystemDuplicateTypeKind = undefined;
  var C$ = V02(), y = Y$2(), Q1 = f02();

  class K8 extends Q1.TypeBoxError {
    constructor($) {
      super(`Duplicate type kind '${$}' detected`);
    }
  }
  o6.TypeSystemDuplicateTypeKind = K8;

  class j8 extends Q1.TypeBoxError {
    constructor($) {
      super(`Duplicate string format '${$}' detected`);
    }
  }
  o6.TypeSystemDuplicateFormat = j8;
  var u6;
  (function($) {
    function Y(X, Z) {
      if (Q1.TypeRegistry.Has(X))
        throw new K8(X);
      return Q1.TypeRegistry.Set(X, Z), (Q = {}) => Q1.Type.Unsafe({ ...Q, [Q1.Kind]: X });
    }
    $.Type = Y;
    function W(X, Z) {
      if (Q1.FormatRegistry.Has(X))
        throw new j8(X);
      return Q1.FormatRegistry.Set(X, Z), X;
    }
    $.Format = W;
  })(u6 || (o6.TypeSystem = u6 = {}));
  var h6;
  (function($) {
    let Y = w8;
    function W() {
      Y = w8;
    }
    $.Reset = W;
    function X(Q) {
      Y = Q;
    }
    $.Set = X;
    function Z() {
      return Y;
    }
    $.Get = Z;
  })(h6 || (o6.TypeSystemErrorFunction = h6 = {}));
  var n6;
  (function($) {
    $.ExactOptionalPropertyTypes = false, $.AllowArrayObject = false, $.AllowNaN = false, $.AllowNullVoid = false;
    function Y(J, q) {
      return $.ExactOptionalPropertyTypes ? q in J : J[q] !== undefined;
    }
    $.IsExactOptionalProperty = Y;
    function W(J) {
      const q = (0, C$.IsObject)(J);
      return $.AllowArrayObject ? q : q && !(0, C$.IsArray)(J);
    }
    $.IsObjectLike = W;
    function X(J) {
      return W(J) && !(J instanceof Date) && !(J instanceof Uint8Array);
    }
    $.IsRecordLike = X;
    function Z(J) {
      const q = (0, C$.IsNumber)(J);
      return $.AllowNaN ? q : q && Number.isFinite(J);
    }
    $.IsNumberLike = Z;
    function Q(J) {
      const q = (0, C$.IsUndefined)(J);
      return $.AllowNullVoid ? q || J === null : q;
    }
    $.IsVoidLike = Q;
  })(n6 || (o6.TypeSystemPolicy = n6 = {}));
  o6.DefaultErrorFunction = w8;
});
var A1 = J02((l6) => {
  var IZ = function($, Y) {
    const W = Y.findIndex((X) => X.$id === $.$ref);
    if (W === -1)
      throw new O8($);
    return Y[W];
  };
  Object.defineProperty(l6, "__esModule", { value: true });
  l6.Deref = l6.TypeDereferenceError = undefined;
  var CZ = f02();

  class O8 extends CZ.TypeBoxError {
    constructor($) {
      super(`Unable to dereference schema with $id '${$.$id}'`);
      this.schema = $;
    }
  }
  l6.TypeDereferenceError = O8;
  l6.Deref = IZ;
});
var W$2 = J02((e6) => {
  function* EZ($) {
    const Y = $ === 0 ? 1 : Math.ceil(Math.floor(Math.log2($) + 1) / 8);
    for (let W = 0;W < Y; W++)
      yield $ >> 8 * (Y - 1 - W) & 255;
  }
  var VZ = function($) {
    b0(T0.Array);
    for (let Y of $)
      v1(Y);
  }, xZ = function($) {
    b0(T0.Boolean), b0($ ? 1 : 0);
  }, kZ = function($) {
    b0(T0.BigInt), r6.setBigInt64(0, $);
    for (let Y of a6)
      b0(Y);
  }, gZ = function($) {
    b0(T0.Date), v1($.getTime());
  }, fZ = function($) {
    b0(T0.Null);
  }, TZ = function($) {
    b0(T0.Number), r6.setFloat64(0, $);
    for (let Y of a6)
      b0(Y);
  }, dZ = function($) {
    b0(T0.Object);
    for (let Y of globalThis.Object.keys($).sort())
      v1(Y), v1($[Y]);
  }, yZ = function($) {
    b0(T0.String);
    for (let Y = 0;Y < $.length; Y++)
      for (let W of EZ($.charCodeAt(Y)))
        b0(W);
  }, vZ = function($) {
    b0(T0.Symbol), v1($.description);
  }, pZ = function($) {
    b0(T0.Uint8Array);
    for (let Y = 0;Y < $.length; Y++)
      b0($[Y]);
  }, iZ = function($) {
    return b0(T0.Undefined);
  }, v1 = function($) {
    if ((0, o0.IsArray)($))
      return VZ($);
    if ((0, o0.IsBoolean)($))
      return xZ($);
    if ((0, o0.IsBigInt)($))
      return kZ($);
    if ((0, o0.IsDate)($))
      return gZ($);
    if ((0, o0.IsNull)($))
      return fZ($);
    if ((0, o0.IsNumber)($))
      return TZ($);
    if ((0, o0.IsPlainObject)($))
      return dZ($);
    if ((0, o0.IsString)($))
      return yZ($);
    if ((0, o0.IsSymbol)($))
      return vZ($);
    if ((0, o0.IsUint8Array)($))
      return pZ($);
    if ((0, o0.IsUndefined)($))
      return iZ($);
    throw new S8($);
  }, b0 = function($) {
    y1 = y1 ^ _Z[$], y1 = y1 * bZ % GZ;
  }, mZ = function($) {
    return y1 = BigInt("14695981039346656037"), v1($), y1;
  };
  Object.defineProperty(e6, "__esModule", { value: true });
  e6.Hash = e6.ByteMarker = e6.ValueHashError = undefined;
  var o0 = V02();

  class S8 extends Error {
    constructor($) {
      super("Unable to hash value");
      this.value = $;
    }
  }
  e6.ValueHashError = S8;
  var T0;
  (function($) {
    $[$.Undefined = 0] = "Undefined", $[$.Null = 1] = "Null", $[$.Boolean = 2] = "Boolean", $[$.Number = 3] = "Number", $[$.String = 4] = "String", $[$.Object = 5] = "Object", $[$.Array = 6] = "Array", $[$.Date = 7] = "Date", $[$.Uint8Array = 8] = "Uint8Array", $[$.Symbol = 9] = "Symbol", $[$.BigInt = 10] = "BigInt";
  })(T0 || (e6.ByteMarker = T0 = {}));
  var y1 = BigInt("14695981039346656037"), [bZ, GZ] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")], _Z = Array.from({ length: 256 }).map(($, Y) => BigInt(Y)), s6 = new Float64Array(1), r6 = new DataView(s6.buffer), a6 = new Uint8Array(s6.buffer);
  e6.Hash = mZ;
});
var Y$2 = J02((WY) => {
  var s = function($) {
    return $ !== undefined;
  }, g = function($, Y, W, X) {
    return { type: $, schema: Y, path: W, value: X, message: p1.TypeSystemErrorFunction.Get()(Y, $) };
  };
  function* oZ($, Y, W, X) {
  }
  function* cZ($, Y, W, X) {
    if (!(0, B0.IsArray)(X))
      return yield g(k.Array, $, W, X);
    if (s($.minItems) && !(X.length >= $.minItems))
      yield g(k.ArrayMinItems, $, W, X);
    if (s($.maxItems) && !(X.length <= $.maxItems))
      yield g(k.ArrayMaxItems, $, W, X);
    for (let J = 0;J < X.length; J++)
      yield* L0($.items, Y, `${W}/${J}`, X[J]);
    if ($.uniqueItems === true && !function() {
      const J = new Set;
      for (let q of X) {
        const F = (0, nZ.Hash)(q);
        if (J.has(F))
          return false;
        else
          J.add(F);
      }
      return true;
    }())
      yield g(k.ArrayUniqueItems, $, W, X);
    if (!(s($.contains) || s($.minContains) || s($.maxContains)))
      return;
    const Z = s($.contains) ? $.contains : i0.Type.Never(), Q = X.reduce((J, q, F) => L0(Z, Y, `${W}${F}`, q).next().done === true ? J + 1 : J, 0);
    if (Q === 0)
      yield g(k.ArrayContains, $, W, X);
    if ((0, B0.IsNumber)($.minContains) && Q < $.minContains)
      yield g(k.ArrayMinContains, $, W, X);
    if ((0, B0.IsNumber)($.maxContains) && Q > $.maxContains)
      yield g(k.ArrayMaxContains, $, W, X);
  }
  function* lZ($, Y, W, X) {
    if (!(0, B0.IsAsyncIterator)(X))
      yield g(k.AsyncIterator, $, W, X);
  }
  function* tZ($, Y, W, X) {
    if (!(0, B0.IsBigInt)(X))
      return yield g(k.BigInt, $, W, X);
    if (s($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(k.BigIntExclusiveMaximum, $, W, X);
    if (s($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(k.BigIntExclusiveMinimum, $, W, X);
    if (s($.maximum) && !(X <= $.maximum))
      yield g(k.BigIntMaximum, $, W, X);
    if (s($.minimum) && !(X >= $.minimum))
      yield g(k.BigIntMinimum, $, W, X);
    if (s($.multipleOf) && X % $.multipleOf !== BigInt(0))
      yield g(k.BigIntMultipleOf, $, W, X);
  }
  function* sZ($, Y, W, X) {
    if (!(0, B0.IsBoolean)(X))
      yield g(k.Boolean, $, W, X);
  }
  function* rZ($, Y, W, X) {
    yield* L0($.returns, Y, W, X.prototype);
  }
  function* aZ($, Y, W, X) {
    if (!(0, B0.IsDate)(X))
      return yield g(k.Date, $, W, X);
    if (s($.exclusiveMaximumTimestamp) && !(X.getTime() < $.exclusiveMaximumTimestamp))
      yield g(k.DateExclusiveMaximumTimestamp, $, W, X);
    if (s($.exclusiveMinimumTimestamp) && !(X.getTime() > $.exclusiveMinimumTimestamp))
      yield g(k.DateExclusiveMinimumTimestamp, $, W, X);
    if (s($.maximumTimestamp) && !(X.getTime() <= $.maximumTimestamp))
      yield g(k.DateMaximumTimestamp, $, W, X);
    if (s($.minimumTimestamp) && !(X.getTime() >= $.minimumTimestamp))
      yield g(k.DateMinimumTimestamp, $, W, X);
    if (s($.multipleOfTimestamp) && X.getTime() % $.multipleOfTimestamp !== 0)
      yield g(k.DateMultipleOfTimestamp, $, W, X);
  }
  function* eZ($, Y, W, X) {
    if (!(0, B0.IsFunction)(X))
      yield g(k.Function, $, W, X);
  }
  function* $4($, Y, W, X) {
    if (!(0, B0.IsInteger)(X))
      return yield g(k.Integer, $, W, X);
    if (s($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(k.IntegerExclusiveMaximum, $, W, X);
    if (s($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(k.IntegerExclusiveMinimum, $, W, X);
    if (s($.maximum) && !(X <= $.maximum))
      yield g(k.IntegerMaximum, $, W, X);
    if (s($.minimum) && !(X >= $.minimum))
      yield g(k.IntegerMinimum, $, W, X);
    if (s($.multipleOf) && X % $.multipleOf !== 0)
      yield g(k.IntegerMultipleOf, $, W, X);
  }
  function* Y4($, Y, W, X) {
    for (let Z of $.allOf) {
      const Q = L0(Z, Y, W, X).next();
      if (!Q.done)
        yield g(k.Intersect, $, W, X), yield Q.value;
    }
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(i0.KeyResolver.ResolvePattern($));
      for (let Q of Object.getOwnPropertyNames(X))
        if (!Z.test(Q))
          yield g(k.IntersectUnevaluatedProperties, $, `${W}/${Q}`, X);
    }
    if (typeof $.unevaluatedProperties === "object") {
      const Z = new RegExp(i0.KeyResolver.ResolvePattern($));
      for (let Q of Object.getOwnPropertyNames(X))
        if (!Z.test(Q)) {
          const J = L0($.unevaluatedProperties, Y, `${W}/${Q}`, X[Q]).next();
          if (!J.done)
            yield J.value;
        }
    }
  }
  function* W4($, Y, W, X) {
    if (!(0, B0.IsIterator)(X))
      yield g(k.Iterator, $, W, X);
  }
  function* X4($, Y, W, X) {
    if (X !== $.const)
      yield g(k.Literal, $, W, X);
  }
  function* Z4($, Y, W, X) {
    yield g(k.Never, $, W, X);
  }
  function* Q4($, Y, W, X) {
    if (L0($.not, Y, W, X).next().done === true)
      yield g(k.Not, $, W, X);
  }
  function* J4($, Y, W, X) {
    if (!(0, B0.IsNull)(X))
      yield g(k.Null, $, W, X);
  }
  function* z4($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsNumberLike(X))
      return yield g(k.Number, $, W, X);
    if (s($.exclusiveMaximum) && !(X < $.exclusiveMaximum))
      yield g(k.NumberExclusiveMaximum, $, W, X);
    if (s($.exclusiveMinimum) && !(X > $.exclusiveMinimum))
      yield g(k.NumberExclusiveMinimum, $, W, X);
    if (s($.maximum) && !(X <= $.maximum))
      yield g(k.NumberMaximum, $, W, X);
    if (s($.minimum) && !(X >= $.minimum))
      yield g(k.NumberMinimum, $, W, X);
    if (s($.multipleOf) && X % $.multipleOf !== 0)
      yield g(k.NumberMultipleOf, $, W, X);
  }
  function* H4($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsObjectLike(X))
      return yield g(k.Object, $, W, X);
    if (s($.minProperties) && !(Object.getOwnPropertyNames(X).length >= $.minProperties))
      yield g(k.ObjectMinProperties, $, W, X);
    if (s($.maxProperties) && !(Object.getOwnPropertyNames(X).length <= $.maxProperties))
      yield g(k.ObjectMaxProperties, $, W, X);
    const Z = Array.isArray($.required) ? $.required : [], Q = Object.getOwnPropertyNames($.properties), J = Object.getOwnPropertyNames(X);
    for (let q of Z) {
      if (J.includes(q))
        continue;
      yield g(k.ObjectRequiredProperty, $.properties[q], `${W}/${q}`, undefined);
    }
    if ($.additionalProperties === false) {
      for (let q of J)
        if (!Q.includes(q))
          yield g(k.ObjectAdditionalProperties, $, `${W}/${q}`, X[q]);
    }
    if (typeof $.additionalProperties === "object")
      for (let q of J) {
        if (Q.includes(q))
          continue;
        yield* L0($.additionalProperties, Y, `${W}/${q}`, X[q]);
      }
    for (let q of Q) {
      const F = $.properties[q];
      if ($.required && $.required.includes(q)) {
        if (yield* L0(F, Y, `${W}/${q}`, X[q]), i0.ExtendsUndefined.Check($) && !(q in X))
          yield g(k.ObjectRequiredProperty, F, `${W}/${q}`, undefined);
      } else if (p1.TypeSystemPolicy.IsExactOptionalProperty(X, q))
        yield* L0(F, Y, `${W}/${q}`, X[q]);
    }
  }
  function* q4($, Y, W, X) {
    if (!(0, B0.IsPromise)(X))
      yield g(k.Promise, $, W, X);
  }
  function* M4($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsRecordLike(X))
      return yield g(k.Object, $, W, X);
    if (s($.minProperties) && !(Object.getOwnPropertyNames(X).length >= $.minProperties))
      yield g(k.ObjectMinProperties, $, W, X);
    if (s($.maxProperties) && !(Object.getOwnPropertyNames(X).length <= $.maxProperties))
      yield g(k.ObjectMaxProperties, $, W, X);
    const [Z, Q] = Object.entries($.patternProperties)[0], J = new RegExp(Z);
    for (let [q, F] of Object.entries(X))
      if (J.test(q))
        yield* L0(Q, Y, `${W}/${q}`, F);
    if (typeof $.additionalProperties === "object") {
      for (let [q, F] of Object.entries(X))
        if (!J.test(q))
          yield* L0($.additionalProperties, Y, `${W}/${q}`, F);
    }
    if ($.additionalProperties === false)
      for (let [q, F] of Object.entries(X)) {
        if (J.test(q))
          continue;
        return yield g(k.ObjectAdditionalProperties, $, `${W}/${q}`, F);
      }
  }
  function* N4($, Y, W, X) {
    yield* L0((0, YY.Deref)($, Y), Y, W, X);
  }
  function* U4($, Y, W, X) {
    if (!(0, B0.IsString)(X))
      return yield g(k.String, $, W, X);
    if (s($.minLength) && !(X.length >= $.minLength))
      yield g(k.StringMinLength, $, W, X);
    if (s($.maxLength) && !(X.length <= $.maxLength))
      yield g(k.StringMaxLength, $, W, X);
    if ((0, B0.IsString)($.pattern)) {
      if (!new RegExp($.pattern).test(X))
        yield g(k.StringPattern, $, W, X);
    }
    if ((0, B0.IsString)($.format)) {
      if (!i0.FormatRegistry.Has($.format))
        yield g(k.StringFormatUnknown, $, W, X);
      else if (!i0.FormatRegistry.Get($.format)(X))
        yield g(k.StringFormat, $, W, X);
    }
  }
  function* F4($, Y, W, X) {
    if (!(0, B0.IsSymbol)(X))
      yield g(k.Symbol, $, W, X);
  }
  function* B4($, Y, W, X) {
    if (!(0, B0.IsString)(X))
      return yield g(k.String, $, W, X);
    if (!new RegExp($.pattern).test(X))
      yield g(k.StringPattern, $, W, X);
  }
  function* A4($, Y, W, X) {
    yield* L0((0, YY.Deref)($, Y), Y, W, X);
  }
  function* D4($, Y, W, X) {
    if (!(0, B0.IsArray)(X))
      return yield g(k.Tuple, $, W, X);
    if ($.items === undefined && X.length !== 0)
      return yield g(k.TupleLength, $, W, X);
    if (X.length !== $.maxItems)
      return yield g(k.TupleLength, $, W, X);
    if (!$.items)
      return;
    for (let Z = 0;Z < $.items.length; Z++)
      yield* L0($.items[Z], Y, `${W}/${Z}`, X[Z]);
  }
  function* w4($, Y, W, X) {
    if (!(0, B0.IsUndefined)(X))
      yield g(k.Undefined, $, W, X);
  }
  function* K4($, Y, W, X) {
    let Z = 0;
    for (let Q of $.anyOf) {
      const J = [...L0(Q, Y, W, X)];
      if (J.length === 0)
        return;
      Z += J.length;
    }
    if (Z > 0)
      yield g(k.Union, $, W, X);
  }
  function* j4($, Y, W, X) {
    if (!(0, B0.IsUint8Array)(X))
      return yield g(k.Uint8Array, $, W, X);
    if (s($.maxByteLength) && !(X.length <= $.maxByteLength))
      yield g(k.Uint8ArrayMaxByteLength, $, W, X);
    if (s($.minByteLength) && !(X.length >= $.minByteLength))
      yield g(k.Uint8ArrayMinByteLength, $, W, X);
  }
  function* P4($, Y, W, X) {
  }
  function* O4($, Y, W, X) {
    if (!p1.TypeSystemPolicy.IsVoidLike(X))
      yield g(k.Void, $, W, X);
  }
  function* S4($, Y, W, X) {
    if (!i0.TypeRegistry.Get($[i0.Kind])($, X))
      yield g(k.Kind, $, W, X);
  }
  function* L0($, Y, W, X) {
    const Z = s($.$id) ? [...Y, $] : Y, Q = $;
    switch (Q[i0.Kind]) {
      case "Any":
        return yield* oZ(Q, Z, W, X);
      case "Array":
        return yield* cZ(Q, Z, W, X);
      case "AsyncIterator":
        return yield* lZ(Q, Z, W, X);
      case "BigInt":
        return yield* tZ(Q, Z, W, X);
      case "Boolean":
        return yield* sZ(Q, Z, W, X);
      case "Constructor":
        return yield* rZ(Q, Z, W, X);
      case "Date":
        return yield* aZ(Q, Z, W, X);
      case "Function":
        return yield* eZ(Q, Z, W, X);
      case "Integer":
        return yield* $4(Q, Z, W, X);
      case "Intersect":
        return yield* Y4(Q, Z, W, X);
      case "Iterator":
        return yield* W4(Q, Z, W, X);
      case "Literal":
        return yield* X4(Q, Z, W, X);
      case "Never":
        return yield* Z4(Q, Z, W, X);
      case "Not":
        return yield* Q4(Q, Z, W, X);
      case "Null":
        return yield* J4(Q, Z, W, X);
      case "Number":
        return yield* z4(Q, Z, W, X);
      case "Object":
        return yield* H4(Q, Z, W, X);
      case "Promise":
        return yield* q4(Q, Z, W, X);
      case "Record":
        return yield* M4(Q, Z, W, X);
      case "Ref":
        return yield* N4(Q, Z, W, X);
      case "String":
        return yield* U4(Q, Z, W, X);
      case "Symbol":
        return yield* F4(Q, Z, W, X);
      case "TemplateLiteral":
        return yield* B4(Q, Z, W, X);
      case "This":
        return yield* A4(Q, Z, W, X);
      case "Tuple":
        return yield* D4(Q, Z, W, X);
      case "Undefined":
        return yield* w4(Q, Z, W, X);
      case "Union":
        return yield* K4(Q, Z, W, X);
      case "Uint8Array":
        return yield* j4(Q, Z, W, X);
      case "Unknown":
        return yield* P4(Q, Z, W, X);
      case "Void":
        return yield* O4(Q, Z, W, X);
      default:
        if (!i0.TypeRegistry.Has(Q[i0.Kind]))
          throw new L8($);
        return yield* S4(Q, Z, W, X);
    }
  }
  var L4 = function(...$) {
    const Y = $.length === 3 ? L0($[0], $[1], "", $[2]) : L0($[0], [], "", $[1]);
    return new C8(Y);
  };
  Object.defineProperty(WY, "__esModule", { value: true });
  WY.Errors = WY.ValueErrorIterator = WY.ValueErrorsUnknownTypeError = WY.ValueErrorType = undefined;
  var B0 = V02(), p1 = P82(), YY = A1(), nZ = W$2(), i0 = f02(), k;
  (function($) {
    $[$.ArrayContains = 0] = "ArrayContains", $[$.ArrayMaxContains = 1] = "ArrayMaxContains", $[$.ArrayMaxItems = 2] = "ArrayMaxItems", $[$.ArrayMinContains = 3] = "ArrayMinContains", $[$.ArrayMinItems = 4] = "ArrayMinItems", $[$.ArrayUniqueItems = 5] = "ArrayUniqueItems", $[$.Array = 6] = "Array", $[$.AsyncIterator = 7] = "AsyncIterator", $[$.BigIntExclusiveMaximum = 8] = "BigIntExclusiveMaximum", $[$.BigIntExclusiveMinimum = 9] = "BigIntExclusiveMinimum", $[$.BigIntMaximum = 10] = "BigIntMaximum", $[$.BigIntMinimum = 11] = "BigIntMinimum", $[$.BigIntMultipleOf = 12] = "BigIntMultipleOf", $[$.BigInt = 13] = "BigInt", $[$.Boolean = 14] = "Boolean", $[$.DateExclusiveMaximumTimestamp = 15] = "DateExclusiveMaximumTimestamp", $[$.DateExclusiveMinimumTimestamp = 16] = "DateExclusiveMinimumTimestamp", $[$.DateMaximumTimestamp = 17] = "DateMaximumTimestamp", $[$.DateMinimumTimestamp = 18] = "DateMinimumTimestamp", $[$.DateMultipleOfTimestamp = 19] = "DateMultipleOfTimestamp", $[$.Date = 20] = "Date", $[$.Function = 21] = "Function", $[$.IntegerExclusiveMaximum = 22] = "IntegerExclusiveMaximum", $[$.IntegerExclusiveMinimum = 23] = "IntegerExclusiveMinimum", $[$.IntegerMaximum = 24] = "IntegerMaximum", $[$.IntegerMinimum = 25] = "IntegerMinimum", $[$.IntegerMultipleOf = 26] = "IntegerMultipleOf", $[$.Integer = 27] = "Integer", $[$.IntersectUnevaluatedProperties = 28] = "IntersectUnevaluatedProperties", $[$.Intersect = 29] = "Intersect", $[$.Iterator = 30] = "Iterator", $[$.Kind = 31] = "Kind", $[$.Literal = 32] = "Literal", $[$.Never = 33] = "Never", $[$.Not = 34] = "Not", $[$.Null = 35] = "Null", $[$.NumberExclusiveMaximum = 36] = "NumberExclusiveMaximum", $[$.NumberExclusiveMinimum = 37] = "NumberExclusiveMinimum", $[$.NumberMaximum = 38] = "NumberMaximum", $[$.NumberMinimum = 39] = "NumberMinimum", $[$.NumberMultipleOf = 40] = "NumberMultipleOf", $[$.Number = 41] = "Number", $[$.ObjectAdditionalProperties = 42] = "ObjectAdditionalProperties", $[$.ObjectMaxProperties = 43] = "ObjectMaxProperties", $[$.ObjectMinProperties = 44] = "ObjectMinProperties", $[$.ObjectRequiredProperty = 45] = "ObjectRequiredProperty", $[$.Object = 46] = "Object", $[$.Promise = 47] = "Promise", $[$.StringFormatUnknown = 48] = "StringFormatUnknown", $[$.StringFormat = 49] = "StringFormat", $[$.StringMaxLength = 50] = "StringMaxLength", $[$.StringMinLength = 51] = "StringMinLength", $[$.StringPattern = 52] = "StringPattern", $[$.String = 53] = "String", $[$.Symbol = 54] = "Symbol", $[$.TupleLength = 55] = "TupleLength", $[$.Tuple = 56] = "Tuple", $[$.Uint8ArrayMaxByteLength = 57] = "Uint8ArrayMaxByteLength", $[$.Uint8ArrayMinByteLength = 58] = "Uint8ArrayMinByteLength", $[$.Uint8Array = 59] = "Uint8Array", $[$.Undefined = 60] = "Undefined", $[$.Union = 61] = "Union", $[$.Void = 62] = "Void";
  })(k || (WY.ValueErrorType = k = {}));

  class L8 extends i0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  WY.ValueErrorsUnknownTypeError = L8;

  class C8 {
    constructor($) {
      this.iterator = $;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    First() {
      const $ = this.iterator.next();
      return $.done ? undefined : $.value;
    }
  }
  WY.ValueErrorIterator = C8;
  WY.Errors = L4;
});
var I$2 = J02((P1) => {
  var b4 = P1 && P1.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), G4 = P1 && P1.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        b4(Y, $, W);
  };
  Object.defineProperty(P1, "__esModule", { value: true });
  G4(Y$2(), P1);
});
var R$ = J02((QY) => {
  Object.defineProperty(QY, "__esModule", { value: true });
  QY.ValuePointer = QY.ValuePointerRootDeleteError = QY.ValuePointerRootSetError = undefined;

  class I8 extends Error {
    constructor($, Y, W) {
      super("Cannot set root value");
      this.value = $, this.path = Y, this.update = W;
    }
  }
  QY.ValuePointerRootSetError = I8;

  class R8 extends Error {
    constructor($, Y) {
      super("Cannot delete root value");
      this.value = $, this.path = Y;
    }
  }
  QY.ValuePointerRootDeleteError = R8;
  var ZY;
  (function($) {
    function Y(q) {
      return q.indexOf("~") === -1 ? q : q.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    function* W(q) {
      if (q === "")
        return;
      let [F, D] = [0, 0];
      for (let K = 0;K < q.length; K++)
        if (q.charAt(K) === "/")
          if (K === 0)
            F = K + 1;
          else
            D = K, yield Y(q.slice(F, D)), F = K + 1;
        else
          D = K;
      yield Y(q.slice(F));
    }
    $.Format = W;
    function X(q, F, D) {
      if (F === "")
        throw new I8(q, F, D);
      let [K, A, I] = [null, q, ""];
      for (let j of W(F)) {
        if (A[j] === undefined)
          A[j] = {};
        K = A, A = A[j], I = j;
      }
      K[I] = D;
    }
    $.Set = X;
    function Z(q, F) {
      if (F === "")
        throw new R8(q, F);
      let [D, K, A] = [null, q, ""];
      for (let I of W(F)) {
        if (K[I] === undefined || K[I] === null)
          return;
        D = K, K = K[I], A = I;
      }
      if (Array.isArray(D)) {
        const I = parseInt(A);
        D.splice(I, 1);
      } else
        delete D[A];
    }
    $.Delete = Z;
    function Q(q, F) {
      if (F === "")
        return true;
      let [D, K, A] = [null, q, ""];
      for (let I of W(F)) {
        if (K[I] === undefined)
          return false;
        D = K, K = K[I], A = I;
      }
      return Object.getOwnPropertyNames(D).includes(A);
    }
    $.Has = Q;
    function J(q, F) {
      if (F === "")
        return q;
      let D = q;
      for (let K of W(F)) {
        if (D[K] === undefined)
          return;
        D = D[K];
      }
      return D;
    }
    $.Get = J;
  })(ZY || (QY.ValuePointer = ZY = {}));
});
var i12 = J02((zY) => {
  var V4 = function($) {
    return [...Object.getOwnPropertyNames($), ...Object.getOwnPropertySymbols($)].reduce((W, X) => ({ ...W, [X]: b8($[X]) }), {});
  }, x4 = function($) {
    return $.map((Y) => b8(Y));
  }, k4 = function($) {
    return $.slice();
  }, g4 = function($) {
    return new Date($.toISOString());
  }, f4 = function($) {
    return $;
  }, b8 = function($) {
    if ((0, X$.IsArray)($))
      return x4($);
    if ((0, X$.IsDate)($))
      return g4($);
    if ((0, X$.IsPlainObject)($))
      return V4($);
    if ((0, X$.IsTypedArray)($))
      return k4($);
    if ((0, X$.IsValueType)($))
      return f4($);
    throw new Error("ValueClone: Unable to clone value");
  };
  Object.defineProperty(zY, "__esModule", { value: true });
  zY.Clone = undefined;
  var X$ = V02();
  zY.Clone = b8;
});
var V82 = J02((NY) => {
  var Z$ = function($, Y) {
    return { type: "update", path: $, value: Y };
  }, qY = function($, Y) {
    return { type: "insert", path: $, value: Y };
  }, MY = function($) {
    return { type: "delete", path: $ };
  };
  function* T4($, Y, W) {
    if (!(0, G0.IsPlainObject)(W))
      return yield Z$($, W);
    const X = [...Object.keys(Y), ...Object.getOwnPropertySymbols(Y)], Z = [...Object.keys(W), ...Object.getOwnPropertySymbols(W)];
    for (let Q of X) {
      if ((0, G0.IsSymbol)(Q))
        throw new m1(Q);
      if ((0, G0.IsUndefined)(W[Q]) && Z.includes(Q))
        yield Z$(`${$}/${String(Q)}`, undefined);
    }
    for (let Q of Z) {
      if ((0, G0.IsUndefined)(Y[Q]) || (0, G0.IsUndefined)(W[Q]))
        continue;
      if ((0, G0.IsSymbol)(Q))
        throw new m1(Q);
      yield* b$2(`${$}/${String(Q)}`, Y[Q], W[Q]);
    }
    for (let Q of Z) {
      if ((0, G0.IsSymbol)(Q))
        throw new m1(Q);
      if ((0, G0.IsUndefined)(Y[Q]))
        yield qY(`${$}/${String(Q)}`, W[Q]);
    }
    for (let Q of X.reverse()) {
      if ((0, G0.IsSymbol)(Q))
        throw new m1(Q);
      if ((0, G0.IsUndefined)(W[Q]) && !Z.includes(Q))
        yield MY(`${$}/${String(Q)}`);
    }
  }
  function* d4($, Y, W) {
    if (!(0, G0.IsArray)(W))
      return yield Z$($, W);
    for (let X = 0;X < Math.min(Y.length, W.length); X++)
      yield* b$2(`${$}/${X}`, Y[X], W[X]);
    for (let X = 0;X < W.length; X++) {
      if (X < Y.length)
        continue;
      yield qY(`${$}/${X}`, W[X]);
    }
    for (let X = Y.length - 1;X >= 0; X--) {
      if (X < W.length)
        continue;
      yield MY(`${$}/${X}`);
    }
  }
  function* y4($, Y, W) {
    if (!(0, G0.IsTypedArray)(W) || Y.length !== W.length || Object.getPrototypeOf(Y).constructor.name !== Object.getPrototypeOf(W).constructor.name)
      return yield Z$($, W);
    for (let X = 0;X < Math.min(Y.length, W.length); X++)
      yield* b$2(`${$}/${X}`, Y[X], W[X]);
  }
  function* v4($, Y, W) {
    if (Y === W)
      return;
    yield Z$($, W);
  }
  function* b$2($, Y, W) {
    if ((0, G0.IsPlainObject)(Y))
      return yield* T4($, Y, W);
    if ((0, G0.IsArray)(Y))
      return yield* d4($, Y, W);
    if ((0, G0.IsTypedArray)(Y))
      return yield* y4($, Y, W);
    if ((0, G0.IsValueType)(Y))
      return yield* v4($, Y, W);
    throw new E8(Y);
  }
  var p4 = function($, Y) {
    return [...b$2("", $, Y)];
  }, i4 = function($) {
    return $.length > 0 && $[0].path === "" && $[0].type === "update";
  }, m4 = function($) {
    return $.length === 0;
  }, u4 = function($, Y) {
    if (i4(Y))
      return (0, _8.Clone)(Y[0].value);
    if (m4(Y))
      return (0, _8.Clone)($);
    const W = (0, _8.Clone)($);
    for (let X of Y)
      switch (X.type) {
        case "insert": {
          G8.ValuePointer.Set(W, X.path, X.value);
          break;
        }
        case "update": {
          G8.ValuePointer.Set(W, X.path, X.value);
          break;
        }
        case "delete": {
          G8.ValuePointer.Delete(W, X.path);
          break;
        }
      }
    return W;
  };
  Object.defineProperty(NY, "__esModule", { value: true });
  NY.Patch = NY.Diff = NY.ValueDeltaUnableToDiffUnknownValue = NY.ValueDeltaObjectWithSymbolKeyError = NY.Edit = NY.Delete = NY.Update = NY.Insert = undefined;
  var G0 = V02(), m0 = f02(), G8 = R$(), _8 = i12();
  NY.Insert = m0.Type.Object({ type: m0.Type.Literal("insert"), path: m0.Type.String(), value: m0.Type.Unknown() });
  NY.Update = m0.Type.Object({ type: m0.Type.Literal("update"), path: m0.Type.String(), value: m0.Type.Unknown() });
  NY.Delete = m0.Type.Object({ type: m0.Type.Literal("delete"), path: m0.Type.String() });
  NY.Edit = m0.Type.Union([NY.Insert, NY.Update, NY.Delete]);

  class m1 extends Error {
    constructor($) {
      super("Cannot diff objects with symbol keys");
      this.key = $;
    }
  }
  NY.ValueDeltaObjectWithSymbolKeyError = m1;

  class E8 extends Error {
    constructor($) {
      super("Unable to create diff edits for unknown value");
      this.value = $;
    }
  }
  NY.ValueDeltaUnableToDiffUnknownValue = E8;
  NY.Diff = p4;
  NY.Patch = u4;
});
var jY2 = J02((wY) => {
  var l4 = function($, Y, W, X) {
    if (!(0, d0.IsPlainObject)(W))
      G$.ValuePointer.Set($, Y, (0, x8.Clone)(X));
    else {
      const Z = Object.keys(W), Q = Object.keys(X);
      for (let J of Z)
        if (!Q.includes(J))
          delete W[J];
      for (let J of Q)
        if (!Z.includes(J))
          W[J] = null;
      for (let J of Q)
        f8($, `${Y}/${J}`, W[J], X[J]);
    }
  }, t4 = function($, Y, W, X) {
    if (!(0, d0.IsArray)(W))
      G$.ValuePointer.Set($, Y, (0, x8.Clone)(X));
    else {
      for (let Z = 0;Z < X.length; Z++)
        f8($, `${Y}/${Z}`, W[Z], X[Z]);
      W.splice(X.length);
    }
  }, s4 = function($, Y, W, X) {
    if ((0, d0.IsTypedArray)(W) && W.length === X.length)
      for (let Z = 0;Z < W.length; Z++)
        W[Z] = X[Z];
    else
      G$.ValuePointer.Set($, Y, (0, x8.Clone)(X));
  }, r4 = function($, Y, W, X) {
    if (W === X)
      return;
    G$.ValuePointer.Set($, Y, X);
  }, f8 = function($, Y, W, X) {
    if ((0, d0.IsArray)(X))
      return t4($, Y, W, X);
    if ((0, d0.IsTypedArray)(X))
      return s4($, Y, W, X);
    if ((0, d0.IsPlainObject)(X))
      return l4($, Y, W, X);
    if ((0, d0.IsValueType)(X))
      return r4($, Y, W, X);
  }, DY = function($) {
    return (0, d0.IsTypedArray)($) || (0, d0.IsValueType)($);
  }, a4 = function($, Y) {
    return (0, d0.IsPlainObject)($) && (0, d0.IsArray)(Y) || (0, d0.IsArray)($) && (0, d0.IsPlainObject)(Y);
  }, e4 = function($, Y) {
    if (DY($) || DY(Y))
      throw new g8;
    if (a4($, Y))
      throw new k8;
    f8($, "", $, Y);
  };
  Object.defineProperty(wY, "__esModule", { value: true });
  wY.Mutate = wY.ValueMutateInvalidRootMutationError = wY.ValueMutateTypeMismatchError = undefined;
  var d0 = V02(), G$ = R$(), x8 = i12();

  class k8 extends Error {
    constructor() {
      super("Cannot assign due type mismatch of assignable values");
    }
  }
  wY.ValueMutateTypeMismatchError = k8;

  class g8 extends Error {
    constructor() {
      super("Only object and array types can be mutated at the root level");
    }
  }
  wY.ValueMutateInvalidRootMutationError = g8;
  wY.Mutate = e4;
});
var SY2 = J02((PY) => {
  var WQ = function($, Y) {
    if (!(0, J1.IsPlainObject)(Y))
      return false;
    const W = [...Object.keys($), ...Object.getOwnPropertySymbols($)], X = [...Object.keys(Y), ...Object.getOwnPropertySymbols(Y)];
    if (W.length !== X.length)
      return false;
    return W.every((Z) => _$($[Z], Y[Z]));
  }, XQ = function($, Y) {
    return (0, J1.IsDate)(Y) && $.getTime() === Y.getTime();
  }, ZQ = function($, Y) {
    if (!(0, J1.IsArray)(Y) || $.length !== Y.length)
      return false;
    return $.every((W, X) => _$(W, Y[X]));
  }, QQ = function($, Y) {
    if (!(0, J1.IsTypedArray)(Y) || $.length !== Y.length || Object.getPrototypeOf($).constructor.name !== Object.getPrototypeOf(Y).constructor.name)
      return false;
    return $.every((W, X) => _$(W, Y[X]));
  }, JQ = function($, Y) {
    return $ === Y;
  }, _$ = function($, Y) {
    if ((0, J1.IsPlainObject)($))
      return WQ($, Y);
    if ((0, J1.IsDate)($))
      return XQ($, Y);
    if ((0, J1.IsTypedArray)($))
      return QQ($, Y);
    if ((0, J1.IsArray)($))
      return ZQ($, Y);
    if ((0, J1.IsValueType)($))
      return JQ($, Y);
    throw new Error("ValueEquals: Unable to compare value");
  };
  Object.defineProperty(PY, "__esModule", { value: true });
  PY.Equal = undefined;
  var J1 = V02();
  PY.Equal = _$;
});
var E$2 = J02((z1) => {
  var zQ = z1 && z1.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), HQ = z1 && z1.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        zQ(Y, $, W);
  };
  Object.defineProperty(z1, "__esModule", { value: true });
  z1.ValueErrorType = undefined;
  var qQ = Y$2();
  Object.defineProperty(z1, "ValueErrorType", { enumerable: true, get: function() {
    return qQ.ValueErrorType;
  } });
  HQ(P82(), z1);
});
var J$2 = J02((CY) => {
  var NQ = function($) {
    return $[C0.Kind] === "Any" || $[C0.Kind] === "Unknown";
  }, r = function($) {
    return $ !== undefined;
  }, UQ = function($, Y, W) {
    return true;
  }, FQ = function($, Y, W) {
    if (!(0, A0.IsArray)(W))
      return false;
    if (r($.minItems) && !(W.length >= $.minItems))
      return false;
    if (r($.maxItems) && !(W.length <= $.maxItems))
      return false;
    if (!W.every((Q) => I0($.items, Y, Q)))
      return false;
    if ($.uniqueItems === true && !function() {
      const Q = new Set;
      for (let J of W) {
        const q = (0, MQ.Hash)(J);
        if (Q.has(q))
          return false;
        else
          Q.add(q);
      }
      return true;
    }())
      return false;
    if (!(r($.contains) || (0, A0.IsNumber)($.minContains) || (0, A0.IsNumber)($.maxContains)))
      return true;
    const X = r($.contains) ? $.contains : C0.Type.Never(), Z = W.reduce((Q, J) => I0(X, Y, J) ? Q + 1 : Q, 0);
    if (Z === 0)
      return false;
    if ((0, A0.IsNumber)($.minContains) && Z < $.minContains)
      return false;
    if ((0, A0.IsNumber)($.maxContains) && Z > $.maxContains)
      return false;
    return true;
  }, BQ = function($, Y, W) {
    return (0, A0.IsAsyncIterator)(W);
  }, AQ = function($, Y, W) {
    if (!(0, A0.IsBigInt)(W))
      return false;
    if (r($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (r($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (r($.maximum) && !(W <= $.maximum))
      return false;
    if (r($.minimum) && !(W >= $.minimum))
      return false;
    if (r($.multipleOf) && W % $.multipleOf !== BigInt(0))
      return false;
    return true;
  }, DQ = function($, Y, W) {
    return (0, A0.IsBoolean)(W);
  }, wQ = function($, Y, W) {
    return I0($.returns, Y, W.prototype);
  }, KQ = function($, Y, W) {
    if (!(0, A0.IsDate)(W))
      return false;
    if (r($.exclusiveMaximumTimestamp) && !(W.getTime() < $.exclusiveMaximumTimestamp))
      return false;
    if (r($.exclusiveMinimumTimestamp) && !(W.getTime() > $.exclusiveMinimumTimestamp))
      return false;
    if (r($.maximumTimestamp) && !(W.getTime() <= $.maximumTimestamp))
      return false;
    if (r($.minimumTimestamp) && !(W.getTime() >= $.minimumTimestamp))
      return false;
    if (r($.multipleOfTimestamp) && W.getTime() % $.multipleOfTimestamp !== 0)
      return false;
    return true;
  }, jQ = function($, Y, W) {
    return (0, A0.IsFunction)(W);
  }, PQ = function($, Y, W) {
    if (!(0, A0.IsInteger)(W))
      return false;
    if (r($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (r($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (r($.maximum) && !(W <= $.maximum))
      return false;
    if (r($.minimum) && !(W >= $.minimum))
      return false;
    if (r($.multipleOf) && W % $.multipleOf !== 0)
      return false;
    return true;
  }, OQ = function($, Y, W) {
    const X = $.allOf.every((Z) => I0(Z, Y, W));
    if ($.unevaluatedProperties === false) {
      const Z = new RegExp(C0.KeyResolver.ResolvePattern($)), Q = Object.getOwnPropertyNames(W).every((J) => Z.test(J));
      return X && Q;
    } else if (C0.TypeGuard.TSchema($.unevaluatedProperties)) {
      const Z = new RegExp(C0.KeyResolver.ResolvePattern($)), Q = Object.getOwnPropertyNames(W).every((J) => Z.test(J) || I0($.unevaluatedProperties, Y, W[J]));
      return X && Q;
    } else
      return X;
  }, SQ = function($, Y, W) {
    return (0, A0.IsIterator)(W);
  }, LQ = function($, Y, W) {
    return W === $.const;
  }, CQ = function($, Y, W) {
    return false;
  }, IQ = function($, Y, W) {
    return !I0($.not, Y, W);
  }, RQ = function($, Y, W) {
    return (0, A0.IsNull)(W);
  }, bQ = function($, Y, W) {
    if (!Q$.TypeSystemPolicy.IsNumberLike(W))
      return false;
    if (r($.exclusiveMaximum) && !(W < $.exclusiveMaximum))
      return false;
    if (r($.exclusiveMinimum) && !(W > $.exclusiveMinimum))
      return false;
    if (r($.minimum) && !(W >= $.minimum))
      return false;
    if (r($.maximum) && !(W <= $.maximum))
      return false;
    if (r($.multipleOf) && W % $.multipleOf !== 0)
      return false;
    return true;
  }, GQ = function($, Y, W) {
    if (!Q$.TypeSystemPolicy.IsObjectLike(W))
      return false;
    if (r($.minProperties) && !(Object.getOwnPropertyNames(W).length >= $.minProperties))
      return false;
    if (r($.maxProperties) && !(Object.getOwnPropertyNames(W).length <= $.maxProperties))
      return false;
    const X = Object.getOwnPropertyNames($.properties);
    for (let Z of X) {
      const Q = $.properties[Z];
      if ($.required && $.required.includes(Z)) {
        if (!I0(Q, Y, W[Z]))
          return false;
        if ((C0.ExtendsUndefined.Check(Q) || NQ(Q)) && !(Z in W))
          return false;
      } else if (Q$.TypeSystemPolicy.IsExactOptionalProperty(W, Z) && !I0(Q, Y, W[Z]))
        return false;
    }
    if ($.additionalProperties === false) {
      const Z = Object.getOwnPropertyNames(W);
      if ($.required && $.required.length === X.length && Z.length === X.length)
        return true;
      else
        return Z.every((Q) => X.includes(Q));
    } else if (typeof $.additionalProperties === "object")
      return Object.getOwnPropertyNames(W).every((Q) => X.includes(Q) || I0($.additionalProperties, Y, W[Q]));
    else
      return true;
  }, _Q = function($, Y, W) {
    return (0, A0.IsPromise)(W);
  }, EQ = function($, Y, W) {
    if (!Q$.TypeSystemPolicy.IsRecordLike(W))
      return false;
    if (r($.minProperties) && !(Object.getOwnPropertyNames(W).length >= $.minProperties))
      return false;
    if (r($.maxProperties) && !(Object.getOwnPropertyNames(W).length <= $.maxProperties))
      return false;
    const [X, Z] = Object.entries($.patternProperties)[0], Q = new RegExp(X), J = Object.entries(W).every(([D, K]) => {
      return Q.test(D) ? I0(Z, Y, K) : true;
    }), q = typeof $.additionalProperties === "object" ? Object.entries(W).every(([D, K]) => {
      return !Q.test(D) ? I0($.additionalProperties, Y, K) : true;
    }) : true, F = $.additionalProperties === false ? Object.getOwnPropertyNames(W).every((D) => {
      return Q.test(D);
    }) : true;
    return J && q && F;
  }, VQ = function($, Y, W) {
    return I0((0, LY.Deref)($, Y), Y, W);
  }, xQ = function($, Y, W) {
    if (!(0, A0.IsString)(W))
      return false;
    if (r($.minLength)) {
      if (!(W.length >= $.minLength))
        return false;
    }
    if (r($.maxLength)) {
      if (!(W.length <= $.maxLength))
        return false;
    }
    if (r($.pattern)) {
      if (!new RegExp($.pattern).test(W))
        return false;
    }
    if (r($.format)) {
      if (!C0.FormatRegistry.Has($.format))
        return false;
      return C0.FormatRegistry.Get($.format)(W);
    }
    return true;
  }, kQ = function($, Y, W) {
    return (0, A0.IsSymbol)(W);
  }, gQ = function($, Y, W) {
    return (0, A0.IsString)(W) && new RegExp($.pattern).test(W);
  }, fQ = function($, Y, W) {
    return I0((0, LY.Deref)($, Y), Y, W);
  }, TQ = function($, Y, W) {
    if (!(0, A0.IsArray)(W))
      return false;
    if ($.items === undefined && W.length !== 0)
      return false;
    if (W.length !== $.maxItems)
      return false;
    if (!$.items)
      return true;
    for (let X = 0;X < $.items.length; X++)
      if (!I0($.items[X], Y, W[X]))
        return false;
    return true;
  }, dQ = function($, Y, W) {
    return (0, A0.IsUndefined)(W);
  }, yQ = function($, Y, W) {
    return $.anyOf.some((X) => I0(X, Y, W));
  }, vQ = function($, Y, W) {
    if (!(0, A0.IsUint8Array)(W))
      return false;
    if (r($.maxByteLength) && !(W.length <= $.maxByteLength))
      return false;
    if (r($.minByteLength) && !(W.length >= $.minByteLength))
      return false;
    return true;
  }, pQ = function($, Y, W) {
    return true;
  }, iQ = function($, Y, W) {
    return Q$.TypeSystemPolicy.IsVoidLike(W);
  }, mQ = function($, Y, W) {
    if (!C0.TypeRegistry.Has($[C0.Kind]))
      return false;
    return C0.TypeRegistry.Get($[C0.Kind])($, W);
  }, I0 = function($, Y, W) {
    const X = r($.$id) ? [...Y, $] : Y, Z = $;
    switch (Z[C0.Kind]) {
      case "Any":
        return UQ(Z, X, W);
      case "Array":
        return FQ(Z, X, W);
      case "AsyncIterator":
        return BQ(Z, X, W);
      case "BigInt":
        return AQ(Z, X, W);
      case "Boolean":
        return DQ(Z, X, W);
      case "Constructor":
        return wQ(Z, X, W);
      case "Date":
        return KQ(Z, X, W);
      case "Function":
        return jQ(Z, X, W);
      case "Integer":
        return PQ(Z, X, W);
      case "Intersect":
        return OQ(Z, X, W);
      case "Iterator":
        return SQ(Z, X, W);
      case "Literal":
        return LQ(Z, X, W);
      case "Never":
        return CQ(Z, X, W);
      case "Not":
        return IQ(Z, X, W);
      case "Null":
        return RQ(Z, X, W);
      case "Number":
        return bQ(Z, X, W);
      case "Object":
        return GQ(Z, X, W);
      case "Promise":
        return _Q(Z, X, W);
      case "Record":
        return EQ(Z, X, W);
      case "Ref":
        return VQ(Z, X, W);
      case "String":
        return xQ(Z, X, W);
      case "Symbol":
        return kQ(Z, X, W);
      case "TemplateLiteral":
        return gQ(Z, X, W);
      case "This":
        return fQ(Z, X, W);
      case "Tuple":
        return TQ(Z, X, W);
      case "Undefined":
        return dQ(Z, X, W);
      case "Union":
        return yQ(Z, X, W);
      case "Uint8Array":
        return vQ(Z, X, W);
      case "Unknown":
        return pQ(Z, X, W);
      case "Void":
        return iQ(Z, X, W);
      default:
        if (!C0.TypeRegistry.Has(Z[C0.Kind]))
          throw new T8(Z);
        return mQ(Z, X, W);
    }
  }, uQ = function(...$) {
    return $.length === 3 ? I0($[0], $[1], $[2]) : I0($[0], [], $[1]);
  };
  Object.defineProperty(CY, "__esModule", { value: true });
  CY.Check = CY.ValueCheckUnknownTypeError = undefined;
  var A0 = V02(), Q$ = E$2(), LY = A1(), MQ = W$2(), C0 = f02();

  class T8 extends C0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  CY.ValueCheckUnknownTypeError = T8;
  CY.Check = uQ;
});
var u82 = J02((_Y) => {
  var oQ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return {};
  }, cQ = function($, Y) {
    if ($.uniqueItems === true && !(0, e.HasPropertyKey)($, "default"))
      throw new Error("ValueCreate.Array: Array with the uniqueItems constraint requires a default value");
    else if (("contains" in $) && !(0, e.HasPropertyKey)($, "default"))
      throw new Error("ValueCreate.Array: Array with the contains constraint requires a default value");
    else if ("default" in $)
      return $.default;
    else if ($.minItems !== undefined)
      return Array.from({ length: $.minItems }).map((W) => {
        return y0($.items, Y);
      });
    else
      return [];
  }, lQ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return async function* () {
      }();
  }, tQ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return BigInt(0);
  }, sQ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return false;
  }, rQ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = y0($.returns, Y);
      if (typeof W === "object" && !Array.isArray(W))
        return class {
          constructor() {
            for (let [X, Z] of Object.entries(W)) {
              const Q = this;
              Q[X] = Z;
            }
          }
        };
      else
        return class {
        };
    }
  }, aQ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimumTimestamp !== undefined)
      return new Date($.minimumTimestamp);
    else
      return new Date(0);
  }, eQ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return () => y0($.returns, Y);
  }, $J = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, YJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = $.allOf.reduce((X, Z) => {
        const Q = y0(Z, Y);
        return typeof Q === "object" ? { ...X, ...Q } : Q;
      }, {});
      if (!(0, nQ.Check)($, Y, W))
        throw new p8($);
      return W;
    }
  }, WJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return function* () {
      }();
  }, XJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return $.const;
  }, ZJ = function($, Y) {
    throw new y8($);
  }, QJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      throw new v8($);
  }, JJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return null;
  }, zJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minimum !== undefined)
      return $.minimum;
    else
      return 0;
  }, HJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else {
      const W = new Set($.required);
      return $.default || Object.entries($.properties).reduce((X, [Z, Q]) => {
        return W.has(Z) ? { ...X, [Z]: y0(Q, Y) } : { ...X };
      }, {});
    }
  }, qJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return Promise.resolve(y0($.item, Y));
  }, MJ = function($, Y) {
    const [W, X] = Object.entries($.patternProperties)[0];
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else if (!(W === x0.PatternStringExact || W === x0.PatternNumberExact))
      return W.slice(1, W.length - 1).split("|").reduce((Q, J) => {
        return { ...Q, [J]: y0(X, Y) };
      }, {});
    else
      return {};
  }, NJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return y0((0, bY.Deref)($, Y), Y);
  }, UJ = function($, Y) {
    if ($.pattern !== undefined)
      if (!(0, e.HasPropertyKey)($, "default"))
        throw new Error("ValueCreate.String: String types with patterns must specify a default value");
      else
        return $.default;
    else if ($.format !== undefined)
      if (!(0, e.HasPropertyKey)($, "default"))
        throw new Error("ValueCreate.String: String types with formats must specify a default value");
      else
        return $.default;
    else if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minLength !== undefined)
      return Array.from({ length: $.minLength }).map(() => ".").join("");
    else
      return "";
  }, FJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else if ("value" in $)
      return Symbol.for($.value);
    else
      return Symbol();
  }, BJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    const W = x0.TemplateLiteralParser.ParseExact($.pattern);
    if (!x0.TemplateLiteralFinite.Check(W))
      throw new i8($);
    return x0.TemplateLiteralGenerator.Generate(W).next().value;
  }, AJ = function($, Y) {
    if (GY++ > RY)
      throw new m8($, RY);
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return y0((0, bY.Deref)($, Y), Y);
  }, DJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    if ($.items === undefined)
      return [];
    else
      return Array.from({ length: $.minItems }).map((W, X) => y0($.items[X], Y));
  }, wJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return;
  }, KJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.anyOf.length === 0)
      throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
    else
      return y0($.anyOf[0], Y);
  }, jJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else if ($.minByteLength !== undefined)
      return new Uint8Array($.minByteLength);
    else
      return new Uint8Array(0);
  }, PJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return {};
  }, OJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      return;
  }, SJ = function($, Y) {
    if ((0, e.HasPropertyKey)($, "default"))
      return $.default;
    else
      throw new Error("User defined types must specify a default value");
  }, y0 = function($, Y) {
    const W = (0, e.IsString)($.$id) ? [...Y, $] : Y, X = $;
    switch (X[x0.Kind]) {
      case "Any":
        return oQ(X, W);
      case "Array":
        return cQ(X, W);
      case "AsyncIterator":
        return lQ(X, W);
      case "BigInt":
        return tQ(X, W);
      case "Boolean":
        return sQ(X, W);
      case "Constructor":
        return rQ(X, W);
      case "Date":
        return aQ(X, W);
      case "Function":
        return eQ(X, W);
      case "Integer":
        return $J(X, W);
      case "Intersect":
        return YJ(X, W);
      case "Iterator":
        return WJ(X, W);
      case "Literal":
        return XJ(X, W);
      case "Never":
        return ZJ(X, W);
      case "Not":
        return QJ(X, W);
      case "Null":
        return JJ(X, W);
      case "Number":
        return zJ(X, W);
      case "Object":
        return HJ(X, W);
      case "Promise":
        return qJ(X, W);
      case "Record":
        return MJ(X, W);
      case "Ref":
        return NJ(X, W);
      case "String":
        return UJ(X, W);
      case "Symbol":
        return FJ(X, W);
      case "TemplateLiteral":
        return BJ(X, W);
      case "This":
        return AJ(X, W);
      case "Tuple":
        return DJ(X, W);
      case "Undefined":
        return wJ(X, W);
      case "Union":
        return KJ(X, W);
      case "Uint8Array":
        return jJ(X, W);
      case "Unknown":
        return PJ(X, W);
      case "Void":
        return OJ(X, W);
      default:
        if (!x0.TypeRegistry.Has(X[x0.Kind]))
          throw new d8(X);
        return SJ(X, W);
    }
  }, LJ = function(...$) {
    return GY = 0, $.length === 2 ? y0($[0], $[1]) : y0($[0], []);
  };
  Object.defineProperty(_Y, "__esModule", { value: true });
  _Y.Create = _Y.ValueCreateRecursiveInstantiationError = _Y.ValueCreateTempateLiteralTypeError = _Y.ValueCreateIntersectTypeError = _Y.ValueCreateNotTypeError = _Y.ValueCreateNeverTypeError = _Y.ValueCreateUnknownTypeError = undefined;
  var e = V02(), nQ = J$2(), bY = A1(), x0 = f02();

  class d8 extends x0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  _Y.ValueCreateUnknownTypeError = d8;

  class y8 extends x0.TypeBoxError {
    constructor($) {
      super("Never types cannot be created");
      this.schema = $;
    }
  }
  _Y.ValueCreateNeverTypeError = y8;

  class v8 extends x0.TypeBoxError {
    constructor($) {
      super("Not types must have a default value");
      this.schema = $;
    }
  }
  _Y.ValueCreateNotTypeError = v8;

  class p8 extends x0.TypeBoxError {
    constructor($) {
      super("Intersect produced invalid value. Consider using a default value.");
      this.schema = $;
    }
  }
  _Y.ValueCreateIntersectTypeError = p8;

  class i8 extends x0.TypeBoxError {
    constructor($) {
      super("Can only create template literal values from patterns that produce finite sequences. Consider using a default value.");
      this.schema = $;
    }
  }
  _Y.ValueCreateTempateLiteralTypeError = i8;

  class m8 extends x0.TypeBoxError {
    constructor($, Y) {
      super("Value cannot be created as recursive type may produce value of infinite size. Consider using a default.");
      this.schema = $, this.recursiveMaxDepth = Y;
    }
  }
  _Y.ValueCreateRecursiveInstantiationError = m8;
  var RY = 512, GY = 0;
  _Y.Create = LJ;
});
var dY2 = J02((fY) => {
  var kY = function($, Y, W) {
    return (0, u0.Check)($, Y, W) ? (0, u1.Clone)(W) : (0, q1.Create)($, Y);
  }, n8 = function($, Y, W) {
    return (0, u0.Check)($, Y, W) ? W : (0, q1.Create)($, Y);
  }, EJ = function($, Y, W) {
    if ((0, u0.Check)($, Y, W))
      return (0, u1.Clone)(W);
    const X = (0, D12.IsArray)(W) ? (0, u1.Clone)(W) : (0, q1.Create)($, Y), Z = (0, D12.IsNumber)($.minItems) && X.length < $.minItems ? [...X, ...Array.from({ length: $.minItems - X.length }, () => null)] : X, J = ((0, D12.IsNumber)($.maxItems) && Z.length > $.maxItems ? Z.slice(0, $.maxItems) : Z).map((F) => $1($.items, Y, F));
    if ($.uniqueItems !== true)
      return J;
    const q = [...new Set(J)];
    if (!(0, u0.Check)($, Y, q))
      throw new o8($, q);
    return q;
  }, VJ = function($, Y, W) {
    if ((0, u0.Check)($, Y, W))
      return (0, q1.Create)($, Y);
    const X = new Set($.returns.required || []), Z = function() {
    };
    for (let [Q, J] of Object.entries($.returns.properties)) {
      if (!X.has(Q) && W.prototype[Q] === undefined)
        continue;
      Z.prototype[Q] = $1(J, Y, W.prototype[Q]);
    }
    return Z;
  }, xJ = function($, Y, W) {
    const X = (0, q1.Create)($, Y), Z = (0, D12.IsPlainObject)(X) && (0, D12.IsPlainObject)(W) ? { ...X, ...W } : W;
    return (0, u0.Check)($, Y, Z) ? Z : (0, q1.Create)($, Y);
  }, kJ = function($, Y, W) {
    throw new c8($);
  }, gJ = function($, Y, W) {
    if ((0, u0.Check)($, Y, W))
      return W;
    if (W === null || typeof W !== "object")
      return (0, q1.Create)($, Y);
    const X = new Set($.required || []), Z = {};
    for (let [Q, J] of Object.entries($.properties)) {
      if (!X.has(Q) && W[Q] === undefined)
        continue;
      Z[Q] = $1(J, Y, W[Q]);
    }
    if (typeof $.additionalProperties === "object") {
      const Q = Object.getOwnPropertyNames($.properties);
      for (let J of Object.getOwnPropertyNames(W)) {
        if (Q.includes(J))
          continue;
        Z[J] = $1($.additionalProperties, Y, W[J]);
      }
    }
    return Z;
  }, fJ = function($, Y, W) {
    if ((0, u0.Check)($, Y, W))
      return (0, u1.Clone)(W);
    if (W === null || typeof W !== "object" || Array.isArray(W) || W instanceof Date)
      return (0, q1.Create)($, Y);
    const X = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X], Q = {};
    for (let [J, q] of Object.entries(W))
      Q[J] = $1(Z, Y, q);
    return Q;
  }, TJ = function($, Y, W) {
    return $1((0, VY.Deref)($, Y), Y, W);
  }, dJ = function($, Y, W) {
    return $1((0, VY.Deref)($, Y), Y, W);
  }, yJ = function($, Y, W) {
    if ((0, u0.Check)($, Y, W))
      return (0, u1.Clone)(W);
    if (!(0, D12.IsArray)(W))
      return (0, q1.Create)($, Y);
    if ($.items === undefined)
      return [];
    return $.items.map((X, Z) => $1(X, Y, W[Z]));
  }, vJ = function($, Y, W) {
    return (0, u0.Check)($, Y, W) ? (0, u1.Clone)(W) : h8.Create($, Y, W);
  }, $1 = function($, Y, W) {
    const X = (0, D12.IsString)($.$id) ? [...Y, $] : Y, Z = $;
    switch ($[H1.Kind]) {
      case "Array":
        return EJ(Z, X, W);
      case "Constructor":
        return VJ(Z, X, W);
      case "Intersect":
        return xJ(Z, X, W);
      case "Never":
        return kJ(Z, X, W);
      case "Object":
        return gJ(Z, X, W);
      case "Record":
        return fJ(Z, X, W);
      case "Ref":
        return TJ(Z, X, W);
      case "This":
        return dJ(Z, X, W);
      case "Tuple":
        return yJ(Z, X, W);
      case "Union":
        return vJ(Z, X, W);
      case "Date":
      case "Symbol":
      case "Uint8Array":
        return kY($, Y, W);
      case "Any":
      case "AsyncIterator":
      case "BigInt":
      case "Boolean":
      case "Function":
      case "Integer":
      case "Iterator":
      case "Literal":
      case "Not":
      case "Null":
      case "Number":
      case "Promise":
      case "String":
      case "TemplateLiteral":
      case "Undefined":
      case "Unknown":
      case "Void":
        return n8(Z, X, W);
      default:
        if (!H1.TypeRegistry.Has(Z[H1.Kind]))
          throw new l8(Z);
        return n8(Z, X, W);
    }
  }, gY = function(...$) {
    return $.length === 3 ? $1($[0], $[1], $[2]) : $1($[0], [], $[1]);
  };
  Object.defineProperty(fY, "__esModule", { value: true });
  fY.Cast = fY.Default = fY.DefaultClone = fY.ValueCastUnknownTypeError = fY.ValueCastRecursiveTypeError = fY.ValueCastNeverTypeError = fY.ValueCastArrayUniqueItemsTypeError = undefined;
  var D12 = V02(), q1 = u82(), u0 = J$2(), u1 = i12(), VY = A1(), H1 = f02();

  class o8 extends H1.TypeBoxError {
    constructor($, Y) {
      super("Array cast produced invalid data due to uniqueItems constraint");
      this.schema = $, this.value = Y;
    }
  }
  fY.ValueCastArrayUniqueItemsTypeError = o8;

  class c8 extends H1.TypeBoxError {
    constructor($) {
      super("Never types cannot be cast");
      this.schema = $;
    }
  }
  fY.ValueCastNeverTypeError = c8;

  class xY extends H1.TypeBoxError {
    constructor($) {
      super("Cannot cast recursive schemas");
      this.schema = $;
    }
  }
  fY.ValueCastRecursiveTypeError = xY;

  class l8 extends H1.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  fY.ValueCastUnknownTypeError = l8;
  var h8;
  (function($) {
    function Y(Z, Q, J) {
      if (Z[H1.Kind] === "Object" && typeof J === "object" && !(0, D12.IsNull)(J)) {
        const q = Z, F = Object.getOwnPropertyNames(J), D = Object.entries(q.properties), [K, A] = [1 / D.length, D.length];
        return D.reduce((I, [j, N]) => {
          const L = N[H1.Kind] === "Literal" && N.const === J[j] ? A : 0, O = (0, u0.Check)(N, Q, J[j]) ? K : 0, U = F.includes(j) ? K : 0;
          return I + (L + O + U);
        }, 0);
      } else
        return (0, u0.Check)(Z, Q, J) ? 1 : 0;
    }
    function W(Z, Q, J) {
      let [q, F] = [Z.anyOf[0], 0];
      for (let D of Z.anyOf) {
        const K = Y(D, Q, J);
        if (K > F)
          q = D, F = K;
      }
      return q;
    }
    function X(Z, Q, J) {
      if ("default" in Z)
        return Z.default;
      else {
        const q = W(Z, Q, J);
        return gY(q, Q, J);
      }
    }
    $.Create = X;
  })(h8 || (h8 = {}));
  fY.DefaultClone = kY;
  fY.Default = n8;
  fY.Cast = gY;
});
var hY = J02((mY) => {
  var V$ = function($) {
    return (0, Z0.IsString)($) && !isNaN($) && !isNaN(parseFloat($));
  }, lJ = function($) {
    return (0, Z0.IsBigInt)($) || (0, Z0.IsBoolean)($) || (0, Z0.IsNumber)($);
  }, z$ = function($) {
    return $ === true || (0, Z0.IsNumber)($) && $ === 1 || (0, Z0.IsBigInt)($) && $ === BigInt("1") || (0, Z0.IsString)($) && ($.toLowerCase() === "true" || $ === "1");
  }, H$ = function($) {
    return $ === false || (0, Z0.IsNumber)($) && ($ === 0 || Object.is($, -0)) || (0, Z0.IsBigInt)($) && $ === BigInt("0") || (0, Z0.IsString)($) && ($.toLowerCase() === "false" || $ === "0" || $ === "-0");
  }, tJ = function($) {
    return (0, Z0.IsString)($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, sJ = function($) {
    return (0, Z0.IsString)($) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, rJ = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test($);
  }, aJ = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test($);
  }, eJ = function($) {
    return (0, Z0.IsString)($) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test($);
  }, $9 = function($, Y) {
    const W = pY($);
    return W === Y ? W : $;
  }, Y9 = function($, Y) {
    const W = iY($);
    return W === Y ? W : $;
  }, W9 = function($, Y) {
    const W = vY($);
    return W === Y ? W : $;
  }, X9 = function($, Y) {
    if (typeof $.const === "string")
      return $9(Y, $.const);
    else if (typeof $.const === "number")
      return Y9(Y, $.const);
    else if (typeof $.const === "boolean")
      return W9(Y, $.const);
    else
      return (0, oJ.Clone)(Y);
  }, vY = function($) {
    return z$($) ? true : H$($) ? false : $;
  }, Z9 = function($) {
    return V$($) ? BigInt(parseInt($)) : (0, Z0.IsNumber)($) ? BigInt($ | 0) : H$($) ? BigInt(0) : z$($) ? BigInt(1) : $;
  }, pY = function($) {
    return lJ($) ? $.toString() : (0, Z0.IsSymbol)($) && $.description !== undefined ? $.description.toString() : $;
  }, iY = function($) {
    return V$($) ? parseFloat($) : z$($) ? 1 : H$($) ? 0 : $;
  }, Q9 = function($) {
    return V$($) ? parseInt($) : (0, Z0.IsNumber)($) ? $ | 0 : z$($) ? 1 : H$($) ? 0 : $;
  }, J9 = function($) {
    return (0, Z0.IsString)($) && $.toLowerCase() === "null" ? null : $;
  }, z9 = function($) {
    return (0, Z0.IsString)($) && $ === "undefined" ? undefined : $;
  }, H9 = function($) {
    return (0, Z0.IsDate)($) ? $ : (0, Z0.IsNumber)($) ? new Date($) : z$($) ? new Date(1) : H$($) ? new Date(0) : V$($) ? new Date(parseInt($)) : sJ($) ? new Date(`1970-01-01T${$}.000Z`) : tJ($) ? new Date(`1970-01-01T${$}`) : aJ($) ? new Date(`${$}.000Z`) : rJ($) ? new Date($) : eJ($) ? new Date(`${$}T00:00:00.000Z`) : $;
  }, t8 = function($) {
    return $;
  }, q9 = function($, Y, W) {
    if ((0, Z0.IsArray)(W))
      return W.map((X) => c0($.items, Y, X));
    return W;
  }, M9 = function($, Y, W) {
    return Z9(W);
  }, N9 = function($, Y, W) {
    return vY(W);
  }, U9 = function($, Y, W) {
    return H9(W);
  }, F9 = function($, Y, W) {
    return Q9(W);
  }, B9 = function($, Y, W) {
    return $.allOf.every((X) => h1.TypeGuard.TObject(X)) ? c0(h1.Type.Composite($.allOf), Y, W) : c0($.allOf[0], Y, W);
  }, A9 = function($, Y, W) {
    return X9($, W);
  }, D9 = function($, Y, W) {
    return J9(W);
  }, w9 = function($, Y, W) {
    return iY(W);
  }, K9 = function($, Y, W) {
    if ((0, Z0.IsObject)(W))
      return Object.getOwnPropertyNames($.properties).reduce((X, Z) => {
        return W[Z] !== undefined ? { ...X, [Z]: c0($.properties[Z], Y, W[Z]) } : { ...X };
      }, W);
    return W;
  }, j9 = function($, Y, W) {
    const X = Object.getOwnPropertyNames($.patternProperties)[0], Z = $.patternProperties[X], Q = {};
    for (let [J, q] of Object.entries(W))
      Q[J] = c0(Z, Y, q);
    return Q;
  }, P9 = function($, Y, W) {
    return c0((0, yY.Deref)($, Y), Y, W);
  }, O9 = function($, Y, W) {
    return pY(W);
  }, S9 = function($, Y, W) {
    return (0, Z0.IsString)(W) || (0, Z0.IsNumber)(W) ? Symbol(W) : W;
  }, L9 = function($, Y, W) {
    return c0((0, yY.Deref)($, Y), Y, W);
  }, C9 = function($, Y, W) {
    if ((0, Z0.IsArray)(W) && !(0, Z0.IsUndefined)($.items))
      return W.map((X, Z) => {
        return Z < $.items.length ? c0($.items[Z], Y, X) : X;
      });
    return W;
  }, I9 = function($, Y, W) {
    return z9(W);
  }, R9 = function($, Y, W) {
    for (let X of $.anyOf) {
      const Z = c0(X, Y, W);
      if ((0, cJ.Check)(X, Y, Z))
        return Z;
    }
    return W;
  }, c0 = function($, Y, W) {
    const X = (0, Z0.IsString)($.$id) ? [...Y, $] : Y, Z = $;
    switch ($[h1.Kind]) {
      case "Array":
        return q9(Z, X, W);
      case "BigInt":
        return M9(Z, X, W);
      case "Boolean":
        return N9(Z, X, W);
      case "Date":
        return U9(Z, X, W);
      case "Integer":
        return F9(Z, X, W);
      case "Intersect":
        return B9(Z, X, W);
      case "Literal":
        return A9(Z, X, W);
      case "Null":
        return D9(Z, X, W);
      case "Number":
        return w9(Z, X, W);
      case "Object":
        return K9(Z, X, W);
      case "Record":
        return j9(Z, X, W);
      case "Ref":
        return P9(Z, X, W);
      case "String":
        return O9(Z, X, W);
      case "Symbol":
        return S9(Z, X, W);
      case "This":
        return L9(Z, X, W);
      case "Tuple":
        return C9(Z, X, W);
      case "Undefined":
        return I9(Z, X, W);
      case "Union":
        return R9(Z, X, W);
      case "Any":
      case "AsyncIterator":
      case "Constructor":
      case "Function":
      case "Iterator":
      case "Never":
      case "Promise":
      case "TemplateLiteral":
      case "Uint8Array":
      case "Unknown":
      case "Void":
        return t8(W);
      default:
        if (!h1.TypeRegistry.Has(Z[h1.Kind]))
          throw new s8(Z);
        return t8(W);
    }
  }, b9 = function(...$) {
    return $.length === 3 ? c0($[0], $[1], $[2]) : c0($[0], [], $[1]);
  };
  Object.defineProperty(mY, "__esModule", { value: true });
  mY.Convert = mY.Default = mY.ValueConvertUnknownTypeError = undefined;
  var Z0 = V02(), oJ = i12(), cJ = J$2(), yY = A1(), h1 = f02();

  class s8 extends h1.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  mY.ValueConvertUnknownTypeError = s8;
  mY.Default = t8;
  mY.Convert = b9;
});
var e82 = J02((sY) => {
  Object.defineProperty(sY, "__esModule", { value: true });
  sY.EncodeTransform = sY.DecodeTransform = sY.HasTransform = sY.TransformEncodeError = sY.TransformDecodeError = sY.TransformEncodeCheckError = sY.TransformDecodeCheckError = sY.TransformUnknownTypeError = undefined;
  var l0 = V02(), n1 = A1(), h2 = f02();

  class q$ extends h2.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  sY.TransformUnknownTypeError = q$;

  class lY extends h2.TypeBoxError {
    constructor($, Y, W) {
      super("Unable to decode due to invalid value");
      this.schema = $, this.value = Y, this.error = W;
    }
  }
  sY.TransformDecodeCheckError = lY;

  class tY extends h2.TypeBoxError {
    constructor($, Y, W) {
      super("Unable to encode due to invalid value");
      this.schema = $, this.value = Y, this.error = W;
    }
  }
  sY.TransformEncodeCheckError = tY;

  class r8 extends h2.TypeBoxError {
    constructor($, Y, W) {
      super(`${W instanceof Error ? W.message : "Unknown error"}`);
      this.schema = $, this.value = Y;
    }
  }
  sY.TransformDecodeError = r8;

  class a8 extends h2.TypeBoxError {
    constructor($, Y, W) {
      super(`${W instanceof Error ? W.message : "Unknown error"}`);
      this.schema = $, this.value = Y;
    }
  }
  sY.TransformEncodeError = a8;
  var nY2;
  (function($) {
    function Y(w, R) {
      return h2.TypeGuard.TTransform(w) || L(w.items, R);
    }
    function W(w, R) {
      return h2.TypeGuard.TTransform(w) || L(w.items, R);
    }
    function X(w, R) {
      return h2.TypeGuard.TTransform(w) || L(w.returns, R) || w.parameters.some((b) => L(b, R));
    }
    function Z(w, R) {
      return h2.TypeGuard.TTransform(w) || L(w.returns, R) || w.parameters.some((b) => L(b, R));
    }
    function Q(w, R) {
      return h2.TypeGuard.TTransform(w) || h2.TypeGuard.TTransform(w.unevaluatedProperties) || w.allOf.some((b) => L(b, R));
    }
    function J(w, R) {
      return h2.TypeGuard.TTransform(w) || L(w.items, R);
    }
    function q(w, R) {
      return h2.TypeGuard.TTransform(w) || L(w.not, R);
    }
    function F(w, R) {
      return h2.TypeGuard.TTransform(w) || Object.values(w.properties).some((b) => L(b, R)) || h2.TypeGuard.TSchema(w.additionalProperties) && L(w.additionalProperties, R);
    }
    function D(w, R) {
      return h2.TypeGuard.TTransform(w) || L(w.item, R);
    }
    function K(w, R) {
      const b = Object.getOwnPropertyNames(w.patternProperties)[0], V = w.patternProperties[b];
      return h2.TypeGuard.TTransform(w) || L(V, R) || h2.TypeGuard.TSchema(w.additionalProperties) && h2.TypeGuard.TTransform(w.additionalProperties);
    }
    function A(w, R) {
      if (h2.TypeGuard.TTransform(w))
        return true;
      return L((0, n1.Deref)(w, R), R);
    }
    function I(w, R) {
      if (h2.TypeGuard.TTransform(w))
        return true;
      return L((0, n1.Deref)(w, R), R);
    }
    function j(w, R) {
      return h2.TypeGuard.TTransform(w) || h2.TypeGuard.TSchema(w.items) && w.items.some((b) => L(b, R));
    }
    function N(w, R) {
      return h2.TypeGuard.TTransform(w) || w.anyOf.some((b) => L(b, R));
    }
    function L(w, R) {
      const b = (0, l0.IsString)(w.$id) ? [...R, w] : R, V = w;
      if (w.$id && O.has(w.$id))
        return false;
      if (w.$id)
        O.add(w.$id);
      switch (w[h2.Kind]) {
        case "Array":
          return Y(V, b);
        case "AsyncIterator":
          return W(V, b);
        case "Constructor":
          return X(V, b);
        case "Function":
          return Z(V, b);
        case "Intersect":
          return Q(V, b);
        case "Iterator":
          return J(V, b);
        case "Not":
          return q(V, b);
        case "Object":
          return F(V, b);
        case "Promise":
          return D(V, b);
        case "Record":
          return K(V, b);
        case "Ref":
          return A(V, b);
        case "This":
          return I(V, b);
        case "Tuple":
          return j(V, b);
        case "Union":
          return N(V, b);
        case "Any":
        case "BigInt":
        case "Boolean":
        case "Date":
        case "Integer":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "String":
        case "Symbol":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return h2.TypeGuard.TTransform(w);
        default:
          if (!h2.TypeRegistry.Has(V[h2.Kind]))
            throw new q$(V);
          return h2.TypeGuard.TTransform(w);
      }
    }
    const O = new Set;
    function U(w, R) {
      return O.clear(), L(w, R);
    }
    $.Has = U;
  })(nY2 || (sY.HasTransform = nY2 = {}));
  var oY;
  (function($) {
    function Y(N, L) {
      try {
        return h2.TypeGuard.TTransform(N) ? N[h2.Transform].Decode(L) : L;
      } catch (O) {
        throw new r8(N, L, O);
      }
    }
    function W(N, L, O) {
      const U = O.map((w) => A(N.items, L, w));
      return Y(N, U);
    }
    function X(N, L, O) {
      if (!(0, l0.IsPlainObject)(O) || (0, l0.IsValueType)(O))
        return Y(N, O);
      const U = h2.KeyResolver.ResolveKeys(N, { includePatterns: false }), w = Object.entries(O).reduce((b, [V, G]) => {
        return !U.includes(V) ? { ...b, [V]: G } : { ...b, [V]: Y(h2.IndexedAccessor.Resolve(N, [V]), G) };
      }, {});
      if (!h2.TypeGuard.TTransform(N.unevaluatedProperties))
        return Y(N, w);
      const R = Object.entries(w).reduce((b, [V, G]) => {
        return U.includes(V) ? { ...b, [V]: G } : { ...b, [V]: Y(N.unevaluatedProperties, G) };
      }, {});
      return Y(N, R);
    }
    function Z(N, L, O) {
      const U = A(N.not, L, O);
      return Y(N, U);
    }
    function Q(N, L, O) {
      if (!(0, l0.IsPlainObject)(O))
        return Y(N, O);
      const U = Object.entries(O).reduce((b, [V, G]) => {
        return !(V in N.properties) ? { ...b, [V]: G } : { ...b, [V]: A(N.properties[V], L, G) };
      }, {});
      if (!h2.TypeGuard.TSchema(N.additionalProperties))
        return Y(N, U);
      const w = N.additionalProperties, R = Object.entries(U).reduce((b, [V, G]) => {
        return V in N.properties ? { ...b, [V]: G } : { ...b, [V]: A(w, L, G) };
      }, {});
      return Y(N, R);
    }
    function J(N, L, O) {
      if (!(0, l0.IsPlainObject)(O))
        return Y(N, O);
      const U = Object.getOwnPropertyNames(N.patternProperties)[0], w = N.patternProperties[U], R = new RegExp(U), b = Object.entries(O).reduce((n, [o, $0]) => {
        return !R.test(o) ? { ...n, [o]: $0 } : { ...n, [o]: A(w, L, $0) };
      }, {});
      if (!h2.TypeGuard.TSchema(N.additionalProperties))
        return Y(N, b);
      const V = N.additionalProperties, G = Object.entries(b).reduce((n, [o, $0]) => {
        return R.test(o) ? { ...n, [o]: $0 } : { ...n, [o]: A(V, L, $0) };
      }, {});
      return Y(N, G);
    }
    function q(N, L, O) {
      const U = (0, n1.Deref)(N, L), w = A(U, L, O);
      return Y(N, w);
    }
    function F(N, L, O) {
      const U = (0, n1.Deref)(N, L), w = A(U, L, O);
      return Y(N, w);
    }
    function D(N, L, O) {
      const U = (0, l0.IsArray)(N.items) ? N.items.map((w, R) => A(w, L, O[R])) : [];
      return Y(N, U);
    }
    function K(N, L, O) {
      const U = Y(N, O);
      for (let w of N.anyOf) {
        if (!I(w, L, U))
          continue;
        return A(w, L, U);
      }
      return U;
    }
    function A(N, L, O) {
      const U = typeof N.$id === "string" ? [...L, N] : L, w = N;
      switch (N[h2.Kind]) {
        case "Array":
          return W(w, U, O);
        case "Intersect":
          return X(w, U, O);
        case "Not":
          return Z(w, U, O);
        case "Object":
          return Q(w, U, O);
        case "Record":
          return J(w, U, O);
        case "Ref":
          return q(w, U, O);
        case "Symbol":
          return Y(w, O);
        case "This":
          return F(w, U, O);
        case "Tuple":
          return D(w, U, O);
        case "Union":
          return K(w, U, O);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Constructor":
        case "Date":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Y(w, O);
        default:
          if (!h2.TypeRegistry.Has(w[h2.Kind]))
            throw new q$(w);
          return Y(w, O);
      }
    }
    let I = () => false;
    function j(N, L, O, U) {
      return I = U, A(N, L, O);
    }
    $.Decode = j;
  })(oY || (sY.DecodeTransform = oY = {}));
  var cY;
  (function($) {
    function Y(N, L) {
      try {
        return h2.TypeGuard.TTransform(N) ? N[h2.Transform].Encode(L) : L;
      } catch (O) {
        throw new a8(N, L, O);
      }
    }
    function W(N, L, O) {
      return Y(N, O).map((w) => A(N.items, L, w));
    }
    function X(N, L, O) {
      const U = Y(N, O);
      if (!(0, l0.IsPlainObject)(O) || (0, l0.IsValueType)(O))
        return U;
      const w = h2.KeyResolver.ResolveKeys(N, { includePatterns: false }), R = Object.entries(U).reduce((b, [V, G]) => {
        return !w.includes(V) ? { ...b, [V]: G } : { ...b, [V]: Y(h2.IndexedAccessor.Resolve(N, [V]), G) };
      }, {});
      if (!h2.TypeGuard.TTransform(N.unevaluatedProperties))
        return Y(N, R);
      return Object.entries(R).reduce((b, [V, G]) => {
        return w.includes(V) ? { ...b, [V]: G } : { ...b, [V]: Y(N.unevaluatedProperties, G) };
      }, {});
    }
    function Z(N, L, O) {
      const U = Y(N, O);
      return Y(N.not, U);
    }
    function Q(N, L, O) {
      const U = Y(N, O);
      if (!(0, l0.IsPlainObject)(O))
        return U;
      const w = Object.entries(U).reduce((b, [V, G]) => {
        return !(V in N.properties) ? { ...b, [V]: G } : { ...b, [V]: A(N.properties[V], L, G) };
      }, {});
      if (!h2.TypeGuard.TSchema(N.additionalProperties))
        return w;
      const R = N.additionalProperties;
      return Object.entries(w).reduce((b, [V, G]) => {
        return V in N.properties ? { ...b, [V]: G } : { ...b, [V]: A(R, L, G) };
      }, {});
    }
    function J(N, L, O) {
      const U = Y(N, O);
      if (!(0, l0.IsPlainObject)(O))
        return U;
      const w = Object.getOwnPropertyNames(N.patternProperties)[0], R = N.patternProperties[w], b = new RegExp(w), V = Object.entries(U).reduce((n, [o, $0]) => {
        return !b.test(o) ? { ...n, [o]: $0 } : { ...n, [o]: A(R, L, $0) };
      }, {});
      if (!h2.TypeGuard.TSchema(N.additionalProperties))
        return Y(N, V);
      const G = N.additionalProperties;
      return Object.entries(V).reduce((n, [o, $0]) => {
        return b.test(o) ? { ...n, [o]: $0 } : { ...n, [o]: A(G, L, $0) };
      }, {});
    }
    function q(N, L, O) {
      const U = (0, n1.Deref)(N, L), w = A(U, L, O);
      return Y(N, w);
    }
    function F(N, L, O) {
      const U = (0, n1.Deref)(N, L), w = A(U, L, O);
      return Y(N, w);
    }
    function D(N, L, O) {
      const U = Y(N, O);
      return (0, l0.IsArray)(N.items) ? N.items.map((w, R) => A(w, L, U[R])) : [];
    }
    function K(N, L, O) {
      for (let U of N.anyOf) {
        if (!I(U, L, O))
          continue;
        const w = A(U, L, O);
        return Y(N, w);
      }
      return Y(N, O);
    }
    function A(N, L, O) {
      const U = typeof N.$id === "string" ? [...L, N] : L, w = N;
      switch (N[h2.Kind]) {
        case "Array":
          return W(w, U, O);
        case "Intersect":
          return X(w, U, O);
        case "Not":
          return Z(w, U, O);
        case "Object":
          return Q(w, U, O);
        case "Record":
          return J(w, U, O);
        case "Ref":
          return q(w, U, O);
        case "This":
          return F(w, U, O);
        case "Tuple":
          return D(w, U, O);
        case "Union":
          return K(w, U, O);
        case "Any":
        case "AsyncIterator":
        case "BigInt":
        case "Boolean":
        case "Constructor":
        case "Date":
        case "Function":
        case "Integer":
        case "Iterator":
        case "Literal":
        case "Never":
        case "Null":
        case "Number":
        case "Promise":
        case "String":
        case "Symbol":
        case "TemplateLiteral":
        case "Undefined":
        case "Uint8Array":
        case "Unknown":
        case "Void":
          return Y(w, O);
        default:
          if (!h2.TypeRegistry.Has(w[h2.Kind]))
            throw new q$(w);
          return Y(w, O);
      }
    }
    let I = () => false;
    function j(N, L, O, U) {
      return I = U, A(N, L, O);
    }
    $.Encode = j;
  })(cY || (sY.EncodeTransform = cY = {}));
});
var JW2 = J02((ZW) => {
  Object.defineProperty(ZW, "__esModule", { value: true });
  ZW.Value = undefined;
  var aY = I$2(), d9 = jY2(), y9 = W$2(), v9 = SY2(), eY = dY2(), p9 = i12(), $W = hY(), YW = u82(), x$ = J$2(), WW = V82(), k$ = e82(), XW;
  (function($) {
    function Y(...N) {
      return eY.Cast.apply(eY, N);
    }
    $.Cast = Y;
    function W(...N) {
      return YW.Create.apply(YW, N);
    }
    $.Create = W;
    function X(...N) {
      return x$.Check.apply(x$, N);
    }
    $.Check = X;
    function Z(...N) {
      return $W.Convert.apply($W, N);
    }
    $.Convert = Z;
    function Q(N) {
      return p9.Clone(N);
    }
    $.Clone = Q;
    function J(...N) {
      const [L, O, U] = N.length === 3 ? [N[0], N[1], N[2]] : [N[0], [], N[1]];
      if (!X(L, O, U))
        throw new k$.TransformDecodeCheckError(L, U, F(L, O, U).First());
      return k$.DecodeTransform.Decode(L, O, U, x$.Check);
    }
    $.Decode = J;
    function q(...N) {
      const [L, O, U] = N.length === 3 ? [N[0], N[1], N[2]] : [N[0], [], N[1]], w = k$.EncodeTransform.Encode(L, O, U, x$.Check);
      if (!X(L, O, w))
        throw new k$.TransformEncodeCheckError(L, U, F(L, O, U).First());
      return w;
    }
    $.Encode = q;
    function F(...N) {
      return aY.Errors.apply(aY, N);
    }
    $.Errors = F;
    function D(N, L) {
      return v9.Equal(N, L);
    }
    $.Equal = D;
    function K(N, L) {
      return WW.Diff(N, L);
    }
    $.Diff = K;
    function A(N) {
      return y9.Hash(N);
    }
    $.Hash = A;
    function I(N, L) {
      return WW.Patch(N, L);
    }
    $.Patch = I;
    function j(N, L) {
      d9.Mutate(N, L);
    }
    $.Mutate = j;
  })(XW || (ZW.Value = XW = {}));
});
var $62 = J02((Y1) => {
  Object.defineProperty(Y1, "__esModule", { value: true });
  Y1.Value = Y1.ValuePointer = Y1.Delete = Y1.Update = Y1.Insert = Y1.Edit = Y1.ValueErrorIterator = Y1.ValueErrorType = undefined;
  var zW = I$2();
  Object.defineProperty(Y1, "ValueErrorType", { enumerable: true, get: function() {
    return zW.ValueErrorType;
  } });
  Object.defineProperty(Y1, "ValueErrorIterator", { enumerable: true, get: function() {
    return zW.ValueErrorIterator;
  } });
  var g$ = V82();
  Object.defineProperty(Y1, "Edit", { enumerable: true, get: function() {
    return g$.Edit;
  } });
  Object.defineProperty(Y1, "Insert", { enumerable: true, get: function() {
    return g$.Insert;
  } });
  Object.defineProperty(Y1, "Update", { enumerable: true, get: function() {
    return g$.Update;
  } });
  Object.defineProperty(Y1, "Delete", { enumerable: true, get: function() {
    return g$.Delete;
  } });
  var i9 = R$();
  Object.defineProperty(Y1, "ValuePointer", { enumerable: true, get: function() {
    return i9.ValuePointer;
  } });
  var m9 = JW2();
  Object.defineProperty(Y1, "Value", { enumerable: true, get: function() {
    return m9.Value;
  } });
});
var FW2 = J02((NW) => {
  Object.defineProperty(NW, "__esModule", { value: true });
  NW.TypeCompiler = NW.Policy = NW.TypeCompilerTypeGuardError = NW.TypeCompilerUnknownTypeError = NW.TypeCheck = undefined;
  var U$ = e82(), c = V02(), r9 = Y$2(), F$ = E$2(), a9 = A1(), e9 = W$2(), N0 = f02();

  class Q6 {
    constructor($, Y, W, X) {
      this.schema = $, this.references = Y, this.checkFunc = W, this.code = X, this.hasTransform = U$.HasTransform.Has($, Y);
    }
    Code() {
      return this.code;
    }
    Errors($) {
      return (0, r9.Errors)(this.schema, this.references, $);
    }
    Check($) {
      return this.checkFunc($);
    }
    Decode($) {
      if (!this.checkFunc($))
        throw new U$.TransformDecodeCheckError(this.schema, $, this.Errors($).First());
      return this.hasTransform ? U$.DecodeTransform.Decode(this.schema, this.references, $, (Y, W, X) => this.Check(X)) : $;
    }
    Encode($) {
      const Y = this.hasTransform ? U$.EncodeTransform.Encode(this.schema, this.references, $, (W, X, Z) => this.Check(Z)) : $;
      if (!this.checkFunc(Y))
        throw new U$.TransformEncodeCheckError(this.schema, $, this.Errors($).First());
      return Y;
    }
  }
  NW.TypeCheck = Q6;
  var M12;
  (function($) {
    function Y(Q) {
      return Q === 36;
    }
    $.DollarSign = Y;
    function W(Q) {
      return Q === 95;
    }
    $.IsUnderscore = W;
    function X(Q) {
      return Q >= 65 && Q <= 90 || Q >= 97 && Q <= 122;
    }
    $.IsAlpha = X;
    function Z(Q) {
      return Q >= 48 && Q <= 57;
    }
    $.IsNumeric = Z;
  })(M12 || (M12 = {}));
  var v$;
  (function($) {
    function Y(Q) {
      if (Q.length === 0)
        return false;
      return M12.IsNumeric(Q.charCodeAt(0));
    }
    function W(Q) {
      if (Y(Q))
        return false;
      for (let J = 0;J < Q.length; J++) {
        const q = Q.charCodeAt(J);
        if (!(M12.IsAlpha(q) || M12.IsNumeric(q) || M12.DollarSign(q) || M12.IsUnderscore(q)))
          return false;
      }
      return true;
    }
    function X(Q) {
      return Q.replace(/'/g, "\\'");
    }
    function Z(Q, J) {
      return W(J) ? `${Q}.${J}` : `${Q}['${X(J)}']`;
    }
    $.Encode = Z;
  })(v$ || (v$ = {}));
  var X6;
  (function($) {
    function Y(W) {
      const X = [];
      for (let Z = 0;Z < W.length; Z++) {
        const Q = W.charCodeAt(Z);
        if (M12.IsNumeric(Q) || M12.IsAlpha(Q))
          X.push(W.charAt(Z));
        else
          X.push(`_${Q}_`);
      }
      return X.join("").replace(/__/g, "_");
    }
    $.Encode = Y;
  })(X6 || (X6 = {}));
  var Z6;
  (function($) {
    function Y(W) {
      return W.replace(/'/g, "\\'");
    }
    $.Escape = Y;
  })(Z6 || (Z6 = {}));

  class J6 extends N0.TypeBoxError {
    constructor($) {
      super("Unknown type");
      this.schema = $;
    }
  }
  NW.TypeCompilerUnknownTypeError = J6;

  class p$ extends N0.TypeBoxError {
    constructor($) {
      super("Preflight validation check failed to guard for the given schema");
      this.schema = $;
    }
  }
  NW.TypeCompilerTypeGuardError = p$;
  var S12;
  (function($) {
    function Y(J, q, F) {
      return F$.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${q}' in ${J} ? ${F} : true)` : `(${v$.Encode(J, q)} !== undefined ? ${F} : true)`;
    }
    $.IsExactOptionalProperty = Y;
    function W(J) {
      return !F$.TypeSystemPolicy.AllowArrayObject ? `(typeof ${J} === 'object' && ${J} !== null && !Array.isArray(${J}))` : `(typeof ${J} === 'object' && ${J} !== null)`;
    }
    $.IsObjectLike = W;
    function X(J) {
      return !F$.TypeSystemPolicy.AllowArrayObject ? `(typeof ${J} === 'object' && ${J} !== null && !Array.isArray(${J}) && !(${J} instanceof Date) && !(${J} instanceof Uint8Array))` : `(typeof ${J} === 'object' && ${J} !== null && !(${J} instanceof Date) && !(${J} instanceof Uint8Array))`;
    }
    $.IsRecordLike = X;
    function Z(J) {
      return !F$.TypeSystemPolicy.AllowNaN ? `(typeof ${J} === 'number' && Number.isFinite(${J}))` : `typeof ${J} === 'number'`;
    }
    $.IsNumberLike = Z;
    function Q(J) {
      return F$.TypeSystemPolicy.AllowNullVoid ? `(${J} === undefined || ${J} === null)` : `${J} === undefined`;
    }
    $.IsVoidLike = Q;
  })(S12 || (NW.Policy = S12 = {}));
  var MW;
  (function($) {
    function Y(P) {
      return P[N0.Kind] === "Any" || P[N0.Kind] === "Unknown";
    }
    function* W(P, _, S) {
      yield "true";
    }
    function* X(P, _, S) {
      yield `Array.isArray(${S})`;
      const [p, f] = [H0("value", "any"), H0("acc", "number")];
      if ((0, c.IsNumber)(P.maxItems))
        yield `${S}.length <= ${P.maxItems}`;
      if ((0, c.IsNumber)(P.minItems))
        yield `${S}.length >= ${P.minItems}`;
      const T = E(P.items, _, "value");
      if (yield `${S}.every((${p}) => ${T})`, N0.TypeGuard.TSchema(P.contains) || (0, c.IsNumber)(P.minContains) || (0, c.IsNumber)(P.maxContains)) {
        const W0 = N0.TypeGuard.TSchema(P.contains) ? P.contains : N0.Type.Never(), K0 = E(W0, _, "value"), X0 = (0, c.IsNumber)(P.minContains) ? [`(count >= ${P.minContains})`] : [], M = (0, c.IsNumber)(P.maxContains) ? [`(count <= ${P.maxContains})`] : [], l = `const count = ${S}.reduce((${f}, ${p}) => ${K0} ? acc + 1 : acc, 0)`, S0 = ["(count > 0)", ...X0, ...M].join(" && ");
        yield `((${p}) => { ${l}; return ${S0}})(${S})`;
      }
      if (P.uniqueItems === true)
        yield `((${p}) => { const set = new Set(); for(const element of value) { const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true } )(${S})`;
    }
    function* Z(P, _, S) {
      yield `(typeof value === 'object' && Symbol.asyncIterator in ${S})`;
    }
    function* Q(P, _, S) {
      if (yield `(typeof ${S} === 'bigint')`, (0, c.IsBigInt)(P.exclusiveMaximum))
        yield `${S} < BigInt(${P.exclusiveMaximum})`;
      if ((0, c.IsBigInt)(P.exclusiveMinimum))
        yield `${S} > BigInt(${P.exclusiveMinimum})`;
      if ((0, c.IsBigInt)(P.maximum))
        yield `${S} <= BigInt(${P.maximum})`;
      if ((0, c.IsBigInt)(P.minimum))
        yield `${S} >= BigInt(${P.minimum})`;
      if ((0, c.IsBigInt)(P.multipleOf))
        yield `(${S} % BigInt(${P.multipleOf})) === 0`;
    }
    function* J(P, _, S) {
      yield `(typeof ${S} === 'boolean')`;
    }
    function* q(P, _, S) {
      yield* g0(P.returns, _, `${S}.prototype`);
    }
    function* F(P, _, S) {
      if (yield `(${S} instanceof Date) && Number.isFinite(${S}.getTime())`, (0, c.IsNumber)(P.exclusiveMaximumTimestamp))
        yield `${S}.getTime() < ${P.exclusiveMaximumTimestamp}`;
      if ((0, c.IsNumber)(P.exclusiveMinimumTimestamp))
        yield `${S}.getTime() > ${P.exclusiveMinimumTimestamp}`;
      if ((0, c.IsNumber)(P.maximumTimestamp))
        yield `${S}.getTime() <= ${P.maximumTimestamp}`;
      if ((0, c.IsNumber)(P.minimumTimestamp))
        yield `${S}.getTime() >= ${P.minimumTimestamp}`;
      if ((0, c.IsNumber)(P.multipleOfTimestamp))
        yield `(${S}.getTime() % ${P.multipleOfTimestamp}) === 0`;
    }
    function* D(P, _, S) {
      yield `(typeof ${S} === 'function')`;
    }
    function* K(P, _, S) {
      if (yield `(typeof ${S} === 'number' && Number.isInteger(${S}))`, (0, c.IsNumber)(P.exclusiveMaximum))
        yield `${S} < ${P.exclusiveMaximum}`;
      if ((0, c.IsNumber)(P.exclusiveMinimum))
        yield `${S} > ${P.exclusiveMinimum}`;
      if ((0, c.IsNumber)(P.maximum))
        yield `${S} <= ${P.maximum}`;
      if ((0, c.IsNumber)(P.minimum))
        yield `${S} >= ${P.minimum}`;
      if ((0, c.IsNumber)(P.multipleOf))
        yield `(${S} % ${P.multipleOf}) === 0`;
    }
    function* A(P, _, S) {
      const p = P.allOf.map((f) => E(f, _, S)).join(" && ");
      if (P.unevaluatedProperties === false) {
        const f = u(`${new RegExp(N0.KeyResolver.ResolvePattern(P))};`), T = `Object.getOwnPropertyNames(${S}).every(key => ${f}.test(key))`;
        yield `(${p} && ${T})`;
      } else if (N0.TypeGuard.TSchema(P.unevaluatedProperties)) {
        const f = u(`${new RegExp(N0.KeyResolver.ResolvePattern(P))};`), T = `Object.getOwnPropertyNames(${S}).every(key => ${f}.test(key) || ${E(P.unevaluatedProperties, _, `${S}[key]`)})`;
        yield `(${p} && ${T})`;
      } else
        yield `(${p})`;
    }
    function* I(P, _, S) {
      yield `(typeof value === 'object' && Symbol.iterator in ${S})`;
    }
    function* j(P, _, S) {
      if (typeof P.const === "number" || typeof P.const === "boolean")
        yield `(${S} === ${P.const})`;
      else
        yield `(${S} === '${Z6.Escape(P.const)}')`;
    }
    function* N(P, _, S) {
      yield "false";
    }
    function* L(P, _, S) {
      yield `(!${E(P.not, _, S)})`;
    }
    function* O(P, _, S) {
      yield `(${S} === null)`;
    }
    function* U(P, _, S) {
      if (yield S12.IsNumberLike(S), (0, c.IsNumber)(P.exclusiveMaximum))
        yield `${S} < ${P.exclusiveMaximum}`;
      if ((0, c.IsNumber)(P.exclusiveMinimum))
        yield `${S} > ${P.exclusiveMinimum}`;
      if ((0, c.IsNumber)(P.maximum))
        yield `${S} <= ${P.maximum}`;
      if ((0, c.IsNumber)(P.minimum))
        yield `${S} >= ${P.minimum}`;
      if ((0, c.IsNumber)(P.multipleOf))
        yield `(${S} % ${P.multipleOf}) === 0`;
    }
    function* w(P, _, S) {
      if (yield S12.IsObjectLike(S), (0, c.IsNumber)(P.minProperties))
        yield `Object.getOwnPropertyNames(${S}).length >= ${P.minProperties}`;
      if ((0, c.IsNumber)(P.maxProperties))
        yield `Object.getOwnPropertyNames(${S}).length <= ${P.maxProperties}`;
      const p = Object.getOwnPropertyNames(P.properties);
      for (let f of p) {
        const T = v$.Encode(S, f), W0 = P.properties[f];
        if (P.required && P.required.includes(f)) {
          if (yield* g0(W0, _, T), N0.ExtendsUndefined.Check(W0) || Y(W0))
            yield `('${f}' in ${S})`;
        } else {
          const K0 = E(W0, _, T);
          yield S12.IsExactOptionalProperty(S, f, K0);
        }
      }
      if (P.additionalProperties === false)
        if (P.required && P.required.length === p.length)
          yield `Object.getOwnPropertyNames(${S}).length === ${p.length}`;
        else {
          const f = `[${p.map((T) => `'${T}'`).join(", ")}]`;
          yield `Object.getOwnPropertyNames(${S}).every(key => ${f}.includes(key))`;
        }
      if (typeof P.additionalProperties === "object") {
        const f = E(P.additionalProperties, _, `${S}[key]`), T = `[${p.map((W0) => `'${W0}'`).join(", ")}]`;
        yield `(Object.getOwnPropertyNames(${S}).every(key => ${T}.includes(key) || ${f}))`;
      }
    }
    function* R(P, _, S) {
      yield `(typeof value === 'object' && typeof ${S}.then === 'function')`;
    }
    function* b(P, _, S) {
      if (yield S12.IsRecordLike(S), (0, c.IsNumber)(P.minProperties))
        yield `Object.getOwnPropertyNames(${S}).length >= ${P.minProperties}`;
      if ((0, c.IsNumber)(P.maxProperties))
        yield `Object.getOwnPropertyNames(${S}).length <= ${P.maxProperties}`;
      const [p, f] = Object.entries(P.patternProperties)[0], T = u(`${new RegExp(p)}`), W0 = E(f, _, "value"), K0 = N0.TypeGuard.TSchema(P.additionalProperties) ? E(P.additionalProperties, _, S) : P.additionalProperties === false ? "false" : "true", X0 = `(${T}.test(key) ? ${W0} : ${K0})`;
      yield `(Object.entries(${S}).every(([key, value]) => ${X0}))`;
    }
    function* V(P, _, S) {
      const p = (0, a9.Deref)(P, _);
      if (M0.functions.has(P.$ref))
        return yield `${d(P.$ref)}(${S})`;
      yield* g0(p, _, S);
    }
    function* G(P, _, S) {
      if (yield `(typeof ${S} === 'string')`, (0, c.IsNumber)(P.maxLength))
        yield `${S}.length <= ${P.maxLength}`;
      if ((0, c.IsNumber)(P.minLength))
        yield `${S}.length >= ${P.minLength}`;
      if (P.pattern !== undefined)
        yield `${u(`${new RegExp(P.pattern)};`)}.test(${S})`;
      if (P.format !== undefined)
        yield `format('${P.format}', ${S})`;
    }
    function* n(P, _, S) {
      yield `(typeof ${S} === 'symbol')`;
    }
    function* o(P, _, S) {
      yield `(typeof ${S} === 'string')`, yield `${u(`${new RegExp(P.pattern)};`)}.test(${S})`;
    }
    function* $0(P, _, S) {
      yield `${d(P.$ref)}(${S})`;
    }
    function* h0(P, _, S) {
      if (yield `Array.isArray(${S})`, P.items === undefined)
        return yield `${S}.length === 0`;
      yield `(${S}.length === ${P.maxItems})`;
      for (let p = 0;p < P.items.length; p++)
        yield `${E(P.items[p], _, `${S}[${p}]`)}`;
    }
    function* w0(P, _, S) {
      yield `${S} === undefined`;
    }
    function* k0(P, _, S) {
      yield `(${P.anyOf.map((f) => E(f, _, S)).join(" || ")})`;
    }
    function* F0(P, _, S) {
      if (yield `${S} instanceof Uint8Array`, (0, c.IsNumber)(P.maxByteLength))
        yield `(${S}.length <= ${P.maxByteLength})`;
      if ((0, c.IsNumber)(P.minByteLength))
        yield `(${S}.length >= ${P.minByteLength})`;
    }
    function* v0(P, _, S) {
      yield "true";
    }
    function* z0(P, _, S) {
      yield S12.IsVoidLike(S);
    }
    function* p0(P, _, S) {
      const p = M0.instances.size;
      M0.instances.set(p, P), yield `kind('${P[N0.Kind]}', ${p}, ${S})`;
    }
    function* g0(P, _, S, p = true) {
      const f = (0, c.IsString)(P.$id) ? [..._, P] : _, T = P;
      if (p && (0, c.IsString)(P.$id)) {
        const W0 = d(P.$id);
        if (M0.functions.has(W0))
          return yield `${W0}(${S})`;
        else {
          const K0 = t(W0, P, _, "value", false);
          return M0.functions.set(W0, K0), yield `${W0}(${S})`;
        }
      }
      switch (T[N0.Kind]) {
        case "Any":
          return yield* W(T, f, S);
        case "Array":
          return yield* X(T, f, S);
        case "AsyncIterator":
          return yield* Z(T, f, S);
        case "BigInt":
          return yield* Q(T, f, S);
        case "Boolean":
          return yield* J(T, f, S);
        case "Constructor":
          return yield* q(T, f, S);
        case "Date":
          return yield* F(T, f, S);
        case "Function":
          return yield* D(T, f, S);
        case "Integer":
          return yield* K(T, f, S);
        case "Intersect":
          return yield* A(T, f, S);
        case "Iterator":
          return yield* I(T, f, S);
        case "Literal":
          return yield* j(T, f, S);
        case "Never":
          return yield* N(T, f, S);
        case "Not":
          return yield* L(T, f, S);
        case "Null":
          return yield* O(T, f, S);
        case "Number":
          return yield* U(T, f, S);
        case "Object":
          return yield* w(T, f, S);
        case "Promise":
          return yield* R(T, f, S);
        case "Record":
          return yield* b(T, f, S);
        case "Ref":
          return yield* V(T, f, S);
        case "String":
          return yield* G(T, f, S);
        case "Symbol":
          return yield* n(T, f, S);
        case "TemplateLiteral":
          return yield* o(T, f, S);
        case "This":
          return yield* $0(T, f, S);
        case "Tuple":
          return yield* h0(T, f, S);
        case "Undefined":
          return yield* w0(T, f, S);
        case "Union":
          return yield* k0(T, f, S);
        case "Uint8Array":
          return yield* F0(T, f, S);
        case "Unknown":
          return yield* v0(T, f, S);
        case "Void":
          return yield* z0(T, f, S);
        default:
          if (!N0.TypeRegistry.Has(T[N0.Kind]))
            throw new J6(P);
          return yield* p0(T, f, S);
      }
    }
    const M0 = { language: "javascript", functions: new Map, variables: new Map, instances: new Map };
    function E(P, _, S, p = true) {
      return `(${[...g0(P, _, S, p)].join(" && ")})`;
    }
    function d(P) {
      return `check_${X6.Encode(P)}`;
    }
    function u(P) {
      const _ = `local_${M0.variables.size}`;
      return M0.variables.set(_, `const ${_} = ${P}`), _;
    }
    function t(P, _, S, p, f = true) {
      const [T, W0] = ["\n", (l) => "".padStart(l, " ")], K0 = H0("value", "any"), X0 = E0("boolean"), M = [...g0(_, S, p, f)].map((l) => `${W0(4)}${l}`).join(` &&${T}`);
      return `function ${P}(${K0})${X0} {${T}${W0(2)}return (${T}${M}${T}${W0(2)})\n}`;
    }
    function H0(P, _) {
      const S = M0.language === "typescript" ? `: ${_}` : "";
      return `${P}${S}`;
    }
    function E0(P) {
      return M0.language === "typescript" ? `: ${P}` : "";
    }
    function D0(P, _, S) {
      const p = t("check", P, _, "value"), f = H0("value", "any"), T = E0("boolean"), W0 = [...M0.functions.values()], K0 = [...M0.variables.values()], X0 = (0, c.IsString)(P.$id) ? `return function check(${f})${T} {\n  return ${d(P.$id)}(value)\n}` : `return ${p}`;
      return [...K0, ...W0, X0].join("\n");
    }
    function a(...P) {
      const _ = { language: "javascript" }, [S, p, f] = P.length === 2 && (0, c.IsArray)(P[1]) ? [P[0], P[1], _] : P.length === 2 && !(0, c.IsArray)(P[1]) ? [P[0], [], P[1]] : P.length === 3 ? [P[0], P[1], P[2]] : P.length === 1 ? [P[0], [], _] : [null, [], _];
      if (M0.language = f.language, M0.variables.clear(), M0.functions.clear(), M0.instances.clear(), !N0.TypeGuard.TSchema(S))
        throw new p$(S);
      for (let T of p)
        if (!N0.TypeGuard.TSchema(T))
          throw new p$(T);
      return D0(S, p, f);
    }
    $.Code = a;
    function B12(P, _ = []) {
      const S = a(P, _, { language: "javascript" }), p = globalThis.Function("kind", "format", "hash", S), f = new Map(M0.instances);
      function T(M, l, S0) {
        if (!N0.TypeRegistry.Has(M) || !f.has(l))
          return false;
        const l$ = N0.TypeRegistry.Get(M), t$ = f.get(l);
        return l$(t$, S0);
      }
      function W0(M, l) {
        if (!N0.FormatRegistry.Has(M))
          return false;
        return N0.FormatRegistry.Get(M)(l);
      }
      function K0(M) {
        return (0, e9.Hash)(M);
      }
      const X0 = p(T, W0, K0);
      return new Q6(P, _, X0, S);
    }
    $.Compile = B12;
  })(MW || (NW.TypeCompiler = MW = {}));
});
var AW2 = J02((t0) => {
  var Z7 = t0 && t0.__createBinding || (Object.create ? function($, Y, W, X) {
    if (X === undefined)
      X = W;
    var Z = Object.getOwnPropertyDescriptor(Y, W);
    if (!Z || ("get" in Z ? !Y.__esModule : Z.writable || Z.configurable))
      Z = { enumerable: true, get: function() {
        return Y[W];
      } };
    Object.defineProperty($, X, Z);
  } : function($, Y, W, X) {
    if (X === undefined)
      X = W;
    $[X] = Y[W];
  }), Q7 = t0 && t0.__exportStar || function($, Y) {
    for (var W in $)
      if (W !== "default" && !Object.prototype.hasOwnProperty.call(Y, W))
        Z7(Y, $, W);
  };
  Object.defineProperty(t0, "__esModule", { value: true });
  t0.ValueErrorIterator = t0.ValueErrorType = undefined;
  var BW = I$2();
  Object.defineProperty(t0, "ValueErrorType", { enumerable: true, get: function() {
    return BW.ValueErrorType;
  } });
  Object.defineProperty(t0, "ValueErrorIterator", { enumerable: true, get: function() {
    return BW.ValueErrorIterator;
  } });
  Q7(FW2(), t0);
});
var RW = J02((wz, IW) => {
  var H7 = function($) {
    var Y = $.indexOf("%");
    if (Y === -1)
      return $;
    var W = $.length, X = "", Z = 0, Q = 0, J = Y, q = LW;
    while (Y > -1 && Y < W) {
      var F = CW($[Y + 1], 4), D = CW($[Y + 2], 0), K = F | D, A = F6[K];
      if (q = F6[256 + q + A], Q = Q << 6 | K & F6[364 + A], q === LW)
        X += $.slice(Z, J), X += Q <= 65535 ? String.fromCharCode(Q) : String.fromCharCode(55232 + (Q >> 10), 56320 + (Q & 1023)), Q = 0, Z = Y + 3, Y = J = $.indexOf("%", Z);
      else if (q === z7)
        return null;
      else {
        if (Y += 3, Y < W && $.charCodeAt(Y) === 37)
          continue;
        return null;
      }
    }
    return X + $.slice(Z);
  }, CW = function($, Y) {
    var W = q7[$];
    return W === undefined ? 255 : W << Y;
  }, LW = 12, z7 = 0, F6 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7], q7 = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  IW.exports = H7;
});
var VW2 = J02((Kz, EW) => {
  var M7 = function($) {
    const Y = new _W;
    if (typeof $ !== "string")
      return Y;
    let W = $.length, X = "", Z = "", Q = -1, J = -1, q = false, F = false, D = false, K = false, A = false, I = 0;
    for (let j = 0;j < W + 1; j++)
      if (I = j !== W ? $.charCodeAt(j) : 38, I === 38) {
        if (A = J > Q, !A)
          J = j;
        if (X = $.slice(Q + 1, J), A || X.length > 0) {
          if (D)
            X = X.replace(GW, " ");
          if (q)
            X = bW2(X) || X;
          if (A) {
            if (Z = $.slice(J + 1, j), K)
              Z = Z.replace(GW, " ");
            if (F)
              Z = bW2(Z) || Z;
          }
          const N = Y[X];
          if (N === undefined)
            Y[X] = Z;
          else if (N.pop)
            N.push(Z);
          else
            Y[X] = [N, Z];
        }
        Z = "", Q = j, J = j, q = false, F = false, D = false, K = false;
      } else if (I === 61)
        if (J <= Q)
          J = j;
        else
          F = true;
      else if (I === 43)
        if (J > Q)
          K = true;
        else
          D = true;
      else if (I === 37)
        if (J > Q)
          F = true;
        else
          q = true;
    return Y;
  }, bW2 = RW(), GW = /\+/g, _W = function() {
  };
  _W.prototype = Object.create(null);
  EW.exports = M7;
});
var kW2 = J02((jz, xW) => {
  var U7 = function($) {
    const Y = $.length;
    if (Y === 0)
      return "";
    let W = "", X = 0, Z = 0;
    $:
      for (;Z < Y; Z++) {
        let Q = $.charCodeAt(Z);
        while (Q < 128) {
          if (N7[Q] !== 1) {
            if (X < Z)
              W += $.slice(X, Z);
            X = Z + 1, W += W1[Q];
          }
          if (++Z === Y)
            break $;
          Q = $.charCodeAt(Z);
        }
        if (X < Z)
          W += $.slice(X, Z);
        if (Q < 2048) {
          X = Z + 1, W += W1[192 | Q >> 6] + W1[128 | Q & 63];
          continue;
        }
        if (Q < 55296 || Q >= 57344) {
          X = Z + 1, W += W1[224 | Q >> 12] + W1[128 | Q >> 6 & 63] + W1[128 | Q & 63];
          continue;
        }
        if (++Z, Z >= Y)
          throw new Error("URI malformed");
        const J = $.charCodeAt(Z) & 1023;
        X = Z + 1, Q = 65536 + ((Q & 1023) << 10 | J), W += W1[240 | Q >> 18] + W1[128 | Q >> 12 & 63] + W1[128 | Q >> 6 & 63] + W1[128 | Q & 63];
      }
    if (X === 0)
      return $;
    if (X < Y)
      return W + $.slice(X);
    return W;
  }, W1 = Array.from({ length: 256 }, ($, Y) => "%" + ((Y < 16 ? "0" : "") + Y.toString(16)).toUpperCase()), N7 = new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0]);
  xW.exports = { encodeString: U7 };
});
var TW2 = J02((Pz, fW) => {
  var gW = function($) {
    const Y = typeof $;
    if (Y === "string")
      return B6($);
    else if (Y === "bigint")
      return $.toString();
    else if (Y === "boolean")
      return $ ? "true" : "false";
    else if (Y === "number" && Number.isFinite($))
      return $ < 1000000000000000000000 ? "" + $ : B6("" + $);
    return "";
  }, F7 = function($) {
    let Y = "";
    if ($ === null || typeof $ !== "object")
      return Y;
    const W = "&", X = Object.keys($), Z = X.length;
    let Q = 0;
    for (let J = 0;J < Z; J++) {
      const q = X[J], F = $[q], D = B6(q) + "=";
      if (J)
        Y += W;
      if (Array.isArray(F)) {
        Q = F.length;
        for (let K = 0;K < Q; K++) {
          if (K)
            Y += W;
          Y += D, Y += gW(F[K]);
        }
      } else
        Y += D, Y += gW(F);
    }
    return Y;
  }, { encodeString: B6 } = kW2();
  fW.exports = F7;
});
var A62 = J02((Oz, D$) => {
  var dW = VW2(), yW = TW2(), vW = { parse: dW, stringify: yW };
  D$.exports = vW;
  D$.exports.default = vW;
  D$.exports.parse = dW;
  D$.exports.stringify = yW;
});
var _12 = ($, Y) => ({ part: $, store: null, inert: Y !== undefined ? new Map(Y.map((W) => [W.part.charCodeAt(0), W])) : null, params: null, wildcardStore: null });
var L62 = ($, Y) => ({ ...$, part: Y });
var C62 = ($) => ({ paramName: $, store: null, inert: null });

class E12 {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
  add($, Y, W) {
    let X;
    if (typeof Y != "string")
      throw TypeError("Route path must be a string");
    Y === "" ? Y = "/" : Y[0] !== "/" && (Y = `/${Y}`), this.history.push([$, Y, W]);
    let Z = Y[Y.length - 1] === "*";
    Z && (Y = Y.slice(0, -1));
    let Q = Y.split(E12.regex.static), J = Y.match(E12.regex.params) || [];
    Q[Q.length - 1] === "" && Q.pop(), X = this.root[$] ? this.root[$] : this.root[$] = _12("/");
    let q = 0;
    for (let F = 0;F < Q.length; ++F) {
      let D = Q[F];
      if (F > 0) {
        let K = J[q++].slice(1);
        if (X.params === null)
          X.params = C62(K);
        else if (X.params.paramName !== K)
          throw Error(`Cannot create route "${Y}" with parameter "${K}" because a route already exists with a different parameter name ("${X.params.paramName}") in the same location`);
        let A = X.params;
        if (A.inert === null) {
          X = A.inert = _12(D);
          continue;
        }
        X = A.inert;
      }
      for (let K = 0;; ) {
        if (K === D.length) {
          if (K < X.part.length) {
            let A = L62(X, X.part.slice(K));
            Object.assign(X, _12(D, [A]));
          }
          break;
        }
        if (K === X.part.length) {
          if (X.inert === null)
            X.inert = new Map;
          else if (X.inert.has(D.charCodeAt(K))) {
            X = X.inert.get(D.charCodeAt(K)), D = D.slice(K), K = 0;
            continue;
          }
          let A = _12(D.slice(K));
          X.inert.set(D.charCodeAt(K), A), X = A;
          break;
        }
        if (D[K] !== X.part[K]) {
          let A = L62(X, X.part.slice(K)), I = _12(D.slice(K));
          Object.assign(X, _12(X.part.slice(0, K), [A, I])), X = I;
          break;
        }
        ++K;
      }
    }
    if (q < J.length) {
      let F = J[q], D = F.slice(1);
      if (X.params === null)
        X.params = C62(D);
      else if (X.params.paramName !== D)
        throw Error(`Cannot create route "${Y}" with parameter "${D}" because a route already exists with a different parameter name ("${X.params.paramName}") in the same location`);
      return X.params.store === null && (X.params.store = W), X.params.store;
    }
    return Z ? (X.wildcardStore === null && (X.wildcardStore = W), X.wildcardStore) : (X.store === null && (X.store = W), X.store);
  }
  find($, Y) {
    let W = this.root[$];
    return W ? r$2(Y, Y.length, W, 0) : null;
  }
}
var r$2 = ($, Y, W, X) => {
  let Z = W?.part, Q = X + Z.length;
  if (Z.length > 1) {
    if (Q > Y)
      return null;
    if (Z.length < 15) {
      for (let J = 1, q = X + 1;J < Z.length; ++J, ++q)
        if (Z.charCodeAt(J) !== $.charCodeAt(q))
          return null;
    } else if ($.substring(X, Q) !== Z)
      return null;
  }
  if (Q === Y)
    return W.store !== null ? { store: W.store, params: {} } : W.wildcardStore !== null ? { store: W.wildcardStore, params: { "*": "" } } : null;
  if (W.inert !== null) {
    let J = W.inert.get($.charCodeAt(Q));
    if (J !== undefined) {
      let q = r$2($, Y, J, Q);
      if (q !== null)
        return q;
    }
  }
  if (W.params !== null) {
    let J = W.params, q = $.indexOf("/", Q);
    if (q !== Q) {
      if (q === -1 || q >= Y) {
        if (J.store !== null) {
          let F = {};
          return F[J.paramName] = $.substring(Q, Y), { store: J.store, params: F };
        }
      } else if (J.inert !== null) {
        let F = r$2($, Y, J.inert, q);
        if (F !== null)
          return F.params[J.paramName] = $.substring(Q, q), F;
      }
    }
  }
  return W.wildcardStore !== null ? { store: W.wildcardStore, params: { "*": $.substring(Q, Y) } } : null;
};
var b62 = X12(R62(), 1);
var G62 = b62.default;
var _62 = ($, Y) => {
  return (W) => {
    const X = W.id;
    if (W.event === "request" && W.type === "begin") {
      const Z = () => {
        let N, L, O = -1;
        const U = [], w = [];
        let R = false;
        const b = new Promise((n) => {
          N = (o) => {
            if (R)
              return;
            else
              R = true;
            n(o);
          };
        });
        let V = false;
        const G = new Promise((n) => {
          L = (o) => {
            if (V)
              return;
            else
              V = true;
            if (O === -1)
              O = 0;
            for (;O < w.length; O++) {
              let $0;
              const h0 = { name: "anonymous", time: performance.now(), skip: true, end: new Promise((w0) => {
                w0($0);
              }), children: [] };
              $0 = performance.now(), U[O](h0);
            }
            n(o);
          };
        });
        return { signal: b, consumeChild(n) {
          switch (n.type) {
            case "begin":
              U[++O]({ name: n.name, time: n.time, skip: false, end: new Promise((o) => {
                w.push(o);
              }) });
              break;
            case "end":
              w[O](n.time);
              break;
          }
        }, consume(n) {
          switch (n.type) {
            case "begin":
              const o = [], $0 = n.unit ?? 0;
              for (let h0 = 0;h0 < $0; h0++) {
                let w0;
                o.push(new Promise((k0) => {
                  w0 = k0;
                })), U.push(w0);
              }
              N({ name: n.name, time: n.time, skip: false, end: G, children: o });
              break;
            case "end":
              L(n.time);
              break;
          }
        }, resolve() {
          if (R && V)
            return;
          let n;
          const o = { name: "anonymous", time: performance.now(), skip: true, end: new Promise(($0) => {
            $0(n);
          }), children: [] };
          n = performance.now(), N(o), L(n);
        } };
      }, Q = Z(), J = Z(), q = Z(), F = Z(), D = Z(), K = Z(), A = Z(), I = Z();
      Q.consume(W);
      const j = (N) => {
        if (N.id === X)
          switch (N.event) {
            case "request":
              Q.consume(N);
              break;
            case "request.unit":
              Q.consumeChild(N);
              break;
            case "parse":
              J.consume(N);
              break;
            case "parse.unit":
              J.consumeChild(N);
              break;
            case "transform":
              q.consume(N);
              break;
            case "transform.unit":
              q.consumeChild(N);
              break;
            case "beforeHandle":
              F.consume(N);
              break;
            case "beforeHandle.unit":
              F.consumeChild(N);
              break;
            case "handle":
              D.consume(N);
              break;
            case "afterHandle":
              K.consume(N);
              break;
            case "afterHandle.unit":
              K.consumeChild(N);
              break;
            case "error":
              A.consume(N);
              break;
            case "error.unit":
              A.consumeChild(N);
              break;
            case "response":
              if (N.type === "begin")
                Q.resolve(), J.resolve(), q.resolve(), F.resolve(), D.resolve(), K.resolve(), A.resolve();
              else
                $.off("event", j);
              I.consume(N);
              break;
            case "response.unit":
              I.consumeChild(N);
              break;
          }
      };
      $.on("event", j), Y({ id: W.id, context: W.ctx, set: W.ctx?.set, store: W.ctx?.store, time: W.time, request: Q.signal, parse: J.signal, transform: q.signal, beforeHandle: F.signal, handle: D.signal, afterHandle: K.signal, error: A.signal, response: I.signal });
    }
  };
};
var Y62 = X12($62(), 1);
var HW2 = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var o12 = Symbol("ErrorCode");
var M$2 = (HW2?.NODE_ENV ?? HW2?.ENV) === "production";

class f$2 extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor($) {
    super($ ?? "INTERNAL_SERVER_ERROR");
  }
}

class O1 extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor($) {
    super($ ?? "NOT_FOUND");
  }
}
class N$2 extends Error {
  $;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor($, Y) {
    super(Y ?? `"${$}" has invalid cookie signature`);
    this.key = $;
  }
}

class j02 extends Error {
  $;
  Y;
  W;
  code = "VALIDATION";
  status = 400;
  constructor($, Y, W) {
    const X = M$2 ? undefined : Y.Errors(W).First(), Z = X?.schema.error ? typeof X.schema.error === "function" ? X.schema.error($, Y, W) : X.schema.error : undefined, Q = M$2 ? Z ?? `Invalid ${$ ?? X?.schema.error ?? X?.message}` : Z ?? `Invalid ${$}, '${X?.path?.slice(1) || "type"}': ${X?.message}` + "\n\nExpected: " + JSON.stringify(Y62.Value.Create(Y.schema), null, 2) + "\n\nFound: " + JSON.stringify(W, null, 2);
    super(Q);
    this.type = $;
    this.validator = Y;
    this.value = W;
    Object.setPrototypeOf(this, j02.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  get model() {
    return Y62.Value.Create(this.validator.schema);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: $ });
  }
}
var W62 = { open($) {
  $.data.open?.($);
}, message($, Y) {
  $.data.message?.($, Y);
}, drain($) {
  $.data.drain?.($);
}, close($, Y, W) {
  $.data.close?.($, Y, W);
} };

class c12 {
  $;
  Y;
  validator;
  constructor($, Y) {
    this.raw = $;
    this.data = Y;
    this.validator = $.data.validator;
  }
  publish($, Y = undefined, W) {
    if (this.validator?.Check(Y) === false)
      throw new j02("message", this.validator, Y);
    if (typeof Y === "object")
      Y = JSON.stringify(Y);
    return this.raw.publish($, Y, W), this;
  }
  send($) {
    if (this.validator?.Check($) === false)
      throw new j02("message", this.validator, $);
    if (typeof $ === "object")
      $ = JSON.stringify($);
    return this.raw.send($), this;
  }
  subscribe($) {
    return this.raw.subscribe($), this;
  }
  unsubscribe($) {
    return this.raw.unsubscribe($), this;
  }
  cork($) {
    return this.raw.cork($), this;
  }
  close() {
    return this.raw.close(), this;
  }
  terminate() {
    this.raw.terminate();
  }
  isSubscribed($) {
    return this.raw.isSubscribed($);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
}
var n92 = function($, Y) {
  if (typeof $ !== "string")
    throw new TypeError("argument str must be a string");
  var W = {}, X = Y || {}, Z = X.decode || c92, Q = 0;
  while (Q < $.length) {
    var J = $.indexOf("=", Q);
    if (J === -1)
      break;
    var q = $.indexOf(";", Q);
    if (q === -1)
      q = $.length;
    else if (q < J) {
      Q = $.lastIndexOf(";", J - 1) + 1;
      continue;
    }
    var F = $.slice(Q, J).trim();
    if (W[F] === undefined) {
      var D = $.slice(J + 1, q).trim();
      if (D.charCodeAt(0) === 34)
        D = D.slice(1, -1);
      W[F] = s92(D, Z);
    }
    Q = q + 1;
  }
  return W;
};
var o92 = function($, Y, W) {
  var X = W || {}, Z = X.encode || l92;
  if (typeof Z !== "function")
    throw new TypeError("option encode is invalid");
  if (!T$2.test($))
    throw new TypeError("argument name is invalid");
  var Q = Z(Y);
  if (Q && !T$2.test(Q))
    throw new TypeError("argument val is invalid");
  var J = $ + "=" + Q;
  if (X.maxAge != null) {
    var q = X.maxAge - 0;
    if (isNaN(q) || !isFinite(q))
      throw new TypeError("option maxAge is invalid");
    J += "; Max-Age=" + Math.floor(q);
  }
  if (X.domain) {
    if (!T$2.test(X.domain))
      throw new TypeError("option domain is invalid");
    J += "; Domain=" + X.domain;
  }
  if (X.path) {
    if (!T$2.test(X.path))
      throw new TypeError("option path is invalid");
    J += "; Path=" + X.path;
  }
  if (X.expires) {
    var F = X.expires;
    if (!t92(F) || isNaN(F.valueOf()))
      throw new TypeError("option expires is invalid");
    J += "; Expires=" + F.toUTCString();
  }
  if (X.httpOnly)
    J += "; HttpOnly";
  if (X.secure)
    J += "; Secure";
  if (X.priority) {
    var D = typeof X.priority === "string" ? X.priority.toLowerCase() : X.priority;
    switch (D) {
      case "low":
        J += "; Priority=Low";
        break;
      case "medium":
        J += "; Priority=Medium";
        break;
      case "high":
        J += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (X.sameSite) {
    var K = typeof X.sameSite === "string" ? X.sameSite.toLowerCase() : X.sameSite;
    switch (K) {
      case true:
        J += "; SameSite=Strict";
        break;
      case "lax":
        J += "; SameSite=Lax";
        break;
      case "strict":
        J += "; SameSite=Strict";
        break;
      case "none":
        J += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return J;
};
var c92 = function($) {
  return $.indexOf("%") !== -1 ? decodeURIComponent($) : $;
};
var l92 = function($) {
  return encodeURIComponent($);
};
var t92 = function($) {
  return h92.call($) === "[object Date]" || $ instanceof Date;
};
var s92 = function($, Y) {
  try {
    return Y($);
  } catch (W) {
    return $;
  }
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var d$2 = n92;
var y$2 = o92;
var h92 = Object.prototype.toString;
var T$2 = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
var i$2 = X12(f02(), 1);
var B$2 = X12($62(), 1);
var H62 = X12(AW2(), 1);
var z62 = ($) => $ && typeof $ === "object" && !Array.isArray($);
var J72 = ($) => typeof $ === "function" && /^\s*class\s+/.test($.toString()) || $.toString() === "[object Module]";
var N1 = ($, Y, { skipKeys: W } = {}) => {
  if (z62($) && z62(Y))
    for (let [X, Z] of Object.entries(Y)) {
      if (W?.includes(X))
        continue;
      if (!z62(Z)) {
        $[X] = Z;
        continue;
      }
      if (!(X in $)) {
        $[X] = Z;
        continue;
      }
      if (J72(Z)) {
        $[X] = Z;
        continue;
      }
      console.log("B"), $[X] = N1($[X], Z);
    }
  return $;
};
var DW2 = ($, Y) => N1($, Y, { skipKeys: ["properties"] });
var P02 = ($, Y) => {
  const W = [...Array.isArray($) ? $ : [$]], X = [];
  for (let Z of W)
    if (Z.$elysiaChecksum)
      X.push(Z.$elysiaChecksum);
  for (let Z of Array.isArray(Y) ? Y : [Y])
    if (!X.includes(Z?.$elysiaChecksum))
      W.push(Z);
  return W;
};
var L1 = ($, Y) => {
  return { body: Y?.body ?? $?.body, headers: Y?.headers ?? $?.headers, params: Y?.params ?? $?.params, query: Y?.query ?? $?.query, response: Y?.response ?? $?.response, type: $?.type || Y?.type, detail: N1(Y?.detail ?? {}, $?.detail ?? {}), parse: P02($?.parse ?? [], Y?.parse ?? []), transform: P02($?.transform ?? [], Y?.transform ?? []), beforeHandle: P02($?.beforeHandle ?? [], Y?.beforeHandle ?? []), afterHandle: P02($?.afterHandle ?? [], Y?.afterHandle ?? []), onResponse: P02($?.onResponse ?? [], Y?.onResponse ?? []), trace: P02($?.trace ?? [], Y?.trace ?? []), error: P02($?.error ?? [], Y?.error ?? []) };
};
var U12 = ($, { models: Y = {}, additionalProperties: W = false, dynamic: X = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Y))
    return;
  const Z = typeof $ === "string" ? Y[$] : $;
  if (Z.type === "object" && ("additionalProperties" in Z) === false)
    Z.additionalProperties = W;
  if (X)
    return { schema: Z, references: "", checkFunc: () => {
    }, code: "", Check: (Q) => B$2.Value.Check(Z, Q), Errors: (Q) => B$2.Value.Errors(Z, Q), Code: () => "" };
  return H62.TypeCompiler.Compile(Z);
};
var q62 = ($, { models: Y = {}, additionalProperties: W = false, dynamic: X = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Y))
    return;
  const Z = typeof $ === "string" ? Y[$] : $, Q = (q) => {
    if (X)
      return { schema: q, references: "", checkFunc: () => {
      }, code: "", Check: (F) => B$2.Value.Check(q, F), Errors: (F) => B$2.Value.Errors(q, F), Code: () => "" };
    return H62.TypeCompiler.Compile(q);
  };
  if (i$2.Kind in Z) {
    if (("additionalProperties" in Z) === false)
      Z.additionalProperties = W;
    return { 200: Q(Z) };
  }
  const J = {};
  return Object.keys(Z).forEach((q) => {
    const F = Z[+q];
    if (typeof F === "string") {
      if (F in Y) {
        const D = Y[F];
        D.type === "object" && ("additionalProperties" in D), J[+q] = (i$2.Kind in D) ? Q(D) : D;
      }
      return;
    }
    if (F.type === "object" && ("additionalProperties" in F) === false)
      F.additionalProperties = W;
    J[+q] = (i$2.Kind in F) ? Q(F) : F;
  }), J;
};
var M62 = ($) => {
  let Y = 9;
  for (let W = 0;W < $.length; )
    Y = Math.imul(Y ^ $.charCodeAt(W++), 387420489);
  return Y = Y ^ Y >>> 9;
};
var m$2 = ($, Y, W) => {
  const X = (Z) => {
    if (W)
      Z.$elysiaChecksum = W;
    return Z;
  };
  return { start: P02($.start, ("start" in Y ? Y.start ?? [] : []).map(X)), request: P02($.request, ("request" in Y ? Y.request ?? [] : []).map(X)), parse: P02($.parse, "parse" in Y ? Y?.parse ?? [] : []).map(X), transform: P02($.transform, (Y?.transform ?? []).map(X)), beforeHandle: P02($.beforeHandle, (Y?.beforeHandle ?? []).map(X)), afterHandle: P02($.afterHandle, (Y?.afterHandle ?? []).map(X)), onResponse: P02($.onResponse, (Y?.onResponse ?? []).map(X)), trace: P02($.trace, ("trace" in Y ? Y.trace ?? [] : []).map(X)), error: P02($.error, (Y?.error ?? []).map(X)), stop: P02($.stop, ("stop" in Y ? Y.stop ?? [] : []).map(X)) };
};
var wW2 = ($, Y = true) => {
  if (!$)
    return $;
  if (typeof $ === "function") {
    if (Y)
      $.$elysiaHookType = "global";
    else
      $.$elysiaHookType = undefined;
    return $;
  }
  return $.map((W) => {
    if (Y)
      W.$elysiaHookType = "global";
    else
      W.$elysiaHookType = undefined;
    return W;
  });
};
var l12 = ($) => {
  if (!$)
    return $;
  if (typeof $ === "function")
    return $.$elysiaHookType === "global" ? $ : undefined;
  return $.filter((Y) => Y.$elysiaHookType === "global");
};
var N62 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: l12($?.parse), transform: l12($?.transform), beforeHandle: l12($?.beforeHandle), afterHandle: l12($?.afterHandle), onResponse: l12($?.onResponse), error: l12($?.error) };
};
var U62 = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var KW2 = import.meta.require("crypto");
var C12 = function($, Y) {
  if (typeof $ != "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (Y == null)
    throw new TypeError("Secret key must be provided.");
  return $ + "." + KW2.createHmac("sha256", Y).update($).digest("base64").replace(/\=+$/, "");
};
var u$2 = function($, Y) {
  if (typeof $ != "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (Y == null)
    throw new TypeError("Secret key must be provided.");
  var W = $.slice(0, $.lastIndexOf(".")), X = C12(W, Y), Z = Buffer.from(X), Q = Buffer.from($);
  return Z.length === Q.length && KW2.timingSafeEqual(Z, Q) ? W : false;
};

class s02 {
  $;
  Y;
  name;
  setter;
  constructor($, Y = {}) {
    this._value = $;
    this.property = Y;
  }
  get() {
    return this._value;
  }
  get value() {
    return this._value;
  }
  set value($) {
    if (typeof $ === "object") {
      if (JSON.stringify(this.value) === JSON.stringify($))
        return;
    } else if (this.value === $)
      return;
    this._value = $, this.sync();
  }
  add($) {
    const Y = Object.assign(this.property, typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $);
    if ("value" in Y)
      this._value = Y.value, delete Y.value;
    return this.property = Y, this.sync();
  }
  set($) {
    const Y = typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $;
    if ("value" in Y)
      this._value = Y.value, delete Y.value;
    return this.property = Y, this.sync();
  }
  remove() {
    if (this.value === undefined)
      return;
    this.set({ value: "", expires: new Date });
  }
  get domain() {
    return this.property.domain;
  }
  set domain($) {
    this.property.domain = $, this.sync();
  }
  get expires() {
    return this.property.expires;
  }
  set expires($) {
    this.property.expires = $, this.sync();
  }
  get httpOnly() {
    return this.property.httpOnly;
  }
  set httpOnly($) {
    this.property.httpOnly = $, this.sync();
  }
  get maxAge() {
    return this.property.maxAge;
  }
  set maxAge($) {
    this.property.maxAge = $, this.sync();
  }
  get path() {
    return this.property.path;
  }
  set path($) {
    this.property.path = $, this.sync();
  }
  get priority() {
    return this.property.priority;
  }
  set priority($) {
    this.property.priority = $, this.sync();
  }
  get sameSite() {
    return this.property.sameSite;
  }
  set sameSite($) {
    this.property.sameSite = $, this.sync();
  }
  get secure() {
    return this.property.secure;
  }
  set secure($) {
    this.property.secure = $, this.sync();
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
  sync() {
    if (!this.name || !this.setter)
      return this;
    if (!this.setter.cookie)
      this.setter.cookie = { [this.name]: Object.assign(this.property, { value: this.toString() }) };
    else
      this.setter.cookie[this.name] = Object.assign(this.property, { value: this.toString() });
    return this;
  }
}
var jW2 = ($, Y) => new Proxy($, { get(W, X) {
  if (X in W)
    return W[X];
  const Z = new s02(undefined);
  return Z.setter = Y, Z.name = X, Z;
}, set(W, X, Z) {
  if (!(Z instanceof s02))
    return false;
  if (!Y.cookie)
    Y.cookie = {};
  return Z.setter = Y, Z.name = X, Z.sync(), W[X] = Z, true;
} });
var h$2 = ($, Y, { secret: W, sign: X } = {}) => {
  if (!Y)
    return jW2({}, $);
  const Z = {}, Q = typeof W === "string";
  if (X && X !== true && !Array.isArray(X))
    X = [X];
  const J = Object.keys(d$2(Y));
  for (let q = 0;q < J.length; q++) {
    const F = J[q];
    let D = d$2(Y)[F];
    if (X === true || X?.includes(F)) {
      if (!W)
        throw new Error("No secret is provided to cookie plugin");
      if (Q) {
        if (D = u$2(D, W), D === false)
          throw new N$2(F);
      } else {
        let I = true;
        for (let j = 0;j < W.length; j++) {
          const N = u$2(D, W[j]);
          if (N !== false) {
            D = N, I = false;
            break;
          }
        }
        if (I)
          throw new N$2(F);
      }
    }
    const K = D.charCodeAt(0);
    if (K === 123 || K === 91)
      try {
        const I = new s02(JSON.parse(D));
        I.setter = $, I.name = F, Z[F] = I;
        continue;
      } catch {
      }
    if (!Number.isNaN(+D))
      D = +D;
    else if (D === "true")
      D = true;
    else if (D === "false")
      D = false;
    const A = new s02(D);
    A.setter = $, A.name = F, Z[F] = A;
  }
  return jW2(Z, $);
};
var PW2 = "toJSON" in new Headers;
var I12 = ($) => {
  for (let Y in $)
    return true;
  return false;
};
var OW2 = ($, Y) => {
  if (!$ || !Array.isArray(Y))
    return $;
  $.delete("Set-Cookie");
  for (let W = 0;W < Y.length; W++) {
    const X = Y[W].indexOf("=");
    $.append("Set-Cookie", `${Y[W].slice(0, X)}=${Y[W].slice(X + 1)}`);
  }
  return $;
};
var SW2 = ($) => {
  if (!$ || typeof $ !== "object" || !I12($))
    return;
  const Y = [];
  for (let [W, X] of Object.entries($)) {
    if (!W || !X)
      continue;
    if (Array.isArray(X.value))
      for (let Z = 0;Z < X.value.length; Z++) {
        let Q = X.value[Z];
        if (Q === undefined || Q === null)
          continue;
        if (typeof Q === "object")
          Q = JSON.stringify(Q);
        Y.push(y$2(W, Q, X));
      }
    else {
      let Z = X.value;
      if (Z === undefined || Z === null)
        continue;
      if (typeof Z === "object")
        Z = JSON.stringify(Z);
      Y.push(y$2(W, X.value, X));
    }
  }
  if (Y.length === 0)
    return;
  if (Y.length === 1)
    return Y[0];
  return Y;
};
var F12 = ($, Y) => {
  if (I12(Y.headers) || Y.status !== 200 || Y.redirect || Y.cookie) {
    if (typeof Y.status === "string")
      Y.status = U62[Y.status];
    if (Y.redirect) {
      if (Y.headers.Location = Y.redirect, !Y.status || Y.status < 300 || Y.status >= 400)
        Y.status = 302;
    }
    if (Y.cookie && I12(Y.cookie))
      Y.headers["Set-Cookie"] = SW2(Y.cookie);
    if (Y.headers["Set-Cookie"] && Array.isArray(Y.headers["Set-Cookie"]))
      Y.headers = OW2(new Headers(Y.headers), Y.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, { status: Y.status, headers: Y.headers });
      case "Object":
      case "Array":
        return Response.json($, Y);
      case undefined:
        if (!$)
          return new Response("", Y);
        return Response.json($, Y);
      case "Response":
        const W = { ...Y.headers };
        if (PW2)
          Y.headers = $.headers.toJSON();
        else
          for (let [Z, Q] of $.headers.entries())
            if (Z in Y.headers)
              Y.headers[Z] = Q;
        for (let Z in W)
          $.headers.append(Z, W[Z]);
        return $;
      case "Error":
        return A$2($, Y);
      case "Promise":
        return $.then((Z) => F12(Z, Y));
      case "Function":
        return F12($(), Y);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Y);
      case "Cookie":
        if ($ instanceof s02)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123) {
          if (!Y.headers["Content-Type"])
            Y.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Y);
        }
        return new Response(X, Y);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Error":
        return A$2($, Y);
      case "Promise":
        return $.then((X) => {
          const Z = w1(X);
          if (Z !== undefined)
            return Z;
          return new Response("");
        });
      case "Function":
        return w1($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof s02)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(W);
    }
};
var r02 = ($, Y) => {
  if ($ === undefined || $ === null)
    return;
  if (I12(Y.headers) || Y.status !== 200 || Y.redirect || Y.cookie) {
    if (typeof Y.status === "string")
      Y.status = U62[Y.status];
    if (Y.redirect) {
      if (Y.headers.Location = Y.redirect, !Y.status || Y.status < 300 || Y.status >= 400)
        Y.status = 302;
    }
    if (Y.cookie && I12(Y.cookie))
      Y.headers["Set-Cookie"] = SW2(Y.cookie);
    if (Y.headers["Set-Cookie"] && Array.isArray(Y.headers["Set-Cookie"]))
      Y.headers = OW2(new Headers(Y.headers), Y.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($, Y);
      case "Object":
      case "Array":
        return Response.json($, Y);
      case undefined:
        if (!$)
          return;
        return Response.json($, Y);
      case "Response":
        const W = Object.assign({}, Y.headers);
        if (PW2)
          Y.headers = $.headers.toJSON();
        else
          for (let [Z, Q] of $.headers.entries())
            if (!(Z in Y.headers))
              Y.headers[Z] = Q;
        for (let Z in W)
          $.headers.append(Z, W[Z]);
        if ($.status !== Y.status)
          Y.status = $.status;
        return $;
      case "Promise":
        return $.then((Z) => {
          const Q = r02(Z, Y);
          if (Q !== undefined)
            return Q;
          return;
        });
      case "Error":
        return A$2($, Y);
      case "Function":
        return r02($(), Y);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Y);
      case "Cookie":
        if ($ instanceof s02)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123) {
          if (!Y.headers["Content-Type"])
            Y.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Y);
        }
        return new Response(X, Y);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
      case "Blob":
        return new Response($);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Promise":
        return $.then((X) => {
          const Z = r02(X, Y);
          if (Z !== undefined)
            return Z;
          return;
        });
      case "Error":
        return A$2($, Y);
      case "Function":
        return w1($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof s02)
          return new Response($.value, Y);
        return new Response($?.toString(), Y);
      default:
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(W);
    }
};
var w1 = ($) => {
  switch ($?.constructor?.name) {
    case "String":
    case "Blob":
      return new Response($);
    case "Object":
    case "Array":
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      return $;
    case "Error":
      return A$2($);
    case "Promise":
      return $.then((W) => {
        const X = w1(W);
        if (X !== undefined)
          return X;
        return new Response("");
      });
    case "Function":
      return w1($());
    case "Number":
    case "Boolean":
      return new Response($.toString());
    default:
      const Y = JSON.stringify($);
      if (Y.charCodeAt(0) === 123)
        return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      return new Response(Y);
  }
};
var A$2 = ($, Y) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: Y?.status !== 200 ? Y?.status ?? 500 : 500, headers: Y?.headers });
var pW2 = X12(A62(), 1);
var B72 = new Headers().toJSON;
var iW2 = new RegExp(" (\\w+) = context", "g");
var mW2 = { value: 0 };
var uW2 = ({ hasTrace: $, hasTraceSet: Y = false, hasTraceChildren: W = false, addFn: X, condition: Z = {} }) => {
  if ($) {
    const Q = W ? "\nawait new Promise(r => {queueMicrotask(() => queueMicrotask(r))})\n" : "\nawait new Promise(r => {queueMicrotask(r)})\n";
    return (J, { name: q, attribute: F = "", unit: D = 0 } = {}) => {
      const K = J.indexOf("."), A = K === -1;
      if (J !== "request" && J !== "response" && !Z[A ? J : J.slice(0, K)])
        return () => {
          if (Y && J === "afterHandle")
            X(Q);
        };
      if (A)
        q ||= J;
      else
        q ||= "anonymous";
      X("\n" + `reporter.emit('event', { 
					id,
					event: '${J}',
					type: 'begin',
					name: '${q}',
					time: performance.now(),
					${A ? `unit: ${D},` : ""}
					${F}
				})`.replace(/(\t| |\n)/g, "") + "\n");
      let I = false;
      return () => {
        if (I)
          return;
        if (I = true, X("\n" + `reporter.emit('event', {
							id,
							event: '${J}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + "\n"), Y && J === "afterHandle")
          X(Q);
      };
    };
  } else
    return () => () => {
    };
};
var w$2 = ($) => {
  const Y = $.indexOf(")");
  if ($.charCodeAt(Y + 2) === 61 && $.charCodeAt(Y + 5) !== 123)
    return true;
  return $.includes("return");
};
var A72 = ($, { injectResponse: Y = "" } = {}) => ({ composeValidation: (W, X = `c.${W}`) => $ ? `c.set.status = 400; throw new ValidationError(
'${W}',
${W},
${X}
)` : `c.set.status = 400; return new ValidationError(
	'${W}',
	${W},
	${X}
).toResponse(c.set.headers)`, composeResponseValidation: (W = "r") => {
  const X = $ ? `throw new ValidationError(
'response',
response[c.set.status],
${W}
)` : `return new ValidationError(
'response',
response[c.set.status],
${W}
).toResponse(c.set.headers)`;
  return `\n${Y}
		if(response[c.set.status]?.Check(${W}) === false) { 
	if(!(response instanceof Error))
		${X}
}\n`;
} });
var O02 = ($, Y) => {
  if (Y = Y.trimStart(), Y = Y.replaceAll(/^async /g, ""), /^(\w+)\(/g.test(Y))
    Y = Y.slice(Y.indexOf("("));
  const W = Y.charCodeAt(0) === 40 || Y.startsWith("function") ? Y.slice(Y.indexOf("(") + 1, Y.indexOf(")")) : Y.slice(0, Y.indexOf("=") - 1);
  if (W === "")
    return false;
  const X = W.charCodeAt(0) === 123 ? W.indexOf("...") : -1;
  if (W.charCodeAt(0) === 123) {
    if (W.includes($))
      return true;
    if (X === -1)
      return false;
  }
  if (Y.match(new RegExp(`${W}(.${$}|\\["${$}"\\])`)))
    return true;
  const Z = X !== -1 ? W.slice(X + 3, W.indexOf(" ", X + 3)) : undefined;
  if (Y.match(new RegExp(`${Z}(.${$}|\\["${$}"\\])`)))
    return true;
  const Q = [W];
  if (Z)
    Q.push(Z);
  for (let q of Y.matchAll(iW2))
    Q.push(q[1]);
  const J = new RegExp(`{.*?} = (${Q.join("|")})`, "g");
  for (let [q] of Y.matchAll(J))
    if (q.includes(`{ ${$}`) || q.includes(`, ${$}`))
      return true;
  return false;
};
var s12 = ($) => {
  if ($ = $.trimStart(), $ = $.replaceAll(/^async /g, ""), /^(\w+)\(/g.test($))
    $ = $.slice($.indexOf("("));
  const Y = $.charCodeAt(0) === 40 || $.startsWith("function") ? $.slice($.indexOf("(") + 1, $.indexOf(")")) : $.slice(0, $.indexOf("=") - 1);
  if (Y === "")
    return false;
  const W = Y.charCodeAt(0) === 123 ? Y.indexOf("...") : -1, X = W !== -1 ? Y.slice(W + 3, Y.indexOf(" ", W + 3)) : undefined, Z = [Y];
  if (X)
    Z.push(X);
  for (let J of $.matchAll(iW2))
    Z.push(J[1]);
  for (let J of Z)
    if (new RegExp(`\\b\\w+\\([^)]*\\b${J}\\b[^)]*\\)`).test($))
      return true;
  const Q = new RegExp(`{.*?} = (${Z.join("|")})`, "g");
  for (let [J] of $.matchAll(Q))
    if (new RegExp(`\\b\\w+\\([^)]*\\b${J}\\b[^)]*\\)`).test($))
      return true;
  return false;
};
var t12 = Symbol.for("TypeBox.Kind");
var n$2 = ($, Y) => {
  if (!Y)
    return;
  if ((t12 in Y) && Y[t12] === $)
    return true;
  if (Y.type === "object") {
    const W = Y.properties;
    for (let X of Object.keys(W)) {
      const Z = W[X];
      if (Z.type === "object") {
        if (n$2($, Z))
          return true;
      } else if (Z.anyOf) {
        for (let Q = 0;Q < Z.anyOf.length; Q++)
          if (n$2($, Z.anyOf[Q]))
            return true;
      }
      if ((t12 in Z) && Z[t12] === $)
        return true;
    }
    return false;
  }
  return Y.properties && (t12 in Y.properties) && Y.properties[t12] === $;
};
var D62 = Symbol.for("TypeBox.Transform");
var R12 = ($) => {
  if (!$)
    return;
  if ($.type === "object") {
    const Y = $.properties;
    for (let W of Object.keys(Y)) {
      const X = Y[W];
      if (X.type === "object") {
        if (R12(X))
          return true;
      } else if (X.anyOf) {
        for (let Q = 0;Q < X.anyOf.length; Q++)
          if (R12(X.anyOf[Q]))
            return true;
      }
      if (D62 in X)
        return true;
    }
    return false;
  }
  return (D62 in $) || $.properties && (D62 in $.properties);
};
var D72 = ($) => {
  if (!$)
    return;
  const Y = $?.schema;
  if (Y && ("anyOf" in Y)) {
    let W = false;
    const X = Y.anyOf[0].type;
    for (let Z of Y.anyOf)
      if (Z.type !== X) {
        W = true;
        break;
      }
    if (!W)
      return X;
  }
  return $.schema?.type;
};
var w72 = /(?:return|=>) \S*\(/g;
var q02 = ($) => {
  if ($.constructor.name === "AsyncFunction")
    return true;
  return $.toString().match(w72);
};
var hW2 = ({ path: $, method: Y, hooks: W, validator: X, handler: Z, handleError: Q, definitions: J, schema: q, onRequest: F, config: D, reporter: K }) => {
  const A = D.forceErrorEncapsulation || W.error.length > 0 || typeof Bun === "undefined" || W.onResponse.length > 0 || !!W.trace.length, I = W.onResponse.length ? `\n;(async () => {${W.onResponse.map((E, d) => `await res${d}(c)`).join(";")}})();\n` : "", j = W.trace.map((E) => E.toString());
  let N = false;
  if (s12(Z.toString()))
    N = true;
  if (!N)
    for (let [E, d] of Object.entries(W)) {
      if (!Array.isArray(d) || !d.length || !["parse", "transform", "beforeHandle", "afterHandle", "onResponse"].includes(E))
        continue;
      for (let u of d) {
        if (typeof u !== "function")
          continue;
        if (s12(u.toString())) {
          N = true;
          break;
        }
      }
      if (N)
        break;
    }
  const L = { parse: j.some((E) => O02("parse", E)), transform: j.some((E) => O02("transform", E)), handle: j.some((E) => O02("handle", E)), beforeHandle: j.some((E) => O02("beforeHandle", E)), afterHandle: j.some((E) => O02("afterHandle", E)), error: A || j.some((E) => O02("error", E)) }, O = W.trace.length > 0;
  let U = "";
  if (O)
    U += "\nconst id = c.$$requestId\n";
  U += A ? "try {\n" : "";
  const w = X || Y !== "GET" && Y !== "HEAD" ? [Z, ...W.transform, ...W.beforeHandle, ...W.afterHandle].map((E) => E.toString()) : [], R = N || Y !== "GET" && Y !== "HEAD" && W.type !== "none" && (!!X.body || !!W.type || w.some((E) => O02("body", E))), b = N || X.headers || w.some((E) => O02("headers", E)), V = N || X.cookie || w.some((E) => O02("cookie", E)), G = X?.cookie?.schema;
  let n = "";
  if (G?.sign) {
    if (!G.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${Y}) ${$}.`);
    const E = !G.secrets ? undefined : typeof G.secrets === "string" ? G.secrets : G.secrets[0];
    if (n += `const _setCookie = c.set.cookie
		if(_setCookie) {`, G.sign === true)
      n += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = signCookie(cookie.value, '${E}')
			}`;
    else
      for (let d of G.sign)
        n += `if(_setCookie['${d}']?.value) { c.set.cookie['${d}'].value = signCookie(_setCookie['${d}'].value, '${E}') }\n`;
    n += "}\n";
  }
  const { composeValidation: o, composeResponseValidation: $0 } = A72(A);
  if (b)
    U += B72 ? "c.headers = c.request.headers.toJSON()\n" : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  if (V) {
    const E = G ? `{
			secret: ${G.secrets !== undefined ? typeof G.secrets === "string" ? `'${G.secrets}'` : "[" + G.secrets.reduce((d, u) => d + `'${u}',`, "") + "]" : "undefined"},
			sign: ${G.sign === true ? true : G.sign !== undefined ? "[" + G.sign.reduce((d, u) => d + `'${u}',`, "") + "]" : "undefined"}
		}` : "undefined";
    if (b)
      U += `\nc.cookie = parseCookie(c.set, c.headers.cookie, ${E})\n`;
    else
      U += `\nc.cookie = parseCookie(c.set, c.request.headers.get('cookie'), ${E})\n`;
  }
  if (N || X.query || w.some((E) => O02("query", E)))
    U += `const url = c.request.url

		if(c.qi !== -1) {
			c.query ??= parseQuery(url.substring(c.qi + 1))
		} else {
			c.query ??= {}
		}
		`;
  const w0 = W.trace.map((E) => E.toString()), k0 = w0.some((E) => O02("set", E) || s12(E)), F0 = k0 && w0.some((E) => E.includes("children") || s12(E));
  N || W.trace.some((E) => O02("set", E.toString()));
  const v0 = k0 || V || w.some((E) => O02("set", E)) || F.some((E) => O02("set", E.toString())), z0 = uW2({ hasTrace: O, hasTraceSet: k0, hasTraceChildren: F0, condition: L, addFn: (E) => {
    U += E;
  } }), p0 = R || k0 || q02(Z) || W.parse.length > 0 || W.afterHandle.some(q02) || W.beforeHandle.some(q02) || W.transform.some(q02), g0 = z0("parse", { unit: W.parse.length });
  if (R) {
    const E = D72(X?.body);
    if (W.type && !Array.isArray(W.type)) {
      if (W.type)
        switch (W.type) {
          case "json":
          case "application/json":
            U += "c.body = await c.request.json()\n";
            break;
          case "text":
          case "text/plain":
            U += "c.body = await c.request.text()\n";
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            U += "c.body = parseQuery(await c.request.text())\n";
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            U += "c.body = await c.request.arrayBuffer()\n";
            break;
          case "formdata":
          case "multipart/form-data":
            U += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}\n`;
            break;
        }
      if (W.parse.length)
        U += "}}";
    } else {
      const u = (() => {
        if (W.parse.length && E && !Array.isArray(W.type)) {
          const t = X?.body?.schema;
          switch (E) {
            case "object":
              if (n$2("File", t) || n$2("Files", t))
                return `c.body = {}
		
								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue
			
									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
              break;
            default:
              break;
          }
        }
      })();
      if (u)
        U += u;
      else {
        if (U += "\n", U += b ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", U += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n`, W.parse.length) {
          U += "let used = false\n";
          const t = z0("parse", { unit: W.parse.length });
          for (let H0 = 0;H0 < W.parse.length; H0++) {
            const E0 = z0("parse.unit", { name: W.parse[H0].name }), D0 = `bo${H0}`;
            if (H0 !== 0)
              U += "if(!used) {\n";
            if (U += `let ${D0} = parse[${H0}](c, contentType)\n`, U += `if(${D0} instanceof Promise) ${D0} = await ${D0}\n`, U += `if(${D0} !== undefined) { c.body = ${D0}; used = true }\n`, E0(), H0 !== 0)
              U += "}";
          }
          t();
        }
        if (W.parse.length)
          U += "if (!used)";
        U += `
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break
				
					case 'text/plain':
						c.body = await c.request.text()
						break
				
					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break
				
					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break
				
					case 'multipart/form-data':
						c.body = {}
				
						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue
				
							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
				
						break
					}\n`, U += "}\n";
      }
    }
    U += "\n";
  }
  if (g0(), W?.transform) {
    const E = z0("transform", { unit: W.transform.length });
    for (let d = 0;d < W.transform.length; d++) {
      const u = W.transform[d], t = z0("transform.unit", { name: u.name });
      if (u.$elysia === "derive")
        U += q02(W.transform[d]) ? `Object.assign(c, await transform[${d}](c));` : `Object.assign(c, transform[${d}](c));`;
      else
        U += q02(W.transform[d]) ? `await transform[${d}](c);` : `transform[${d}](c);`;
      t();
    }
    E();
  }
  if (X) {
    if (U += "\n", X.headers) {
      if (U += `if(headers.Check(c.headers) === false) {
				${o("headers")}
			}`, R12(X.headers.schema))
        U += "\nc.headers = headers.Decode(c.headers)\n";
    }
    if (X.params) {
      if (U += `if(params.Check(c.params) === false) {
				${o("params")}
			}`, R12(X.params.schema))
        U += "\nc.params = params.Decode(c.params)\n";
    }
    if (X.query) {
      if (U += `if(query.Check(c.query) === false) {
				${o("query")} 
			}`, R12(X.query.schema))
        U += "\nc.query = query.Decode(Object.assign({}, c.query))\n";
    }
    if (X.body) {
      if (U += `if(body.Check(c.body) === false) { 
				${o("body")}
			}`, R12(X.body.schema))
        U += "\nc.body = body.Decode(c.body)\n";
    }
    if (X.cookie) {
      if (U += `const cookieValue = {}
			for(const [key, value] of Object.entries(c.cookie))
				cookieValue[key] = value.value

			if(cookie.Check(cookieValue) === false) {
				${o("cookie", "cookieValue")}
			}`, R12(X.cookie.schema))
        U += "\nc.cookie = params.Decode(c.cookie)\n";
    }
  }
  if (W?.beforeHandle) {
    const E = z0("beforeHandle", { unit: W.beforeHandle.length });
    for (let d = 0;d < W.beforeHandle.length; d++) {
      const u = z0("beforeHandle.unit", { name: W.beforeHandle[d].name }), t = `be${d}`;
      if (!w$2(W.beforeHandle[d].toString()))
        U += q02(W.beforeHandle[d]) ? `await beforeHandle[${d}](c);\n` : `beforeHandle[${d}](c);\n`, u();
      else {
        U += q02(W.beforeHandle[d]) ? `let ${t} = await beforeHandle[${d}](c);\n` : `let ${t} = beforeHandle[${d}](c);\n`, u(), U += `if(${t} !== undefined) {\n`;
        const E0 = z0("afterHandle", { unit: W.transform.length });
        if (W.afterHandle) {
          const D0 = t;
          for (let a = 0;a < W.afterHandle.length; a++) {
            const B12 = w$2(W.afterHandle[a].toString()), P = z0("afterHandle.unit", { name: W.afterHandle[a].name });
            if (U += `c.response = ${D0}\n`, !B12)
              U += q02(W.afterHandle[a]) ? `await afterHandle[${a}](c, ${D0});\n` : `afterHandle[${a}](c, ${D0});\n`;
            else {
              const _ = `af${a}`;
              U += q02(W.afterHandle[a]) ? `const ${_} = await afterHandle[${a}](c);\n` : `const ${_} = afterHandle[${a}](c);\n`, U += `if(${_} !== undefined) { c.response = ${D0} = ${_} }\n`;
            }
            P();
          }
        }
        if (E0(), X.response)
          U += $0(t);
        U += n, U += `return mapEarlyResponse(${t}, c.set)}\n`;
      }
    }
    E();
  }
  if (W?.afterHandle.length) {
    const E = z0("handle", { name: Z.name });
    if (W.afterHandle.length)
      U += q02(Z) ? "let r = c.response = await handler(c);\n" : "let r = c.response = handler(c);\n";
    else
      U += q02(Z) ? "let r = await handler(c);\n" : "let r = handler(c);\n";
    E();
    const d = z0("afterHandle", { unit: W.afterHandle.length });
    for (let u = 0;u < W.afterHandle.length; u++) {
      const t = `af${u}`, H0 = w$2(W.afterHandle[u].toString()), E0 = z0("afterHandle.unit", { name: W.afterHandle[u].name });
      if (!H0)
        U += q02(W.afterHandle[u]) ? `await afterHandle[${u}](c)\n` : `afterHandle[${u}](c)\n`, E0();
      else {
        if (X.response)
          U += q02(W.afterHandle[u]) ? `let ${t} = await afterHandle[${u}](c)\n` : `let ${t} = afterHandle[${u}](c)\n`;
        else
          U += q02(W.afterHandle[u]) ? `let ${t} = mapEarlyResponse(await afterHandle[${u}](c), c.set)\n` : `let ${t} = mapEarlyResponse(afterHandle[${u}](c), c.set)\n`;
        if (E0(), X.response)
          U += `if(${t} !== undefined) {`, U += $0(t), U += `${t} = mapEarlyResponse(${t}, c.set)\n`, U += `if(${t}) {`, d(), U += `return ${t} } }`;
        else
          U += `if(${t}) {`, d(), U += `return ${t}}\n`;
      }
    }
    if (d(), U += "r = c.response\n", X.response)
      U += $0();
    if (U += n, v0)
      U += "return mapResponse(r, c.set)\n";
    else
      U += "return mapCompactResponse(r)\n";
  } else {
    const E = z0("handle", { name: Z.name });
    if (X.response)
      if (U += q02(Z) ? "const r = await handler(c);\n" : "const r = handler(c);\n", E(), U += $0(), z0("afterHandle")(), U += n, v0)
        U += "return mapResponse(r, c.set)\n";
      else
        U += "return mapCompactResponse(r)\n";
    else if (L.handle || V)
      if (U += q02(Z) ? "let r = await handler(c);\n" : "let r = handler(c);\n", E(), z0("afterHandle")(), U += n, v0)
        U += "return mapResponse(r, c.set)\n";
      else
        U += "return mapCompactResponse(r)\n";
    else {
      E();
      const d = q02(Z) ? "await handler(c) " : "handler(c)";
      if (z0("afterHandle")(), v0)
        U += `return mapResponse(${d}, c.set)\n`;
      else
        U += `return mapCompactResponse(${d})\n`;
    }
  }
  if (A || I) {
    if (U += `
} catch(error) {`, !p0)
      U += "return (async () => {";
    U += `const set = c.set

		if (!set.status || set.status < 300) set.status = 500
	`;
    const E = z0("error", { unit: W.error.length });
    if (W.error.length)
      for (let d = 0;d < W.error.length; d++) {
        const u = `er${d}`, t = z0("error.unit", { name: W.error[d].name });
        if (U += `\nlet ${u} = handleErrors[${d}](
					Object.assign(c, {
						error: error,
						code: error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
					})
				)\n`, q02(W.error[d]))
          U += `if (${u} instanceof Promise) ${u} = await ${u}\n`;
        t(), U += `${u} = mapEarlyResponse(${u}, set)\n`, U += `if (${u}) {`, U += `return ${u} }\n`;
      }
    if (E(), U += "return handleError(c, error)\n\n", !p0)
      U += "})()";
    if (U += "}", I || O) {
      U += " finally { ";
      const d = z0("response", { unit: W.onResponse.length });
      U += I, d(), U += "}";
    }
  }
  return U = `const { 
		handler,
		handleError,
		hooks: {
			transform,
			beforeHandle,
			afterHandle,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		reporter,
		requestId,
		parseCookie,
		signCookie
	} = hooks

	${W.onResponse.length ? `const ${W.onResponse.map((E, d) => `res${d} = onResponse[${d}]`).join(",")}` : ""}

	return ${p0 ? "async" : ""} function(c) {
		${q && J ? "c.schema = schema; c.defs = definitions;" : ""}
		${U}
	}`, Function("hooks", U)({ handler: Z, hooks: W, validator: X, handleError: Q, utils: { mapResponse: F12, mapCompactResponse: w1, mapEarlyResponse: r02, parseQuery: pW2.parse }, error: { NotFoundError: O1, ValidationError: j02, InternalServerError: f$2 }, schema: q, definitions: J, ERROR_CODE: o12, reporter: K, requestId: mW2, parseCookie: h$2, signCookie: C12 });
};
var w62 = ($) => {
  let Y = "", W = "";
  for (let A of Object.keys($.decorators))
    Y += `,${A}: app.decorators.${A}`;
  const { router: X, staticRouter: Z } = $, Q = $.event.trace.length > 0, J = `
	const route = find(request.method, path) ${X.root.ALL ? '?? find("ALL", path)' : ""}
	if (route === null)
		return ${$.event.error.length ? "app.handleError(ctx, notFound)" : `new Response(error404, {
					status: 404
				})`}

	ctx.params = route.params

	return route.store(ctx)`;
  let q = "";
  for (let [A, { code: I, all: j }] of Object.entries(Z.map))
    q += `case '${A}':\nswitch(request.method) {\n${I}\n${j ?? "default: break map"}}\n\n`;
  const F = $.event.request.some(q02);
  W += `const {
		app,
		app: { store, router, staticRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		reporter
	} = data

	const notFound = new NotFoundError()

	${$.event.request.length ? "const onRequest = app.event.request" : ""}

	${Z.variables}

	const find = router.find.bind(router)
	const handleError = app.handleError.bind(this)

	${$.event.error.length ? "" : "const error404 = notFound.message.toString()"}

	return ${F ? "async" : ""} function map(request) {
	`;
  const D = $.event.trace.map((A) => A.toString()), K = uW2({ hasTrace: Q, hasTraceChildren: Q && D.some((A) => A.includes("children") || s12(A)), condition: { request: D.some((A) => O02("request", A) || s12(A)) }, addFn: (A) => {
    W += A;
  } });
  if ($.event.request.length) {
    W += `
			${Q ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					cookie: {},
					headers: {},
					status: 200
				}
				${Q ? ",$$requestId: +id" : ""}
				${Y}
			}
		`;
    const A = K("request", { attribute: "ctx", unit: $.event.request.length });
    W += "try {\n";
    for (let I = 0;I < $.event.request.length; I++) {
      const j = $.event.request[I], N = w$2(j.toString()), L = q02(j), O = K("request.unit", { name: $.event.request[I].name }), U = `re${I}`;
      if (N)
        W += `const ${U} = mapEarlyResponse(
					${L ? "await" : ""} onRequest[${I}](ctx),
					ctx.set
				)\n`, O(), W += `if(${U}) return ${U}\n`;
      else
        W += `${L ? "await" : ""} onRequest[${I}](ctx)\n`, O();
    }
    W += `} catch (error) {
			return app.handleError(ctx, error)
		}`, A(), W += `
		const url = request.url,
		s = url.indexOf('/', 11),
		i = ctx.qi = url.indexOf('?', s + 1),
		path = ctx.path = i === -1 ? url.substring(s) : url.substring(s, i);`;
  } else
    W += `
		const url = request.url,
			s = url.indexOf('/', 11),
			qi = url.indexOf('?', s + 1),
			path = qi === -1
				? url.substring(s)
				: url.substring(s, qi)

		${Q ? "const id = +requestId.value++" : ""}

		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: {},
				status: 200
			}
			${Q ? ",$$requestId: id" : ""}
			${Y}
		}`, K("request", { unit: $.event.request.length, attribute: D.some((A) => O02("context", A)) || D.some((A) => O02("store", A)) || D.some((A) => O02("set", A)) ? "ctx" : "" })();
  return W += `
		map: switch(path) {
			${q}

			default:
				break
		}

		${J}
	}`, $.handleError = K62($), Function("data", W)({ app: $, mapEarlyResponse: r02, NotFoundError: O1, reporter: $.reporter, requestId: mW2 });
};
var K62 = ($) => {
  let Y = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE
	} = inject

	return ${$.event.error.find(q02) ? "async" : ""} function(context, error) {
		const { set } = context
		`;
  for (let W = 0;W < $.event.error.length; W++) {
    const X = $.event.error[W], Z = `${q02(X) ? "await " : ""}onError[${W}](
			Object.assign(context, {
				code: error.code ?? error[ERROR_CODE] ?? 'UNKNOWN',
				error
			})
		)`;
    if (w$2(X.toString()))
      Y += `const r${W} = ${Z}; if(r${W} !== undefined) return mapResponse(r${W}, set)\n`;
    else
      Y += Z + "\n";
  }
  return Y += `if(error.constructor.name === "ValidationError") {
		set.status = error.status ?? 400
		return new Response(
			error.message, 
			{ headers: set.headers, status: set.status }
		)
	} else {
		return new Response(error.message, { headers: set.headers, status: error.status ?? 500 })
	}
}`, Function("inject", Y)({ app: $, mapResponse: F12, ERROR_CODE: o12 });
};
var o$2 = X12(A62(), 1);
var j62 = ($) => async (Y) => {
  const W = { cookie: {}, status: 200, headers: {} };
  let X;
  if ($.decorators)
    X = $.decorators, X.request = Y, X.set = W, X.store = $.store;
  else
    X = { set: W, store: $.store, request: Y };
  const Z = Y.url, Q = Z.indexOf("/", 11), J = Z.indexOf("?", Q + 1), q = J === -1 ? Z.substring(Q) : Z.substring(Q, J);
  try {
    for (let O = 0;O < $.event.request.length; O++) {
      const U = $.event.request[O];
      let w = U(X);
      if (w instanceof Promise)
        w = await w;
      if (w = r02(w, W), w)
        return w;
    }
    const F = $.dynamicRouter.find(Y.method, q) ?? $.dynamicRouter.find("ALL", q);
    if (!F)
      throw new O1;
    const { handle: D, hooks: K, validator: A, content: I } = F.store;
    let j;
    if (Y.method !== "GET" && Y.method !== "HEAD")
      if (I)
        switch (I) {
          case "application/json":
            j = await Y.json();
            break;
          case "text/plain":
            j = await Y.text();
            break;
          case "application/x-www-form-urlencoded":
            j = o$2.parse(await Y.text());
            break;
          case "application/octet-stream":
            j = await Y.arrayBuffer();
            break;
          case "multipart/form-data":
            j = {};
            const O = await Y.formData();
            for (let U of O.keys()) {
              if (j[U])
                continue;
              const w = O.getAll(U);
              if (w.length === 1)
                j[U] = w[0];
              else
                j[U] = w;
            }
            break;
        }
      else {
        let O = Y.headers.get("content-type");
        if (O) {
          const U = O.indexOf(";");
          if (U !== -1)
            O = O.slice(0, U);
          for (let w = 0;w < $.event.parse.length; w++) {
            let R = $.event.parse[w](X, O);
            if (R instanceof Promise)
              R = await R;
            if (R) {
              j = R;
              break;
            }
          }
          if (j === undefined)
            switch (O) {
              case "application/json":
                j = await Y.json();
                break;
              case "text/plain":
                j = await Y.text();
                break;
              case "application/x-www-form-urlencoded":
                j = o$2.parse(await Y.text());
                break;
              case "application/octet-stream":
                j = await Y.arrayBuffer();
                break;
              case "multipart/form-data":
                j = {};
                const w = await Y.formData();
                for (let R of w.keys()) {
                  if (j[R])
                    continue;
                  const b = w.getAll(R);
                  if (b.length === 1)
                    j[R] = b[0];
                  else
                    j[R] = b;
                }
                break;
            }
        }
      }
    X.body = j, X.params = F?.params || undefined, X.query = J === -1 ? {} : o$2.parse(Z.substring(J + 1)), X.headers = {};
    for (let [O, U] of Y.headers.entries())
      X.headers[O] = U;
    const N = A?.cookie?.schema;
    X.cookie = h$2(X.set, X.headers.cookie, N ? { secret: N.secrets !== undefined ? typeof N.secrets === "string" ? N.secrets : N.secrets.join(",") : undefined, sign: N.sign === true ? true : N.sign !== undefined ? typeof N.sign === "string" ? N.sign : N.sign.join(",") : undefined } : undefined);
    for (let O = 0;O < K.transform.length; O++) {
      const U = K.transform[O](X);
      if (K.transform[O].$elysia === "derive")
        if (U instanceof Promise)
          Object.assign(X, await U);
        else
          Object.assign(X, U);
      else if (U instanceof Promise)
        await U;
    }
    if (A) {
      if (A.headers) {
        const O = {};
        for (let U in Y.headers)
          O[U] = Y.headers.get(U);
        if (A.headers.Check(O) === false)
          throw new j02("header", A.headers, O);
      }
      if (A.params?.Check(X.params) === false)
        throw new j02("params", A.params, X.params);
      if (A.query?.Check(X.query) === false)
        throw new j02("query", A.query, X.query);
      if (A.cookie) {
        const O = {};
        for (let [U, w] of Object.entries(X.cookie))
          O[U] = w.value;
        if (A.cookie?.Check(O) === false)
          throw new j02("cookie", A.cookie, O);
      }
      if (A.body?.Check(j) === false)
        throw new j02("body", A.body, j);
    }
    for (let O = 0;O < K.beforeHandle.length; O++) {
      let U = K.beforeHandle[O](X);
      if (U instanceof Promise)
        U = await U;
      if (U !== undefined) {
        X.response = U;
        for (let R = 0;R < K.afterHandle.length; R++) {
          let b = K.afterHandle[R](X);
          if (b instanceof Promise)
            b = await b;
          if (b)
            U = b;
        }
        const w = r02(U, X.set);
        if (w)
          return w;
      }
    }
    let L = D(X);
    if (L instanceof Promise)
      L = await L;
    if (!K.afterHandle.length) {
      const O = A?.response?.[L.status];
      if (O?.Check(L) === false)
        throw new j02("response", O, L);
    } else {
      X.response = L;
      for (let O = 0;O < K.afterHandle.length; O++) {
        let U = K.afterHandle[O](X);
        if (U instanceof Promise)
          U = await U;
        const w = r02(U, X.set);
        if (w !== undefined) {
          const R = A?.response?.[L.status];
          if (R?.Check(w) === false)
            throw new j02("response", R, w);
          return w;
        }
      }
    }
    if (X.set.cookie && N?.sign) {
      const O = !N.secrets ? undefined : typeof N.secrets === "string" ? N.secrets : N.secrets[0];
      if (N.sign === true)
        for (let [U, w] of Object.entries(X.set.cookie))
          X.set.cookie[U].value = C12(w.value, "${secret}");
      else
        for (let U of N.sign) {
          if (!(U in N.properties))
            continue;
          if (X.set.cookie[U]?.value)
            X.set.cookie[U].value = C12(X.set.cookie[U].value, O);
        }
    }
    return F12(L, X.set);
  } catch (F) {
    if (F.status)
      W.status = F.status;
    return $.handleError(X, F);
  } finally {
    for (let F of $.event.onResponse)
      await F(X);
  }
};
var nW2 = ($) => async (Y, W) => {
  const X = Object.assign(Y, W);
  X.set = Y.set;
  for (let Z = 0;Z < $.event.error.length; Z++) {
    let Q = $.event.error[Z](X);
    if (Q instanceof Promise)
      Q = await Q;
    if (Q !== undefined && Q !== null)
      return F12(Q, Y.set);
  }
  return new Response(typeof W.cause === "string" ? W.cause : W.message, { headers: Y.set.headers, status: W.status ?? 500 });
};
var b12 = X12(E$2(), 1);
var U02 = X12(f02(), 1);
try {
  b12.TypeSystem.Format("email", ($) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test($)), b12.TypeSystem.Format("uuid", ($) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test($)), b12.TypeSystem.Format("date", ($) => !Number.isNaN(new Date($).getTime())), b12.TypeSystem.Format("date-time", ($) => !Number.isNaN(new Date($).getTime()));
} catch ($) {
}
var oW2 = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var P62 = ($, Y) => {
  if (!(Y instanceof Blob))
    return false;
  if ($.minSize && Y.size < oW2($.minSize))
    return false;
  if ($.maxSize && Y.size > oW2($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!Y.type.startsWith($.extension))
        return false;
    } else {
      for (let W = 0;W < $.extension.length; W++)
        if (Y.type.startsWith($.extension[W]))
          return true;
      return false;
    }
  return true;
};
var K72 = b12.TypeSystem.Type("Files", ($, Y) => {
  if (!Array.isArray(Y))
    return P62($, Y);
  if ($.minItems && Y.length < $.minItems)
    return false;
  if ($.maxItems && Y.length > $.maxItems)
    return false;
  for (let W = 0;W < Y.length; W++)
    if (!P62($, Y[W]))
      return false;
  return true;
});
var G12 = { Numeric: ($) => U02.Type.Transform(U02.Type.Union([U02.Type.String(), U02.Type.Number($)])).Decode((Y) => {
  const W = +Y;
  if (isNaN(W))
    return Y;
  return W;
}).Encode((Y) => Y), ObjectString: ($, Y) => U02.Type.Transform(U02.Type.Union([U02.Type.String(), U02.Type.Object($, Y)])).Decode((W) => {
  if (typeof W === "string")
    try {
      return JSON.parse(W);
    } catch {
      return W;
    }
  return W;
}).Encode((W) => JSON.stringify(W)), File: b12.TypeSystem.Type("File", P62), Files: ($) => U02.Type.Transform(U02.Type.Union([K72($)])).Decode((Y) => {
  if (Array.isArray(Y))
    return Y;
  return [Y];
}).Encode((Y) => Y), Nullable: ($) => ({ ...$, nullable: true }), MaybeEmpty: ($) => U02.Type.Union([U02.Type.Undefined(), $]), Cookie: ($, Y) => U02.Type.Object($, Y) };
U02.Type.ObjectString = G12.ObjectString;
U02.Type.Numeric = G12.Numeric;
U02.Type.File = ($ = {}) => G12.File({ default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
U02.Type.Files = ($ = {}) => G12.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });
U02.Type.Nullable = ($) => G12.Nullable($);
U02.Type.MaybeEmpty = G12.MaybeEmpty;
U02.Type.Cookie = G12.Cookie;

class c$2 {
  config;
  dependencies = {};
  store = {};
  decorators = {};
  definitions = { type: {}, error: {} };
  schema = {};
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], onResponse: [], trace: [], error: [], stop: [] };
  reporter = new G62;
  server = null;
  validator = null;
  router = new E12;
  routes = [];
  staticRouter = { handlers: [], variables: "", map: {}, all: "" };
  dynamicRouter = new E12;
  lazyLoadModules = [];
  path = "";
  constructor($) {
    this.config = { forceErrorEncapsulation: false, prefix: "", aot: true, strictPath: false, scoped: false, cookie: {}, ...$, seed: $?.seed === undefined ? "" : $?.seed };
  }
  add($, Y, W, X, { allowMeta: Z = false, skipPrefix: Q = false } = { allowMeta: false, skipPrefix: false }) {
    if (typeof Y === "string")
      Y = [Y];
    for (let J of Y) {
      if (J = J === "" ? J : J.charCodeAt(0) === 47 ? J : `/${J}`, this.config.prefix && !Q)
        J = this.config.prefix + J;
      if (X?.type)
        switch (X.type) {
          case "text":
            X.type = "text/plain";
            break;
          case "json":
            X.type = "application/json";
            break;
          case "formdata":
            X.type = "multipart/form-data";
            break;
          case "urlencoded":
            X.type = "application/x-www-form-urlencoded";
            break;
          case "arrayBuffer":
            X.type = "application/octet-stream";
            break;
          default:
            break;
        }
      const q = this.definitions.type, F = U12(X?.cookie ?? this.validator?.cookie, { dynamic: !this.config.aot, models: q, additionalProperties: true });
      if (F && I12(this.config.cookie ?? []))
        F.schema = DW2(F.schema, this.config.cookie ?? {});
      const D = { body: U12(X?.body ?? this.validator?.body, { dynamic: !this.config.aot, models: q }), headers: U12(X?.headers ?? this.validator?.headers, { dynamic: !this.config.aot, models: q, additionalProperties: true }), params: U12(X?.params ?? this.validator?.params, { dynamic: !this.config.aot, models: q }), query: U12(X?.query ?? this.validator?.query, { dynamic: !this.config.aot, models: q }), cookie: F, response: q62(X?.response ?? this.validator?.response, { dynamic: !this.config.aot, models: q }) }, K = L1(this.event, X), A = J.endsWith("/") ? J.slice(0, J.length - 1) : J + "/";
      if (this.config.aot === false) {
        if (this.dynamicRouter.add($, J, { validator: D, hooks: K, content: X?.type, handle: W }), this.config.strictPath === false)
          this.dynamicRouter.add($, A, { validator: D, hooks: K, content: X?.type, handle: W });
        this.routes.push({ method: $, path: J, composed: null, handler: W, hooks: K });
        return;
      }
      const I = hW2({ path: J, method: $, hooks: K, validator: D, handler: W, handleError: this.handleError, onRequest: this.event.request, config: this.config, definitions: Z ? this.definitions.type : undefined, schema: Z ? this.schema : undefined, reporter: this.reporter });
      if (this.routes.push({ method: $, path: J, composed: I, handler: W, hooks: K }), J.indexOf(":") === -1 && J.indexOf("*") === -1) {
        const j = this.staticRouter.handlers.length;
        if (this.staticRouter.handlers.push(I), this.staticRouter.variables += `const st${j} = staticRouter.handlers[${j}]\n`, !this.staticRouter.map[J])
          this.staticRouter.map[J] = { code: "" };
        if ($ === "ALL")
          this.staticRouter.map[J].all = `default: return st${j}(ctx)\n`;
        else
          this.staticRouter.map[J].code += `case '${$}': return st${j}(ctx)\n`;
        if (!this.config.strictPath) {
          if (!this.staticRouter.map[A])
            this.staticRouter.map[A] = { code: "" };
          if ($ === "ALL")
            this.staticRouter.map[A].all = `default: return st${j}(ctx)\n`;
          else
            this.staticRouter.map[A].code += `case '${$}': return st${j}(ctx)\n`;
        }
      } else if (this.router.add($, J, I), !this.config.strictPath)
        this.router.add($, J.endsWith("/") ? J.slice(0, J.length - 1) : J + "/", I);
    }
  }
  onStart($) {
    return this.on("start", $), this;
  }
  onRequest($) {
    return this.on("request", $), this;
  }
  onParse($) {
    return this.on("parse", $), this;
  }
  onTransform($) {
    return this.on("transform", $), this;
  }
  onBeforeHandle($) {
    return this.on("beforeHandle", $), this;
  }
  onAfterHandle($) {
    return this.on("afterHandle", $), this;
  }
  onResponse($) {
    return this.on("response", $), this;
  }
  trace($) {
    return this.reporter.on("event", _62(this.reporter, $)), this.on("trace", $), this;
  }
  addError($, Y) {
    return this.error($, Y);
  }
  error($, Y) {
    switch (typeof $) {
      case "string":
        return Y.prototype[o12] = $, this.definitions.error[$] = Y, this;
      case "function":
        return this.definitions.error = $(this.definitions.error), this;
    }
    for (let [W, X] of Object.entries($))
      X.prototype[o12] = W, this.definitions.error[W] = X;
    return this;
  }
  onError($) {
    return this.on("error", $), this;
  }
  onStop($) {
    return this.on("stop", $), this;
  }
  on($, Y) {
    for (let W of Array.isArray(Y) ? Y : [Y])
      switch (W = wW2(W), $) {
        case "start":
          this.event.start.push(W);
          break;
        case "request":
          this.event.request.push(W);
          break;
        case "response":
          this.event.onResponse.push(W);
          break;
        case "parse":
          this.event.parse.splice(this.event.parse.length - 1, 0, W);
          break;
        case "transform":
          this.event.transform.push(W);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(W);
          break;
        case "afterHandle":
          this.event.afterHandle.push(W);
          break;
        case "trace":
          this.event.trace.push(W);
          break;
        case "error":
          this.event.error.push(W);
          break;
        case "stop":
          this.event.stop.push(W);
          break;
      }
    return this;
  }
  group($, Y, W) {
    const X = new c$2({ ...this.config, prefix: "" });
    X.store = this.store;
    const Z = typeof Y === "object", Q = (Z ? W : Y)(X);
    if (this.decorators = N1(this.decorators, X.decorators), Q.event.request.length)
      this.event.request = [...this.event.request, ...Q.event.request];
    if (Q.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...Q.event.onResponse];
    return this.model(Q.definitions.type), Object.values(X.routes).forEach(({ method: J, path: q, handler: F, hooks: D }) => {
      if (q = this.config.prefix + $ + q, Z) {
        const K = Y, A = D;
        this.add(J, q, F, L1(K, { ...A, error: !A.error ? Q.event.error : Array.isArray(A.error) ? [...A.error, ...Q.event.error] : [A.error, ...Q.event.error] }));
      } else
        this.add(J, q, F, L1(D, { error: Q.event.error }), { skipPrefix: true });
    }), this;
  }
  guard($, Y) {
    if (!Y)
      return this.event = m$2(this.event, $), this.validator = { body: $.body, headers: $.headers, params: $.params, query: $.query, response: $.response }, this;
    const W = new c$2;
    W.store = this.store;
    const X = Y(W);
    if (this.decorators = N1(this.decorators, W.decorators), X.event.request.length)
      this.event.request = [...this.event.request, ...X.event.request];
    if (X.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse, ...X.event.onResponse];
    return this.model(X.definitions.type), Object.values(W.routes).forEach(({ method: Z, path: Q, handler: J, hooks: q }) => {
      this.add(Z, Q, J, L1($, { ...q, error: !q.error ? X.event.error : Array.isArray(q.error) ? [...q.error, ...X.event.error] : [q.error, ...X.event.error] }));
    }), this;
  }
  use($) {
    if ($ instanceof Promise)
      return this.lazyLoadModules.push($.then((Y) => {
        if (typeof Y === "function")
          return Y(this);
        if (typeof Y.default === "function")
          return Y.default(this);
        return this._use(Y.default);
      }).then((Y) => Y.compile())), this;
    else
      return this._use($);
    return this;
  }
  _use($) {
    if (typeof $ === "function") {
      const Z = $(this);
      if (Z instanceof Promise)
        return this.lazyLoadModules.push(Z.then((Q) => Q.compile())), this;
      return Z;
    }
    const { name: Y, seed: W } = $.config, X = $.config.scoped;
    if (X) {
      if (Y) {
        if (!(Y in this.dependencies))
          this.dependencies[Y] = [];
        const Z = W !== undefined ? M62(Y + JSON.stringify(W)) : 0;
        if (this.dependencies[Y].some((Q) => Z === Q))
          return this;
        this.dependencies[Y].push(Z);
      }
      if ($.model(this.definitions.type), $.error(this.definitions.error), $.onRequest((Z) => {
        Object.assign(Z, this.decorators), Object.assign(Z.store, this.store);
      }), $.config.aot)
        $.compile();
      return this.mount($.fetch);
    }
    this.decorate($.decorators), this.state($.store), this.model($.definitions.type), this.error($.definitions.error);
    for (let { method: Z, path: Q, handler: J, hooks: q } of Object.values($.routes))
      this.add(Z, Q, J, L1(q, { error: $.event.error }));
    if (!X)
      if (Y) {
        if (!(Y in this.dependencies))
          this.dependencies[Y] = [];
        const Z = W !== undefined ? M62(Y + JSON.stringify(W)) : 0;
        if (this.dependencies[Y].some((Q) => Z === Q))
          return this;
        this.dependencies[Y].push(Z), this.event = m$2(this.event, N62($.event), Z);
      } else
        this.event = m$2(this.event, N62($.event));
    return this;
  }
  mount($, Y) {
    if (typeof $ === "function" || $.length === 0 || $ === "/") {
      const Z = typeof $ === "function" ? $ : Y, Q = async ({ request: J, path: q }) => Z(new Request("http://a.cc" + q || "/", J));
      return this.all("/", Q, { type: "none" }), this.all("/*", Q, { type: "none" }), this;
    }
    const W = $.length, X = async ({ request: Z, path: Q }) => Y(new Request("http://a.cc" + Q.slice(W) || "/", Z));
    return this.all($, X, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), X, { type: "none" }), this;
  }
  get($, Y, W) {
    return this.add("GET", $, Y, W), this;
  }
  post($, Y, W) {
    return this.add("POST", $, Y, W), this;
  }
  put($, Y, W) {
    return this.add("PUT", $, Y, W), this;
  }
  patch($, Y, W) {
    return this.add("PATCH", $, Y, W), this;
  }
  delete($, Y, W) {
    return this.add("DELETE", $, Y, W), this;
  }
  options($, Y, W) {
    return this.add("OPTIONS", $, Y, W), this;
  }
  all($, Y, W) {
    return this.add("ALL", $, Y, W), this;
  }
  head($, Y, W) {
    return this.add("HEAD", $, Y, W), this;
  }
  connect($, Y, W) {
    return this.add("CONNECT", $, Y, W), this;
  }
  ws($, Y) {
    const W = Y.transformMessage ? Array.isArray(Y.transformMessage) ? Y.transformMessage : [Y.transformMessage] : undefined;
    return this.get($, (X) => {
      const { set: Z, path: Q, qi: J, ...q } = X;
      X.headers, X.query, X.params;
      const F = U12(Y?.body, { models: this.definitions.type }), D = U12(Y?.response, { models: this.definitions.type }), K = (A) => {
        const I = A.charCodeAt(0);
        if (I === 47 || I === 123)
          try {
            A = JSON.parse(A);
          } catch {
          }
        else if (!Number.isNaN(+A))
          A = +A;
        if (W?.length)
          for (let j = 0;j < W.length; j++) {
            const N = W[j](A);
            if (N !== undefined)
              A = N;
          }
        return A;
      };
      if (this.server?.upgrade(X.request, { headers: typeof Y.upgrade === "function" ? Y.upgrade(X) : Y.upgrade, data: { validator: D, open(A) {
        Y.open?.(new c12(A, q));
      }, message: (A, I) => {
        const j = K(I);
        if (F?.Check(j) === false)
          return void A.send(new j02("message", F, j).message);
        Y.message?.(new c12(A, q), j);
      }, drain(A) {
        Y.drain?.(new c12(A, q));
      }, close(A, I, j) {
        Y.close?.(new c12(A, q), I, j);
      } } }))
        return;
      return Z.status = 400, "Expected a websocket connection";
    }, { beforeHandle: Y.beforeHandle, transform: Y.transform, headers: Y.headers, params: Y.params, query: Y.query }), this;
  }
  route($, Y, W, { config: X, ...Z } = { config: { allowMeta: false } }) {
    return this.add($, Y, W, Z, X), this;
  }
  state($, Y) {
    switch (typeof $) {
      case "object":
        return this.store = N1(this.store, $), this;
      case "function":
        return this.store = $(this.store), this;
    }
    if (!($ in this.store))
      this.store[$] = Y;
    return this;
  }
  decorate($, Y) {
    switch (typeof $) {
      case "object":
        return this.decorators = N1(this.decorators, $), this;
      case "function":
        return this.decorators = $(this.decorators), this;
    }
    if (!($ in this.decorators))
      this.decorators[$] = Y;
    return this;
  }
  derive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  model($, Y) {
    switch (typeof $) {
      case "object":
        return Object.entries($).forEach(([W, X]) => {
          if (!(W in this.definitions.type))
            this.definitions.type[W] = X;
        }), this;
      case "function":
        return this.definitions.type = $(this.definitions.type), this;
    }
    return this.definitions.type[$] = Y, this;
  }
  mapDerive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  affix($, Y, W) {
    if (W === "")
      return this;
    const X = ["_", "-", " "], Z = (F) => F[0].toUpperCase() + F.slice(1), Q = $ === "prefix" ? (F, D) => X.includes(F.at(-1) ?? "") ? F + D : F + Z(D) : X.includes(W.at(-1) ?? "") ? (F, D) => D + F : (F, D) => D + Z(F), J = (F) => {
      const D = {};
      switch (F) {
        case "decorator":
          for (let K in this.decorators)
            D[Q(W, K)] = this.decorators[K];
          this.decorators = D;
          break;
        case "state":
          for (let K in this.store)
            D[Q(W, K)] = this.store[K];
          this.store = D;
          break;
        case "model":
          for (let K in this.definitions.type)
            D[Q(W, K)] = this.definitions.type[K];
          this.definitions.type = D;
          break;
        case "error":
          for (let K in this.definitions.error)
            D[Q(W, K)] = this.definitions.error[K];
          this.definitions.error = D;
          break;
      }
    }, q = Array.isArray(Y) ? Y : [Y];
    for (let F of q.some((D) => D === "all") ? ["decorator", "state", "model", "error"] : q)
      J(F);
    return this;
  }
  prefix($, Y) {
    return this.affix("prefix", $, Y);
  }
  suffix($, Y) {
    return this.affix("suffix", $, Y);
  }
  compile() {
    if (this.fetch = this.config.aot ? w62(this) : j62(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => (this.fetch = this.config.aot ? w62(this) : j62(this))($);
  handleError = async ($, Y) => (this.handleError = this.config.aot ? K62(this) : nW2(this))($, Y);
  outerErrorHandler = ($) => new Response($.message || $.name || "Error", { status: $?.status ?? 500 });
  listen = ($, Y) => {
    if (!Bun)
      throw new Error("Bun to run");
    if (this.compile(), typeof $ === "string") {
      if ($ = +$.trim(), Number.isNaN($))
        throw new Error("Port must be a numeric value");
    }
    const W = this.fetch, X = typeof $ === "object" ? { development: !M$2, ...this.config.serve, ...$, websocket: { ...this.config.websocket, ...W62 }, fetch: W, error: this.outerErrorHandler } : { development: !M$2, ...this.config.serve, websocket: { ...this.config.websocket, ...W62 }, port: $, fetch: W, error: this.outerErrorHandler };
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    this.server = Bun?.serve(X);
    for (let Z = 0;Z < this.event.start.length; Z++)
      this.event.start[Z](this);
    if (Y)
      Y(this.server);
    return Promise.all(this.lazyLoadModules).then(() => {
      Bun?.gc(false);
    }), this;
  };
  stop = async () => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    this.server.stop();
    for (let $ = 0;$ < this.event.stop.length; $++)
      await this.event.stop[$](this);
  };
  get modules() {
    return Promise.all(this.lazyLoadModules);
  }
}
var export_t2 = U02.Type;

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/ut
var typebox = __toESM(require_typebox(), 1);
var value = __toESM(require_value2(), 1);
var compiler = __toESM(require_compiler2(), 1);
var StatusMap = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/util.jsjss-color/index
var assembleStyles = function() {
  const codes = new Map;
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value2 = Math.max(red, green, blue) * 2;
        if (value2 === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value2 === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
};
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    blackBright: [90, 39],
    gray: [90, 39],
    grey: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/util.jsjss-color/index.js
import process2 from "process";
import os from "os";
import tty from "tty";
var hasFlag = function(flag, argv = globalThis.Deno ? globalThis.Deno.args : process2.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};
var envForceColor = function() {
  if ("FORCE_COLOR" in env2) {
    if (env2.FORCE_COLOR === "true") {
      return 1;
    }
    if (env2.FORCE_COLOR === "false") {
      return 0;
    }
    return env2.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env2.FORCE_COLOR, 10), 3);
  }
};
var translateLevel = function(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
};
var _supportsColor = function(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== undefined) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if (("TF_BUILD" in env2) && ("AGENT_NAME" in env2)) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === undefined) {
    return 0;
  }
  const min = forceColor || 0;
  if (env2.TERM === "dumb") {
    return min;
  }
  if (process2.platform === "win32") {
    const osRelease = os.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env2) {
    if (("GITHUB_ACTIONS" in env2) || ("GITEA_ACTIONS" in env2)) {
      return 3;
    }
    if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => (sign in env2)) || env2.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env2) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env2.COLORTERM === "truecolor") {
    return 3;
  }
  if (env2.TERM === "xterm-kitty") {
    return 3;
  }
  if ("TERM_PROGRAM" in env2) {
    const version = Number.parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env2.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env2.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env2) {
    return 1;
  }
  return min;
};
function createSupportsColor(stream2, options = {}) {
  const level = _supportsColor(stream2, {
    streamIsTTY: stream2 && stream2.isTTY,
    ...options
  });
  return translateLevel(level);
}
var { env: env2 } = process2;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: tty.isatty(1) }),
  stderr: createSupportsColor({ isTTY: tty.isatty(2) })
};
var supports_color_default = supportsColor;

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/util.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/uti
var createChalk = function(options) {
  return chalkFactory(options);
};
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = Object.create(null);
var applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === undefined ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  const chalk = (...strings) => strings.join(" ");
  applyOptions(chalk, options);
  Object.setPrototypeOf(chalk, createChalk.prototype);
  return chalk;
};
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open, close, parent) => {
  let openAll;
  let closeAll;
  if (parent === undefined) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }
  return {
    open,
    close,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string) {
    return self2[IS_EMPTY] ? "" : string;
  }
  let styler = self2[STYLER];
  if (styler === undefined) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== undefined) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// node_modules/@libsql/hrana-client/lib-esm/enco
class HoltLogger {
  static DEFAULT_FORMAT = ":dateUTC | :method :path - :status (:request-duration ms)";
  config;
  tokens = [];
  constructor(partialConfig = {}) {
    this.config = HoltLogger.configFromPartial(partialConfig);
  }
  getLogger() {
    return new c$2({ name: "@tlscipher/holt" }).derive(async () => {
      return {
        _holtRequestStartTime: Date.now()
      };
    }).onResponse(({ request: request4, set, path, headers, body, _holtRequestStartTime }) => {
      let message = this.config.format.replaceAll(":date", new Date().toISOString()).replaceAll(":method", request4.method).replaceAll(":path", path).replaceAll(":status", set.status ? set.status.toString() : "<unknown status>").replaceAll(":request-duration", `${Date.now() - _holtRequestStartTime}`);
      for (const token of this.tokens) {
        message = message.replaceAll(HoltLogger.tokenize(token.token), token.extractFn({
          request: request4,
          headers,
          set,
          path,
          body
        }));
      }
      for (const headerPair of HoltLogger.extractHeaderKeysFromFormat(this.config.format)) {
        message = message.replaceAll(headerPair.rawMatch, request4.headers.get(headerPair.headerKey) ?? "-");
      }
      if (!this.config.colorful || !set.status) {
        console.log(message);
      } else {
        const colorFn = HoltLogger.getColorByConfig(set.status);
        console.log(colorFn(message));
      }
    });
  }
  token(token, extractFn) {
    this.tokens.push({
      token,
      extractFn
    });
    return this;
  }
  static tokenize(token) {
    return `:${token}`;
  }
  static configFromPartial(partialConfig) {
    const colorful = partialConfig.colorful === undefined ? true : false;
    const format2 = partialConfig.format === undefined ? HoltLogger.DEFAULT_FORMAT : partialConfig.format;
    return {
      format: format2,
      colorful
    };
  }
  static extractHeaderKeysFromFormat(format2) {
    const regex = /:header\[(.*?)\]/g;
    const matches = format2.match(regex);
    return matches ? matches.map((match) => {
      return {
        rawMatch: match,
        headerKey: match.match(/:header\[(.*?)\]/)[1]
      };
    }) : [];
  }
  static getColorByConfig(status) {
    const intStatus = typeof status === "number" ? status : StatusMap[status];
    switch (true) {
      case intStatus >= 500:
        return source_default.red;
      case intStatus >= 400:
        return source_default.yellow;
      case intStatus >= 300:
        return source_default.cyan;
      case intStatus >= 200:
        return source_default.green;
      default:
        return source_default.white;
    }
  }
}

// node_modules/@libsql/hrana-client/lib-esm/encodi
import {existsSync, unlinkSync} from "fs";
import {Database} from "bun:sqlite";
var startingConfig = {
  log: "major",
  defaultCacheOptions: {
    persist: "json",
    revalidate: Infinity,
    tags: [],
    seedImmediately: true
  },
  errorHandling: {
    duringRevalidation: "return-stale",
    duringRevalidationWhileUnseeded: "rerun on next call",
    duringImmediateSeed: "rerun on next call"
  },
  returnStaleWhileRevalidating: true
};

class BethMemoryCache {
  cache;
  constructor() {
    this.cache = new Map;
  }
  get(key) {
    const result = this.cache.get(key);
    if (result) {
      return result;
    } else {
      throw new Error(`No entry found in memory cache when one was expected: ${key}`);
    }
  }
  set(key, value2) {
    this.cache.set(key, value2);
  }
}

class BethJsonCache {
  db;
  constructor() {
    if (existsSync("beth-cache.sqlite")) {
      unlinkSync("beth-cache.sqlite");
    }
    this.db = new Database("beth-cache.sqlite");
    this.db.exec("CREATE TABLE IF NOT EXISTS cache (key TEXT PRIMARY KEY, value TEXT NOT NULL)");
  }
  get(key) {
    const result = this.db.query("SELECT value FROM cache WHERE key = ?").get(key);
    if (result) {
      return JSON.parse(result.value);
    } else {
      throw new Error(`No entry found in json cache when one was expected: ${key}`);
    }
  }
  set(key, value2) {
    this.db.query(`
        INSERT INTO cache (key, value)
        VALUES (?, ?)
        ON CONFLICT (key) DO UPDATE SET value = excluded.value;
        `).run(key, JSON.stringify(value2));
  }
}
class BethPersistedCache {
  config = startingConfig;
  primaryMap = new Map;
  pendingMap = new Map;
  erroredMap = new Map;
  inMemoryDataCache = new BethMemoryCache;
  jsonDataCache = new BethJsonCache;
  intervals = new Set;
  keys = new Set;
  constructor() {
  }
  setConfig(config4) {
  }
  clearAllIntervals() {
    this.intervals.forEach((interval) => clearInterval(interval));
  }
  purgeAllCachedData() {
    this.primaryMap = new Map;
    this.erroredMap = new Map;
    this.inMemoryDataCache = new BethMemoryCache;
    this.jsonDataCache = new BethJsonCache;
    this.primaryMap.forEach((fnData, key) => {
      fnData.argsMap.forEach((fnData2, key2) => {
        fnData2.status = "unseeded";
      });
    });
  }
  initializeEntry(callBack, key, options) {
  }
  getCachedValue(key, ...args2) {
  }
  async revalidateTag(tag) {
  }
  logDebug() {
  }
  log() {
  }
  rerunCallBack(key) {
  }
  setInterval(key, revalidate) {
  }
}

// node_modules/@libsql/hrana-client/lib-esm/e
class BethRenderCache {
  dedupeCache;
  streamController;
  counter;
  suspenseMap;
  sentFirstChunk;
  constructor() {
    this.dedupeCache = new WeakMap;
    this.streamController = undefined;
    this.counter = 1;
    this.suspenseMap = new Map;
    this.sentFirstChunk = false;
  }
  reset() {
    this.dedupeCache = new WeakMap;
    this.streamController = undefined;
    this.counter = 1;
    this.suspenseMap = new Map;
    this.sentFirstChunk = false;
  }
  registerChild(child) {
    const id = this.counter++;
    this.suspenseMap.set(child, id);
    return id;
  }
  dismissChild(child) {
    const id = this.suspenseMap.get(child);
    if (id) {
      this.suspenseMap.delete(child);
    }
    return id;
  }
  closeNow() {
    this.streamController?.close();
    this.reset();
  }
  checkIfEndAndClose() {
    if (this.suspenseMap.size === 0) {
      this.closeNow();
    }
  }
}

// node_modules/@libsql/hrana-client/lib-esm/en
globalThis.BETH_GLOBAL_RENDER_CACHE ??= new BethRenderCache;
globalThis.BETH_GLOBAL_PERSISTED_CACHE ??= new BethPersistedCache;
var BETH_GLOBAL_RENDER_CACHE = globalThis.BETH_GLOBAL_RENDER_CACHE;
var BETH_GLOBAL_PERSISTED_CACHE = globalThis.BETH_GLOBAL_PERSISTED_CACHE;
globalThis.RENDER_COUNT ??= 0;
globalThis.RENDER_COUNT++;

// node_modules/@libsql/hrana-client/lib-esm
async function ErrorBoundary({
  fallback,
  children
}) {
  if (!Array.isArray(children))
    throw new Error("children isnt array (shouldnt be possible)");
  return Promise.all(children).then((children2) => Html.createElement(Html.Fragment, null, children2)).catch(() => fallback);
}

// node_modules/@libsql/hrana-client/lib-esm/en
async function Suspense({
  fallback,
  children
}) {
  if (!Array.isArray(children))
    throw new Error("children isnt array (shouldnt be possible)");
  const hasAnyUnresolvedPromiseChildren = children.reduce((acc, child) => acc || Bun.peek.status(child) !== "fulfilled", false);
  if (!hasAnyUnresolvedPromiseChildren) {
    return children.join("");
  }
  const suspended = Promise.all(children);
  suspended.then((childrenContent) => {
    setTimeout(() => {
      const id = BETH_GLOBAL_RENDER_CACHE.dismissChild(children);
      if (!id) {
        BETH_GLOBAL_RENDER_CACHE.streamController?.error("Suspense children not found");
        throw new Error("Suspense children not found");
      }
      const content = childrenContent.join("");
      let withScript = `
        <template id="N:${id}" data-replace>
            ${content}
        </template>
        <script>
            \$RC("N:${id}", "B:${id}");
        </script>
    `;
      if (!BETH_GLOBAL_RENDER_CACHE.sentFirstChunk) {
        withScript = swapScript + withScript;
        BETH_GLOBAL_RENDER_CACHE.sentFirstChunk = true;
      }
      BETH_GLOBAL_RENDER_CACHE.streamController?.enqueue(withScript);
      BETH_GLOBAL_RENDER_CACHE.checkIfEndAndClose();
    }, 0);
  });
  return fallback;
}
var swapScript = `
  <script>
    $RC = function(newId, oldId) {
      let newContentTemplate = document.querySelector(\`template[id="\${newId}"][data-replace]\`);
      let oldFallbackDiv = document.querySelector(\`div[id="\${oldId}"][data-fallback]\`);

      if (!newContentTemplate || !oldFallbackDiv) return;

      let fragment = document.createDocumentFragment();
      while (newContentTemplate.content.firstChild) {
          fragment.appendChild(newContentTemplate.content.firstChild);
      }
      
      // Replace the entire oldFallbackDiv with the new content
      oldFallbackDiv.parentNode.replaceChild(fragment, oldFallbackDiv);

      // Remove the newContentTemplate
      newContentTemplate.remove();
    };
  </script>
`;

// node_modules/@libsql/hrana-client/lib-es
function isUpper(input, index) {
  const code = input.charCodeAt(index);
  return code >= 65 && code <= 90;
}
function isVoidElement(tag) {
  return tag === "meta" || tag === "link" || tag === "img" || tag === "br" || tag === "input" || tag === "hr" || tag === "area" || tag === "base" || tag === "col" || tag === "command" || tag === "embed" || tag === "keygen" || tag === "param" || tag === "source" || tag === "track" || tag === "wbr";
}
function styleToString(style) {
  if (typeof style === "string") {
    let end = style.indexOf('"');
    if (end === -1) {
      return style;
    }
    const length2 = style.length;
    let escaped = "";
    let start = 0;
    for (;end < length2; end++) {
      if (style[end] === '"') {
        escaped += style.slice(start, end) + "&#34;";
        start = end + 1;
      }
    }
    escaped += style.slice(start, end);
    return escaped;
  }
  const keys = Object.keys(style);
  const length = keys.length;
  let key;
  let value2;
  let index = 0;
  let result = "";
  for (;index < length; index++) {
    key = keys[index];
    value2 = style[key];
    if (value2 === null || value2 === undefined) {
      continue;
    }
    result += toKebabCase(key) + ":";
    if (typeof value2 !== "string") {
      result += value2.toString() + ";";
      continue;
    }
    let end = value2.indexOf('"');
    if (end === -1) {
      result += value2 + ";";
      continue;
    }
    const length2 = value2.length;
    let start = 0;
    for (;end < length2; end++) {
      if (value2[end] === '"') {
        result += value2.slice(start, end) + "&#34;";
        start = end + 1;
      }
    }
    result += value2.slice(start, end) + ";";
  }
  return result;
}
function attributesToString(attributes) {
  if (!attributes) {
    return "";
  }
  const keys = Object.keys(attributes);
  const length = keys.length;
  let key, value2, type;
  let result = "";
  let index = 0;
  for (;index < length; index++) {
    key = keys[index];
    if (key === "children" || key === "safe") {
      continue;
    }
    value2 = attributes[key];
    if (key === "className") {
      if (attributes.class !== undefined) {
        continue;
      }
      key = "class";
    }
    if (key === "style") {
      result += ' style="' + styleToString(value2) + '"';
      continue;
    }
    type = typeof value2;
    if (type === "boolean") {
      if (value2) {
        result += " " + key;
      }
      continue;
    }
    if (value2 === null || value2 === undefined) {
      continue;
    }
    result += " " + key;
    if (type !== "string") {
      if (type !== "object") {
        result += '="' + value2.toString() + '"';
        continue;
      } else if (value2 instanceof Date) {
        result += '="' + value2.toISOString() + '"';
        continue;
      }
      value2 = value2.toString();
    }
    let end = value2.indexOf('"');
    if (end === -1) {
      result += '="' + value2 + '"';
      continue;
    }
    result += '="';
    const length2 = value2.length;
    let start = 0;
    for (;end < length2; end++) {
      if (value2[end] === '"') {
        result += value2.slice(start, end) + "&#34;";
        start = end + 1;
      }
    }
    result += value2.slice(start, end) + '"';
  }
  return result;
}
function toKebabCase(camel) {
  if (!CAMEL_REGEX.test(camel)) {
    return camel;
  }
  const length = camel.length;
  let start = 0;
  let end = 0;
  let kebab = "";
  let prev = true;
  let curr = isUpper(camel, 0);
  let next;
  for (;end < length; end++) {
    next = isUpper(camel, end + 1);
    if (!prev && curr && !next) {
      kebab += camel.slice(start, end) + "-" + camel[end].toLowerCase();
      start = end + 1;
    }
    prev = curr;
    curr = next;
  }
  kebab += camel.slice(start, end);
  return kebab;
}
function contentsToString(contents, escape) {
  const length = contents.length;
  if (length === 0) {
    return "";
  }
  let result = "";
  let content;
  let index = 0;
  for (;index < length; index++) {
    content = contents[index];
    if (!content && content !== 0) {
      continue;
    }
    if (Array.isArray(content)) {
      result += contentsToString(content, escape);
    } else if (escape === true) {
      result += Bun.escapeHTML(content);
    } else {
      result += content;
    }
  }
  return result;
}
function deepFlatten(arr) {
  return arr.reduce((acc, val) => {
    return Array.isArray(val) ? acc.concat(deepFlatten(val)) : acc.concat(val);
  }, []);
}
var CAMEL_REGEX = /[a-z][A-Z]/;

// node_modules/@libsql/hrana-client/lib-es
async function createElement(name, attributes, ...children) {
  children = deepFlatten(children);
  const hasAnyPromiseChildren = children.reduce((acc, child) => acc || child instanceof Promise, false);
  const hasAnyUnresolvedPromiseChildren = children.reduce((acc, child) => acc || Bun.peek.status(child) !== "fulfilled", false);
  const insideStreamCall = BETH_GLOBAL_RENDER_CACHE.streamController !== undefined;
  if (name === Suspense && hasAnyUnresolvedPromiseChildren && insideStreamCall) {
    const id = BETH_GLOBAL_RENDER_CACHE.registerChild(children);
    if (attributes !== null && ("fallback" in attributes)) {
      attributes.fallback = `
        <div id="B:${id}" data-fallback>
        ${await attributes.fallback}
        </div>
      `;
    }
  } else if (name !== ErrorBoundary) {
    if (hasAnyPromiseChildren) {
      children = await Promise.all(children);
    }
  }
  if (attributes === null) {
    attributes = { children };
  }
  if (typeof name === "function") {
    if (attributes.children === undefined) {
      attributes.children = children;
    }
    return name(attributes);
  }
  if (name === Fragment) {
    return contentsToString(children);
  }
  if (name === "tag" && ("of" in attributes)) {
    name = String(attributes.of);
    delete attributes.of;
  }
  if (children.length === 0 && isVoidElement(name)) {
    return "<" + name + attributesToString(attributes) + "/>";
  }
  return "<" + name + attributesToString(attributes) + ">" + contentsToString(children, ("safe" in attributes) && typeof attributes.safe === "boolean" && attributes.safe) + "</" + name + ">";
}
var compile = function(cleanComponent, strict = true, separator = "/*\0*/") {
  const properties = new Set;
  const html = cleanComponent(new Proxy({}, {
    get(_, name) {
      properties.add(name);
      const isChildren = name === "children";
      let access = `args[${separator}\`${name.toString()}\`${separator}]`;
      if (isChildren) {
        access = `Array.isArray(${access}) ? ${access}.join(${separator}\`\`${separator}) : ${access}`;
      }
      return `\`${separator} + (${access} || ${strict && !isChildren ? `throwPropertyNotFound(${separator}\`${name.toString()}\`${separator})` : `${separator}\`\`${separator}`}) + ${separator}\``;
    }
  }));
  const sepLength = separator.length;
  const length = html.length;
  let body = "";
  let nextStart = 0;
  let index = 0;
  for (;index < length; index++) {
    if (html[index] === "`" && html.slice(index - sepLength, index) !== separator && html.slice(index + 1, index + sepLength + 1) !== separator) {
      body += html.slice(nextStart, index) + "\\`";
      nextStart = index + 1;
      continue;
    }
    if (html[index] === "\\") {
      body += html.slice(nextStart, index) + "\\\\";
      nextStart = index + 1;
      continue;
    }
  }
  body += html.slice(nextStart);
  if (strict) {
    return Function("args", 'if (args === undefined) { throw new Error("The arguments object was not provided.") };\nfunction throwPropertyNotFound(name) { throw new Error("Property " + name + " was not provided.") };\n' + `return \`${body}\``);
  }
  return Function("args", "if (args === undefined) { args = Object.create(null) };\n" + `return \`${body}\``);
};

// node_modules/@libsql/hrana-client/lib-esm
function renderToString(lazyHtml) {
  BETH_GLOBAL_RENDER_CACHE.reset();
  const resultPromise = lazyHtml();
  return resultPromise;
}
async function renderToStringResponse(lazyHtml) {
  const result = await renderToString(lazyHtml);
  return new Response(result, {
    headers: {
      "Content-Type": "text/html; charset=utf-8"
    }
  });
}
function renderToStreamResponse(lazyHtml) {
  const stream2 = renderToStream(lazyHtml);
  return new Response(stream2, {
    headers: {
      "Content-Type": "text/html; charset=utf-8"
    }
  });
}
function renderToStream(lazyHtml) {
  BETH_GLOBAL_RENDER_CACHE.reset();
  const stream2 = new ReadableStream({
    start(c) {
      BETH_GLOBAL_RENDER_CACHE.streamController = c;
      lazyHtml().then((data) => {
        BETH_GLOBAL_RENDER_CACHE.streamController?.enqueue(data);
        BETH_GLOBAL_RENDER_CACHE.checkIfEndAndClose();
      }).catch((error5) => {
        console.error("Error in promise:", error5);
        BETH_GLOBAL_RENDER_CACHE.streamController?.error(error5);
        BETH_GLOBAL_RENDER_CACHE.closeNow();
      });
    }
  });
  return stream2;
}
// node_modules/@libsql/hrana-client/lib-esm/e
class GlobalContextContext {
  stack = new Array;
  map = new Map;
  set(context, value2) {
    this.map.set(context.id, value2);
  }
  get(context) {
    return this.map.get(context.id) ?? null;
  }
  push(id) {
    this.stack.push(id);
  }
  pop() {
    const id = this.stack.pop();
    if (!id) {
      throw new Error("Context stack is empty");
    }
    this.map.delete(id);
  }
}
var GLOBAL_CONTEXT_CONTEXT = new GlobalContextContext;

class Context {
  id = Symbol("context");
  Provider = ({
    children,
    value: value2
  }) => {
    GLOBAL_CONTEXT_CONTEXT.push(this.id);
    GLOBAL_CONTEXT_CONTEXT.set(this, value2);
    const [fn] = children;
    const result = fn(value2);
    GLOBAL_CONTEXT_CONTEXT.pop();
    return Html.createElement(Html.Fragment, null, result);
  };
}

// node_modules/@libsql/hrana-client/lib-es
var Fragment = Symbol.for("beth-stack-fragment");
var jsx_default = {
  createElement,
  Fragment,
  compile
};

// node_modules/@libsql/hrana-client/lib-esm/e
globalThis.Html = jsx_default;

// node_modules/@libsql/hrana-client/lib-esm/e
function bethStack(options = {}) {
  async function html(lazyHtml) {
    return renderToStringResponse(lazyHtml);
  }
  function htmlStream(lazyHtml) {
    return renderToStreamResponse(lazyHtml);
  }
  return function bethPlugin(app) {
    return app.decorate("html", html).decorate("htmlStream", htmlStream);
  };
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/pr
var createPreparedStatementHelper = (placeholder) => {
  const helper = (values) => {
    const keys = Object.keys(values);
    return [
      keys.map((k) => escapeName(k)),
      keys.map((_, i) => placeholder(i)),
      keys.map((k) => values[k])
    ];
  };
  return helper;
};
var escapeName = (val) => {
  return `${ESCAPE_CHAR}${val}${ESCAPE_CHAR}`;
};
var ESCAPE_CHAR = "`";
var helper = createPreparedStatementHelper(() => "?");
var getSetArgs = (fields, placeholders) => {
  return fields.map((field, i) => [field, placeholders[i]].join(" = ")).join(",");
};
// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/ut
var libsqlAdapter = (db, tables) => {
  const ESCAPED_USER_TABLE_NAME = escapeName(tables.user);
  const ESCAPED_SESSION_TABLE_NAME = tables.session ? escapeName(tables.session) : null;
  const ESCAPED_KEY_TABLE_NAME = escapeName(tables.key);
  return (LuciaError2) => {
    return {
      getUser: async (userId) => {
        const result = await db.execute({
          sql: `SELECT * FROM ${ESCAPED_USER_TABLE_NAME} WHERE id = ?`,
          args: [userId]
        });
        const rows = result.rows;
        return rows.at(0) ?? null;
      },
      setUser: async (user, key) => {
        const [userFields, userValues, userArgs] = helper(user);
        const insertUserQuery = {
          sql: `INSERT INTO ${ESCAPED_USER_TABLE_NAME} ( ${userFields} ) VALUES ( ${userValues} )`,
          args: userArgs
        };
        if (!key) {
          await db.execute(insertUserQuery);
          return;
        }
        try {
          const [keyFields, keyValues, keyArgs] = helper(key);
          const insertKeyQuery = {
            sql: `INSERT INTO ${ESCAPED_KEY_TABLE_NAME} ( ${keyFields} ) VALUES ( ${keyValues} )`,
            args: keyArgs
          };
          await db.batch([insertUserQuery, insertKeyQuery], "write");
        } catch (e2) {
          const error6 = e2;
          if (error6.code === "SQLITE_CONSTRAINT_PRIMARYKEY" && error6.message?.includes(".id")) {
            throw new LuciaError2("AUTH_DUPLICATE_KEY_ID");
          }
          throw e2;
        }
      },
      deleteUser: async (userId) => {
        await db.execute({
          sql: `DELETE FROM ${ESCAPED_USER_TABLE_NAME} WHERE id = ?`,
          args: [userId]
        });
      },
      updateUser: async (userId, partialUser) => {
        const [fields, values, args2] = helper(partialUser);
        args2.push(userId);
        await db.execute({
          sql: `UPDATE ${ESCAPED_USER_TABLE_NAME} SET ${getSetArgs(fields, values)} WHERE id = ?`,
          args: args2
        });
      },
      getSession: async (sessionId) => {
        if (!ESCAPED_SESSION_TABLE_NAME) {
          throw new Error("Session table not defined");
        }
        const result = await db.execute({
          sql: `SELECT * FROM ${ESCAPED_SESSION_TABLE_NAME} WHERE id = ?`,
          args: [sessionId]
        });
        const rows = result.rows;
        return rows.at(0) ?? null;
      },
      getSessionsByUserId: async (userId) => {
        if (!ESCAPED_SESSION_TABLE_NAME) {
          throw new Error("Session table not defined");
        }
        const result = await db.execute({
          sql: `SELECT * FROM ${ESCAPED_SESSION_TABLE_NAME} WHERE user_id = ?`,
          args: [userId]
        });
        return result.rows;
      },
      setSession: async (session2) => {
        if (!ESCAPED_SESSION_TABLE_NAME) {
          throw new Error("Session table not defined");
        }
        try {
          const [fields, values, args2] = helper(session2);
          await db.execute({
            sql: `INSERT INTO ${ESCAPED_SESSION_TABLE_NAME} ( ${fields} ) VALUES ( ${values} )`,
            args: args2
          });
        } catch (e2) {
          const error6 = e2;
          if (error6.code === "SQLITE_CONSTRAINT_FOREIGNKEY") {
            throw new LuciaError2("AUTH_INVALID_USER_ID");
          }
          throw e2;
        }
      },
      deleteSession: async (sessionId) => {
        if (!ESCAPED_SESSION_TABLE_NAME) {
          throw new Error("Session table not defined");
        }
        await db.execute({
          sql: `DELETE FROM ${ESCAPED_SESSION_TABLE_NAME} WHERE id = ?`,
          args: [sessionId]
        });
      },
      deleteSessionsByUserId: async (userId) => {
        if (!ESCAPED_SESSION_TABLE_NAME) {
          throw new Error("Session table not defined");
        }
        await db.execute({
          sql: `DELETE FROM ${ESCAPED_SESSION_TABLE_NAME} WHERE user_id = ?`,
          args: [userId]
        });
      },
      updateSession: async (sessionId, partialSession) => {
        if (!ESCAPED_SESSION_TABLE_NAME) {
          throw new Error("Session table not defined");
        }
        const [fields, values, args2] = helper(partialSession);
        const setArgs = getSetArgs(fields, values);
        args2.push(sessionId);
        await db.execute({
          sql: `UPDATE ${ESCAPED_SESSION_TABLE_NAME} SET ${setArgs} WHERE id = ?`,
          args: args2
        });
      },
      getKey: async (keyId) => {
        const result = await db.execute({
          sql: `SELECT * FROM ${ESCAPED_KEY_TABLE_NAME} WHERE id = ?`,
          args: [keyId]
        });
        const rows = result.rows;
        return rows.at(0) ?? null;
      },
      getKeysByUserId: async (userId) => {
        const result = await db.execute({
          sql: `SELECT * FROM ${ESCAPED_KEY_TABLE_NAME} WHERE user_id = ?`,
          args: [userId]
        });
        return result.rows;
      },
      setKey: async (key) => {
        try {
          const [fields, values, args2] = helper(key);
          await db.execute({
            sql: `INSERT INTO ${ESCAPED_KEY_TABLE_NAME} ( ${fields} ) VALUES ( ${values} )`,
            args: args2
          });
        } catch (e2) {
          const error6 = e2;
          if (error6.code === "SQLITE_CONSTRAINT_FOREIGNKEY") {
            throw new LuciaError2("AUTH_INVALID_USER_ID");
          }
          if (error6.code === "SQLITE_CONSTRAINT_PRIMARYKEY" && error6.message?.includes(".id")) {
            throw new LuciaError2("AUTH_DUPLICATE_KEY_ID");
          }
          throw e2;
        }
      },
      deleteKey: async (keyId) => {
        await db.execute({
          sql: `DELETE FROM ${ESCAPED_KEY_TABLE_NAME} WHERE id = ?`,
          args: [keyId]
        });
      },
      deleteKeysByUserId: async (userId) => {
        await db.execute({
          sql: `DELETE FROM ${ESCAPED_KEY_TABLE_NAME} WHERE user_id = ?`,
          args: [userId]
        });
      },
      updateKey: async (keyId, partialKey) => {
        const [fields, values, args2] = helper(partialKey);
        const setArgs = getSetArgs(fields, values);
        args2.push(keyId);
        await db.execute({
          sql: `UPDATE ${ESCAPED_KEY_TABLE_NAME} SET ${setArgs} WHERE id = ?`,
          args: args2
        });
      }
    };
  };
};
// node_modules/@libsql/hrana-client/lib-esm/encoding/
class OAuthRequestError extends Error {
  request;
  response;
  message = "OAUTH_REQUEST_FAILED";
  constructor(request4, response) {
    super("OAUTH_REQUEST_FAILED");
    this.request = request4;
    this.response = response;
  }
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/p
var handleRequest = async (request5) => {
  request5.headers.set("User-Agent", "lucia");
  request5.headers.set("Accept", "application/json");
  const response = await fetch(request5);
  if (!response.ok) {
    throw new OAuthRequestError(request5, response);
  }
  return await response.json();
};
var createUrl = (url3, urlSearchParams) => {
  const newUrl = new URL(url3);
  for (const [key, value2] of Object.entries(urlSearchParams)) {
    if (!value2)
      continue;
    newUrl.searchParams.set(key, value2);
  }
  return newUrl;
};
var authorizationHeader = (type, token) => {
  if (type === "basic") {
    return ["Basic", token].join(" ");
  }
  if (type === "bearer") {
    return ["Bearer", token].join(" ");
  }
  throw new TypeError("Invalid token type");
};

// node_modules/@libsql/hrana-client/lib-esm/encoding/
var isDeno = () => {
  return typeof window !== "undefined" && ("Deno" in window);
};
var encodeBase64 = (data) => {
  if (isDeno()) {
    if (typeof data === "string")
      return btoa(data);
    return btoa(String.fromCharCode(...new Uint8Array(data)));
  }
  if (typeof Buffer === "function") {
    const bufferData = typeof data === "string" ? data : new Uint8Array(data);
    return Buffer.from(bufferData).toString("base64");
  }
  if (typeof data === "string")
    return btoa(data);
  return btoa(String.fromCharCode(...new Uint8Array(data)));
};
// node_modules/@libsql/hrana-client/lib-esm/encoding
class OAuth2ProviderAuth {
  auth;
  constructor(auth) {
    this.auth = auth;
  }
}
var createOAuth2AuthorizationUrl = async (url3, options) => {
  const state = generateState();
  const authorizationUrl = createUrl(url3, {
    response_type: "code",
    client_id: options.clientId,
    scope: options.scope.join(" "),
    state,
    redirect_uri: options.redirectUri
  });
  return [authorizationUrl, state];
};
var validateOAuth2AuthorizationCode = async (authorizationCode, url3, options) => {
  const body = new URLSearchParams({
    code: authorizationCode,
    client_id: options.clientId,
    grant_type: "authorization_code"
  });
  if (options.redirectUri) {
    body.set("redirect_uri", options.redirectUri);
  }
  if (options.codeVerifier) {
    body.set("code_verifier", options.codeVerifier);
  }
  if (options.clientPassword && options.clientPassword.authenticateWith === "client_secret") {
    body.set("client_secret", options.clientPassword.clientSecret);
  }
  const headers = new Headers({
    "Content-Type": "application/x-www-form-urlencoded"
  });
  if (options.clientPassword && options.clientPassword.authenticateWith === "http_basic_auth") {
    headers.set("Authorization", authorizationHeader("basic", encodeBase64(`${options.clientId}:${options.clientPassword.clientSecret}`)));
  }
  const request6 = new Request(new URL(url3), {
    method: "POST",
    headers,
    body
  });
  return await handleRequest(request6);
};
var generateState = () => {
  return generateRandomString(43);
};

// node_modules/@libsql/hrana-client/lib-esm/encoding/p
class ProviderUserAuth {
  auth;
  providerId;
  providerUserId;
  constructor(auth, providerId, providerUserId) {
    this.auth = auth;
    this.providerId = providerId;
    this.providerUserId = providerUserId;
  }
  getExistingUser = async () => {
    try {
      const key = await this.auth.useKey(this.providerId, this.providerUserId, null);
      const user = await this.auth.getUser(key.userId);
      return user;
    } catch (e2) {
      const error6 = e2;
      if (error6?.message !== "AUTH_INVALID_KEY_ID")
        throw e2;
      return null;
    }
  };
  createKey = async (userId) => {
    return await this.auth.createKey({
      userId,
      providerId: this.providerId,
      providerUserId: this.providerUserId,
      password: null
    });
  };
  createUser = async (options) => {
    const user = await this.auth.createUser({
      key: {
        providerId: this.providerId,
        providerUserId: this.providerUserId,
        password: null
      },
      ...options
    });
    return user;
  };
}

// node_modules/@libsql/hrana-client/lib-esm/encodi
var decoder = new TextDecoder;

// node_modules/@libsql/hrana-client/lib-esm/encodi
var encoder = new TextEncoder;
// node_modules/@libsql/hrana-client/lib-esm/encoding/prot
var PROVIDER_ID = "github";
var github = (auth, config4) => {
  return new GithubAuth(auth, config4);
};

class GithubAuth extends OAuth2ProviderAuth {
  config;
  constructor(auth, config4) {
    super(auth);
    this.config = config4;
  }
  getAuthorizationUrl = async () => {
    return await createOAuth2AuthorizationUrl("https://github.com/login/oauth/authorize", {
      clientId: this.config.clientId,
      scope: this.config.scope ?? [],
      redirectUri: this.config.redirectUri
    });
  };
  validateCallback = async (code) => {
    const githubTokens = await this.validateAuthorizationCode(code);
    const githubUser = await getGithubUser(githubTokens.accessToken);
    return new GithubUserAuth(this.auth, githubUser, githubTokens);
  };
  validateAuthorizationCode = async (code) => {
    const tokens = await validateOAuth2AuthorizationCode(code, "https://github.com/login/oauth/access_token", {
      clientId: this.config.clientId,
      clientPassword: {
        clientSecret: this.config.clientSecret,
        authenticateWith: "client_secret"
      }
    });
    if ("refresh_token" in tokens) {
      return {
        accessToken: tokens.access_token,
        accessTokenExpiresIn: tokens.expires_in,
        refreshToken: tokens.refresh_token,
        refreshTokenExpiresIn: tokens.refresh_token_expires_in
      };
    }
    return {
      accessToken: tokens.access_token,
      accessTokenExpiresIn: null
    };
  };
}
var getGithubUser = async (accessToken) => {
  const githubUserRequest = new Request("https://api.github.com/user", {
    headers: {
      Authorization: authorizationHeader("bearer", accessToken)
    }
  });
  return await handleRequest(githubUserRequest);
};

class GithubUserAuth extends ProviderUserAuth {
  githubTokens;
  githubUser;
  constructor(auth, githubUser, githubTokens) {
    super(auth, PROVIDER_ID, githubUser.id.toString());
    this.githubTokens = githubTokens;
    this.githubUser = githubUser;
  }
}
// node_modules/@libsql/hrana-client/lib-esm/
class LibsqlError extends Error {
  code;
  constructor(message, code, cause) {
    if (code !== undefined) {
      message = `${code}: ${message}`;
    }
    super(message, { cause });
    this.code = code;
    this.name = "LibsqlError";
  }
}

// node_modules/@libsql/hrana-client/lib-esm/
function parseUri(text) {
  const match = URI_RE.exec(text);
  if (match === null) {
    throw new LibsqlError("The URL is not in a valid format", "URL_INVALID");
  }
  const groups = match.groups;
  const scheme = groups["scheme"];
  const authority = groups["authority"] !== undefined ? parseAuthority(groups["authority"]) : undefined;
  const path = percentDecode(groups["path"]);
  const query = groups["query"] !== undefined ? parseQuery(groups["query"]) : undefined;
  const fragment = groups["fragment"] !== undefined ? percentDecode(groups["fragment"]) : undefined;
  return { scheme, authority, path, query, fragment };
}
var parseAuthority = function(text) {
  const match = AUTHORITY_RE.exec(text);
  if (match === null) {
    throw new LibsqlError("The authority part of the URL is not in a valid format", "URL_INVALID");
  }
  const groups = match.groups;
  const host = percentDecode(groups["host_br"] ?? groups["host"]);
  const port = groups["port"] ? parseInt(groups["port"], 10) : undefined;
  const userinfo = groups["username"] !== undefined ? {
    username: percentDecode(groups["username"]),
    password: groups["password"] !== undefined ? percentDecode(groups["password"]) : undefined
  } : undefined;
  return { host, port, userinfo };
};
var parseQuery = function(text) {
  const sequences = text.split("&");
  const pairs = [];
  for (const sequence of sequences) {
    if (sequence === "") {
      continue;
    }
    let key;
    let value2;
    const splitIdx = sequence.indexOf("=");
    if (splitIdx < 0) {
      key = sequence;
      value2 = "";
    } else {
      key = sequence.substring(0, splitIdx);
      value2 = sequence.substring(splitIdx + 1);
    }
    pairs.push({
      key: percentDecode(key.replaceAll("+", " ")),
      value: percentDecode(value2.replaceAll("+", " "))
    });
  }
  return { pairs };
};
var percentDecode = function(text) {
  try {
    return decodeURIComponent(text);
  } catch (e2) {
    if (e2 instanceof URIError) {
      throw new LibsqlError(`URL component has invalid percent encoding: ${e2}`, "URL_INVALID", e2);
    }
    throw e2;
  }
};
function encodeBaseUrl(scheme, authority, path) {
  if (authority === undefined) {
    throw new LibsqlError(`URL with scheme ${JSON.stringify(scheme + ":")} requires authority (the "//" part)`, "URL_INVALID");
  }
  const schemeText = `${scheme}:`;
  const hostText = encodeHost(authority.host);
  const portText = encodePort(authority.port);
  const userinfoText = encodeUserinfo(authority.userinfo);
  const authorityText = `//${userinfoText}${hostText}${portText}`;
  let pathText = path.split("/").map(encodeURIComponent).join("/");
  if (pathText !== "" && !pathText.startsWith("/")) {
    pathText = "/" + pathText;
  }
  return new URL(`${schemeText}${authorityText}${pathText}`);
}
var encodeHost = function(host) {
  return host.includes(":") ? `[${encodeURI(host)}]` : encodeURI(host);
};
var encodePort = function(port) {
  return port !== undefined ? `:${port}` : "";
};
var encodeUserinfo = function(userinfo) {
  if (userinfo === undefined) {
    return "";
  }
  const usernameText = encodeURIComponent(userinfo.username);
  const passwordText = userinfo.password !== undefined ? `:${encodeURIComponent(userinfo.password)}` : "";
  return `${usernameText}${passwordText}@`;
};
var URI_RE = (() => {
  const SCHEME = "(?<scheme>[A-Za-z][A-Za-z.+-]*)";
  const AUTHORITY = "(?<authority>[^/?#]*)";
  const PATH = "(?<path>[^?#]*)";
  const QUERY = "(?<query>[^#]*)";
  const FRAGMENT = "(?<fragment>.*)";
  return new RegExp(`^${SCHEME}:(//${AUTHORITY})?${PATH}(\\?${QUERY})?(#${FRAGMENT})?\$`, "su");
})();
var AUTHORITY_RE = (() => {
  const USERINFO = "(?<username>[^:]*)(:(?<password>.*))?";
  const HOST = "((?<host>[^:\\[\\]]*)|(\\[(?<host_br>[^\\[\\]]*)\\]))";
  const PORT = "(?<port>[0-9]*)";
  return new RegExp(`^(${USERINFO}@)?${HOST}(:${PORT})?\$`, "su");
})();

// node_modules/@libsql/hrana-client
var version = "3.7.5";
var VERSION = version;
var _hasatob = typeof atob === "function";
var _hasbtoa = typeof btoa === "function";
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder : undefined;
var _TE = typeof TextEncoder === "function" ? new TextEncoder : undefined;
var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = ((a) => {
  let tab = {};
  a.forEach((c, i) => tab[c] = i);
  return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
var _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
var _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\+\/]/g, "");
var btoaPolyfill = (bin) => {
  let u322, c0, c13, c2, asc = "";
  const pad = bin.length % 3;
  for (let i = 0;i < bin.length; ) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c13 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
      throw new TypeError("invalid character found");
    u322 = c0 << 16 | c13 << 8 | c2;
    asc += b64chs[u322 >> 18 & 63] + b64chs[u322 >> 12 & 63] + b64chs[u322 >> 6 & 63] + b64chs[u322 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
var _btoa = _hasbtoa ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
var _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i = 0, l = u8a.length;i < l; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(""));
};
var fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
var cb_utob = (c) => {
  if (c.length < 2) {
    var cc = c.charCodeAt(0);
    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  } else {
    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  }
};
var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
var utob = (u) => u.replace(re_utob, cb_utob);
var _encode = _hasBuffer ? (s) => Buffer.from(s, "utf8").toString("base64") : _TE ? (s) => _fromUint8Array(_TE.encode(s)) : (s) => _btoa(utob(s));
var encode4 = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
var encodeURI2 = (src) => encode4(src, true);
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
var btou = (b) => b.replace(re_btou, cb_btou);
var atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r2;
  for (let i = 0;i < asc.length; ) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
var _atob = _hasatob ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, "base64")) : (a) => _U8Afrom(_atob(a).split("").map((c) => c.charCodeAt(0)));
var toUint8Array = (a) => _toUint8Array(_unURI(a));
var _decode = _hasBuffer ? (a) => Buffer.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
var _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
var decode = (src) => _decode(_unURI(src));
var isValid2 = (src) => {
  if (typeof src !== "string")
    return false;
  const s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
};
var _noEnum = (v) => {
  return {
    value: v,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
var extendString = function() {
  const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
  _add("fromBase64", function() {
    return decode(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode4(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode4(this, true);
  });
  _add("toBase64URL", function() {
    return encode4(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array(this);
  });
};
var extendUint8Array = function() {
  const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
var extendBuiltins = () => {
  extendString();
  extendUint8Array();
};
var gBase64 = {
  version,
  VERSION,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode,
  toBase64: encode4,
  encode: encode4,
  encodeURI: encodeURI2,
  encodeURL: encodeURI2,
  utob,
  btou,
  decode,
  isValid: isValid2,
  fromUint8Array,
  toUint8Array,
  extendString,
  extendUint8Array,
  extendBuiltins
};

// node_modules/@libsql/hrana-client/lib-esm/e
function transactionModeToBegin(mode) {
  if (mode === "write") {
    return "BEGIN IMMEDIATE";
  } else if (mode === "read") {
    return "BEGIN TRANSACTION READONLY";
  } else if (mode === "deferred") {
    return "BEGIN DEFERRED";
  } else {
    throw RangeError('Unknown transaction mode, supported values are "write", "read" and "deferred"');
  }
}
var rowToJson = function(row) {
  return Array.prototype.map.call(row, valueToJson);
};
var valueToJson = function(value2) {
  if (typeof value2 === "bigint") {
    return "" + value2;
  } else if (value2 instanceof ArrayBuffer) {
    return gBase64.fromUint8Array(new Uint8Array(value2));
  } else {
    return value2;
  }
};
var supportedUrlLink = "https://github.com/libsql/libsql-client-ts#supported-urls";

class ResultSetImpl {
  columns;
  columnTypes;
  rows;
  rowsAffected;
  lastInsertRowid;
  constructor(columns, columnTypes, rows, rowsAffected, lastInsertRowid) {
    this.columns = columns;
    this.columnTypes = columnTypes;
    this.rows = rows;
    this.rowsAffected = rowsAffected;
    this.lastInsertRowid = lastInsertRowid;
  }
  toJSON() {
    return {
      columns: this.columns,
      columnTypes: this.columnTypes,
      rows: this.rows.map(rowToJson),
      rowsAffected: this.rowsAffected,
      lastInsertRowid: this.lastInsertRowid !== undefined ? "" + this.lastInsertRowid : null
    };
  }
}

// node_modules/@libsql/hrana-client/lib-esm/enc
function expandConfig(config4, preferHttp) {
  if (typeof config4 !== "object") {
    throw new TypeError(`Expected client configuration as object, got ${typeof config4}`);
  }
  const uri2 = parseUri(config4.url);
  let tls = config4.tls;
  let authToken = config4.authToken;
  for (const { key, value: value2 } of uri2.query?.pairs ?? []) {
    if (key === "authToken") {
      authToken = value2 ? value2 : undefined;
    } else if (key === "tls") {
      if (value2 === "0") {
        tls = false;
      } else if (value2 === "1") {
        tls = true;
      } else {
        throw new LibsqlError(`Unknown value for the "tls" query argument: ${JSON.stringify(value2)}. ` + 'Supported values are "0" and "1"', "URL_INVALID");
      }
    } else {
      throw new LibsqlError(`Unknown URL query parameter ${JSON.stringify(key)}`, "URL_PARAM_NOT_SUPPORTED");
    }
  }
  let syncUrl = config4.syncUrl;
  const uriScheme = uri2.scheme.toLowerCase();
  let scheme;
  if (uriScheme === "libsql") {
    if (tls === false) {
      if (uri2.authority?.port === undefined) {
        throw new LibsqlError('A "libsql:" URL with ?tls=0 must specify an explicit port', "URL_INVALID");
      }
      scheme = preferHttp ? "http" : "ws";
    } else {
      scheme = preferHttp ? "https" : "wss";
    }
  } else if (uriScheme === "http" || uriScheme === "ws") {
    scheme = uriScheme;
    tls ??= false;
  } else if (uriScheme === "https" || uriScheme === "wss" || uriScheme === "file") {
    scheme = uriScheme;
  } else {
    throw new LibsqlError('The client supports only "libsql:", "wss:", "ws:", "https:", "http:" and "file:" URLs, ' + `got ${JSON.stringify(uri2.scheme + ":")}. ` + `For more information, please read ${supportedUrlLink}`, "URL_SCHEME_NOT_SUPPORTED");
  }
  if (uri2.fragment !== undefined) {
    throw new LibsqlError(`URL fragments are not supported: ${JSON.stringify("#" + uri2.fragment)}`, "URL_INVALID");
  }
  const intMode = "" + (config4.intMode ?? "number");
  if (intMode !== "number" && intMode !== "bigint" && intMode !== "string") {
    throw new TypeError(`Invalid value for intMode, expected "number", "bigint" or "string",             got ${JSON.stringify(intMode)}`);
  }
  return {
    scheme,
    tls: tls ?? true,
    authority: uri2.authority,
    path: uri2.path,
    authToken,
    syncUrl,
    intMode,
    fetch: config4.fetch
  };
}

// node_modules/@libsql/hrana-client/lib-esm/enco
var import_libsql2 = __toESM(require_libsql(), 1);
import {Buffer as Buffer2} from "buffer";
function _createClient(config5) {
  if (config5.scheme !== "file") {
    throw new LibsqlError(`URL scheme ${JSON.stringify(config5.scheme + ":")} is not supported by the local sqlite3 client. ` + `For more information, please read ${supportedUrlLink}`, "URL_SCHEME_NOT_SUPPORTED");
  }
  const authority = config5.authority;
  if (authority !== undefined) {
    const host = authority.host.toLowerCase();
    if (host !== "" && host !== "localhost") {
      throw new LibsqlError(`Invalid host in file URL: ${JSON.stringify(authority.host)}. ` + 'A "file:" URL with an absolute path should start with one slash ("file:/absolute/path.db") or with three slashes ("file:///absolute/path.db"). ' + `For more information, please read ${supportedUrlLink}`, "URL_INVALID");
    }
    if (authority.port !== undefined) {
      throw new LibsqlError("File URL cannot have a port", "URL_INVALID");
    }
    if (authority.userinfo !== undefined) {
      throw new LibsqlError("File URL cannot have username and password", "URL_INVALID");
    }
  }
  const path = config5.path;
  const options = {
    authToken: config5.authToken,
    syncUrl: config5.syncUrl
  };
  const db = new import_libsql2.default(path, options);
  executeStmt(db, "SELECT 1 AS checkThatTheDatabaseCanBeOpened", config5.intMode);
  return new Sqlite3Client(db, config5.intMode);
}
var executeStmt = function(db, stmt, intMode) {
  let sql;
  let args2;
  if (typeof stmt === "string") {
    sql = stmt;
    args2 = [];
  } else {
    sql = stmt.sql;
    if (Array.isArray(stmt.args)) {
      args2 = stmt.args.map(valueToSql);
    } else {
      args2 = {};
      for (const name in stmt.args) {
        const argName = name[0] === "@" || name[0] === "$" || name[0] === ":" ? name.substring(1) : name;
        args2[argName] = valueToSql(stmt.args[name]);
      }
    }
  }
  try {
    const sqlStmt = db.prepare(sql);
    sqlStmt.safeIntegers(true);
    let returnsData = true;
    try {
      sqlStmt.raw(true);
    } catch {
      returnsData = false;
    }
    if (returnsData) {
      const columns = Array.from(sqlStmt.columns().map((col) => col.name));
      const columnTypes = Array.from(sqlStmt.columns().map((col) => col.type ?? ""));
      const rows = sqlStmt.all(args2).map((sqlRow) => {
        return rowFromSql(sqlRow, columns, intMode);
      });
      const rowsAffected = 0;
      const lastInsertRowid = undefined;
      return new ResultSetImpl(columns, columnTypes, rows, rowsAffected, lastInsertRowid);
    } else {
      const info = sqlStmt.run(args2);
      const rowsAffected = info.changes;
      const lastInsertRowid = BigInt(info.lastInsertRowid);
      return new ResultSetImpl([], [], [], rowsAffected, lastInsertRowid);
    }
  } catch (e2) {
    throw mapSqliteError(e2);
  }
};
var rowFromSql = function(sqlRow, columns, intMode) {
  const row = {};
  Object.defineProperty(row, "length", { value: sqlRow.length });
  for (let i = 0;i < sqlRow.length; ++i) {
    const value2 = valueFromSql(sqlRow[i], intMode);
    Object.defineProperty(row, i, { value: value2 });
    const column = columns[i];
    if (!Object.hasOwn(row, column)) {
      Object.defineProperty(row, column, { value: value2, enumerable: true });
    }
  }
  return row;
};
var valueFromSql = function(sqlValue, intMode) {
  if (typeof sqlValue === "bigint") {
    if (intMode === "number") {
      if (sqlValue < minSafeBigint || sqlValue > maxSafeBigint) {
        throw new RangeError("Received integer which cannot be safely represented as a JavaScript number");
      }
      return Number(sqlValue);
    } else if (intMode === "bigint") {
      return sqlValue;
    } else if (intMode === "string") {
      return "" + sqlValue;
    } else {
      throw new Error("Invalid value for IntMode");
    }
  } else if (sqlValue instanceof Buffer2) {
    return sqlValue.buffer;
  }
  return sqlValue;
};
var valueToSql = function(value2) {
  if (typeof value2 === "number") {
    if (!Number.isFinite(value2)) {
      throw new RangeError("Only finite numbers (not Infinity or NaN) can be passed as arguments");
    }
    return value2;
  } else if (typeof value2 === "bigint") {
    if (value2 < minInteger || value2 > maxInteger) {
      throw new RangeError("bigint is too large to be represented as a 64-bit integer and passed as argument");
    }
    return value2;
  } else if (typeof value2 === "boolean") {
    return value2 ? 1n : 0n;
  } else if (value2 instanceof ArrayBuffer) {
    return Buffer2.from(value2);
  } else if (value2 instanceof Date) {
    return value2.valueOf();
  } else if (value2 === undefined) {
    throw new TypeError("undefined cannot be passed as argument to the database");
  } else {
    return value2;
  }
};
var executeMultiple = function(db, sql) {
  try {
    db.exec(sql);
  } catch (e2) {
    throw mapSqliteError(e2);
  }
};
var mapSqliteError = function(e2) {
  if (e2 instanceof import_libsql2.default.SqliteError) {
    return new LibsqlError(e2.message, e2.code, e2);
  }
  return e2;
};

class Sqlite3Client {
  #db;
  #intMode;
  closed;
  protocol;
  constructor(db, intMode) {
    this.#db = db;
    this.#intMode = intMode;
    this.closed = false;
    this.protocol = "file";
  }
  async execute(stmt) {
    this.#checkNotClosed();
    return executeStmt(this.#db, stmt, this.#intMode);
  }
  async batch(stmts, mode = "deferred") {
    this.#checkNotClosed();
    try {
      executeStmt(this.#db, transactionModeToBegin(mode), this.#intMode);
      const resultSets = stmts.map((stmt) => {
        if (!this.#db.inTransaction) {
          throw new LibsqlError("The transaction has been rolled back", "TRANSACTION_CLOSED");
        }
        return executeStmt(this.#db, stmt, this.#intMode);
      });
      executeStmt(this.#db, "COMMIT", this.#intMode);
      return resultSets;
    } finally {
      if (this.#db.inTransaction) {
        executeStmt(this.#db, "ROLLBACK", this.#intMode);
      }
    }
  }
  async transaction(mode = "write") {
    executeStmt(this.#db, transactionModeToBegin(mode), this.#intMode);
    return new Sqlite3Transaction(this.#db, this.#intMode);
  }
  async executeMultiple(sql) {
    this.#checkNotClosed();
    try {
      return executeMultiple(this.#db, sql);
    } finally {
      if (this.#db.inTransaction) {
        executeStmt(this.#db, "ROLLBACK", this.#intMode);
      }
    }
  }
  async sync() {
    this.#checkNotClosed();
    await this.#db.sync();
  }
  close() {
    this.closed = true;
    this.#db.close();
  }
  #checkNotClosed() {
    if (this.closed) {
      throw new LibsqlError("The client is closed", "CLIENT_CLOSED");
    }
  }
}

class Sqlite3Transaction {
  #database;
  #intMode;
  constructor(database2, intMode) {
    this.#database = database2;
    this.#intMode = intMode;
  }
  async execute(stmt) {
    this.#checkNotClosed();
    return executeStmt(this.#database, stmt, this.#intMode);
  }
  async batch(stmts) {
    return stmts.map((stmt) => {
      this.#checkNotClosed();
      return executeStmt(this.#database, stmt, this.#intMode);
    });
  }
  async executeMultiple(sql) {
    this.#checkNotClosed();
    return executeMultiple(this.#database, sql);
  }
  async rollback() {
    if (!this.#database.open) {
      return;
    }
    this.#checkNotClosed();
    executeStmt(this.#database, "ROLLBACK", this.#intMode);
  }
  async commit() {
    this.#checkNotClosed();
    executeStmt(this.#database, "COMMIT", this.#intMode);
  }
  close() {
    if (this.#database.inTransaction) {
      executeStmt(this.#database, "ROLLBACK", this.#intMode);
    }
  }
  get closed() {
    return !this.#database.inTransaction;
  }
  #checkNotClosed() {
    if (this.closed) {
      throw new LibsqlError("The transaction is closed", "TRANSACTION_CLOSED");
    }
  }
}
var minSafeBigint = -9007199254740991n;
var maxSafeBigint = 9007199254740991n;
var minInteger = -9223372036854775808n;
var maxInteger = 9223372036854775807n;

// node_modules/@libsql/hrana-client/lib-esm/
var _WebSocket;
if (typeof WebSocket !== "undefined") {
  _WebSocket = WebSocket;
} else if (typeof global !== "undefined") {
  _WebSocket = global.WebSocket;
} else if (typeof window !== "undefined") {
  _WebSocket = window.WebSocket;
} else if (typeof self !== "undefined") {
  _WebSocket = self.WebSocket;
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/
class Client {
  constructor() {
    this.intMode = "number";
  }
  intMode;
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/
class ClientError extends Error {
  constructor(message) {
    super(message);
    this.name = "ClientError";
  }
}

class ProtoError extends ClientError {
  constructor(message) {
    super(message);
    this.name = "ProtoError";
  }
}

class ResponseError extends ClientError {
  code;
  proto;
  constructor(message, protoError) {
    super(message);
    this.name = "ResponseError";
    this.code = protoError.code;
    this.proto = protoError;
    this.stack = undefined;
  }
}

class ClosedError extends ClientError {
  constructor(message, cause) {
    if (cause !== undefined) {
      super(`${message}: ${cause}`);
      this.cause = cause;
    } else {
      super(message);
    }
    this.name = "ClosedError";
  }
}

class WebSocketUnsupportedError extends ClientError {
  constructor(message) {
    super(message);
    this.name = "WebSocketUnsupportedError";
  }
}

class WebSocketError extends ClientError {
  constructor(message) {
    super(message);
    this.name = "WebSocketError";
  }
}

class HttpServerError extends ClientError {
  status;
  constructor(message, status) {
    super(message);
    this.status = status;
    this.name = "HttpServerError";
  }
}
class ProtocolVersionError extends ClientError {
  constructor(message) {
    super(message);
    this.name = "ProtocolVersionError";
  }
}

class InternalError extends ClientError {
  constructor(message) {
    super(message);
    this.name = "InternalError";
  }
}

class MisuseError extends ClientError {
  constructor(message) {
    super(message);
    this.name = "MisuseError";
  }
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/util.
function string(value2) {
  if (typeof value2 === "string") {
    return value2;
  }
  throw typeError(value2, "string");
}
function stringOpt(value2) {
  if (value2 === null || value2 === undefined) {
    return;
  } else if (typeof value2 === "string") {
    return value2;
  }
  throw typeError(value2, "string or null");
}
function number(value2) {
  if (typeof value2 === "number") {
    return value2;
  }
  throw typeError(value2, "number");
}
function boolean(value2) {
  if (typeof value2 === "boolean") {
    return value2;
  }
  throw typeError(value2, "boolean");
}
function array(value2) {
  if (Array.isArray(value2)) {
    return value2;
  }
  throw typeError(value2, "array");
}
function object(value2) {
  if (value2 !== null && typeof value2 === "object" && !Array.isArray(value2)) {
    return value2;
  }
  throw typeError(value2, "object");
}
function arrayObjectsMap(value2, fun) {
  return array(value2).map((elemValue) => fun(object(elemValue)));
}
var typeError = function(value2, expected) {
  if (value2 === undefined) {
    return new ProtoError(`Expected ${expected}, but the property was missing`);
  }
  let received = typeof value2;
  if (value2 === null) {
    received = "null";
  } else if (Array.isArray(value2)) {
    received = "array";
  }
  return new ProtoError(`Expected ${expected}, received ${received}`);
};
function readJsonObject(value2, fun) {
  return fun(object(value2));
}
// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/util.
function writeJsonObject(value2, fun) {
  const output = [];
  const writer = new ObjectWriter(output);
  writer.begin();
  fun(writer, value2);
  writer.end();
  return output.join("");
}

class ObjectWriter {
  #output;
  #isFirst;
  constructor(output) {
    this.#output = output;
    this.#isFirst = false;
  }
  begin() {
    this.#output.push("{");
    this.#isFirst = true;
  }
  end() {
    this.#output.push("}");
    this.#isFirst = false;
  }
  #key(name) {
    if (this.#isFirst) {
      this.#output.push('"');
      this.#isFirst = false;
    } else {
      this.#output.push(',"');
    }
    this.#output.push(name);
    this.#output.push('":');
  }
  string(name, value2) {
    this.#key(name);
    this.#output.push(JSON.stringify(value2));
  }
  stringRaw(name, value2) {
    this.#key(name);
    this.#output.push('"');
    this.#output.push(value2);
    this.#output.push('"');
  }
  number(name, value2) {
    this.#key(name);
    this.#output.push("" + value2);
  }
  boolean(name, value2) {
    this.#key(name);
    this.#output.push(value2 ? "true" : "false");
  }
  object(name, value2, valueFun) {
    this.#key(name);
    this.begin();
    valueFun(this, value2);
    this.end();
  }
  arrayObjects(name, values, valueFun) {
    this.#key(name);
    this.#output.push("[");
    for (let i = 0;i < values.length; ++i) {
      if (i !== 0) {
        this.#output.push(",");
      }
      this.begin();
      valueFun(this, values[i]);
      this.end();
    }
    this.#output.push("]");
  }
}
// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/util.js
var VARINT = 0;
var FIXED_64 = 1;
var LENGTH_DELIMITED = 2;
var FIXED_32 = 5;

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/util.jsjs
function readProtobufMessage(data, def) {
  const msgReader = new MessageReader(data);
  const fieldReader = new FieldReader(msgReader);
  let value2 = def.default();
  while (!msgReader.eof()) {
    const key = msgReader.varint();
    const tag = key >> 3;
    const wireType = key & 7;
    fieldReader.setup(wireType);
    const tagFun = def[tag];
    if (tagFun !== undefined) {
      const returnedValue = tagFun(fieldReader, value2);
      if (returnedValue !== undefined) {
        value2 = returnedValue;
      }
    }
    fieldReader.maybeSkip();
  }
  return value2;
}

class MessageReader {
  #array;
  #view;
  #pos;
  constructor(array2) {
    this.#array = array2;
    this.#view = new DataView(array2.buffer, array2.byteOffset, array2.byteLength);
    this.#pos = 0;
  }
  varint() {
    let value2 = 0;
    for (let shift = 0;; shift += 7) {
      const byte = this.#array[this.#pos++];
      value2 |= (byte & 127) << shift;
      if (!(byte & 128)) {
        break;
      }
    }
    return value2;
  }
  varintBig() {
    let value2 = 0n;
    for (let shift = 0n;; shift += 7n) {
      const byte = this.#array[this.#pos++];
      value2 |= BigInt(byte & 127) << shift;
      if (!(byte & 128)) {
        break;
      }
    }
    return value2;
  }
  bytes(length) {
    const array2 = new Uint8Array(this.#array.buffer, this.#array.byteOffset + this.#pos, length);
    this.#pos += length;
    return array2;
  }
  double() {
    const value2 = this.#view.getFloat64(this.#pos, true);
    this.#pos += 8;
    return value2;
  }
  skipVarint() {
    for (;; ) {
      const byte = this.#array[this.#pos++];
      if (!(byte & 128)) {
        break;
      }
    }
  }
  skip(count) {
    this.#pos += count;
  }
  eof() {
    return this.#pos >= this.#array.byteLength;
  }
}

class FieldReader {
  #reader;
  #wireType;
  constructor(reader) {
    this.#reader = reader;
    this.#wireType = -1;
  }
  setup(wireType) {
    this.#wireType = wireType;
  }
  #expect(expectedWireType) {
    if (this.#wireType !== expectedWireType) {
      throw new ProtoError(`Expected wire type ${expectedWireType}, got ${this.#wireType}`);
    }
    this.#wireType = -1;
  }
  bytes() {
    this.#expect(LENGTH_DELIMITED);
    const length = this.#reader.varint();
    return this.#reader.bytes(length);
  }
  string() {
    return new TextDecoder().decode(this.bytes());
  }
  message(def) {
    return readProtobufMessage(this.bytes(), def);
  }
  int32() {
    this.#expect(VARINT);
    return this.#reader.varint();
  }
  uint32() {
    return this.int32();
  }
  bool() {
    return this.int32() !== 0;
  }
  uint64() {
    this.#expect(VARINT);
    return this.#reader.varintBig();
  }
  sint64() {
    const value2 = this.uint64();
    return value2 >> 1n ^ -(value2 & 1n);
  }
  double() {
    this.#expect(FIXED_64);
    return this.#reader.double();
  }
  maybeSkip() {
    if (this.#wireType < 0) {
      return;
    } else if (this.#wireType === VARINT) {
      this.#reader.skipVarint();
    } else if (this.#wireType === FIXED_64) {
      this.#reader.skip(8);
    } else if (this.#wireType === LENGTH_DELIMITED) {
      const length = this.#reader.varint();
      this.#reader.skip(length);
    } else if (this.#wireType === FIXED_32) {
      this.#reader.skip(4);
    } else {
      throw new ProtoError(`Unexpected wire type ${this.#wireType}`);
    }
    this.#wireType = -1;
  }
}
// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/util.jsjs
function writeProtobufMessage(value2, fun) {
  const w = new MessageWriter;
  fun(w, value2);
  return w.data();
}

class MessageWriter {
  #buf;
  #array;
  #view;
  #pos;
  constructor() {
    this.#buf = new ArrayBuffer(256);
    this.#array = new Uint8Array(this.#buf);
    this.#view = new DataView(this.#buf);
    this.#pos = 0;
  }
  #ensure(extra) {
    if (this.#pos + extra <= this.#buf.byteLength) {
      return;
    }
    let newCap = this.#buf.byteLength;
    while (newCap < this.#pos + extra) {
      newCap *= 2;
    }
    const newBuf = new ArrayBuffer(newCap);
    const newArray = new Uint8Array(newBuf);
    const newView = new DataView(newBuf);
    newArray.set(new Uint8Array(this.#buf, 0, this.#pos));
    this.#buf = newBuf;
    this.#array = newArray;
    this.#view = newView;
  }
  #varint(value2) {
    this.#ensure(5);
    value2 = 0 | value2;
    do {
      let byte = value2 & 127;
      value2 >>>= 7;
      byte |= value2 ? 128 : 0;
      this.#array[this.#pos++] = byte;
    } while (value2);
  }
  #varintBig(value2) {
    this.#ensure(10);
    value2 = value2 & 0xffffffffffffffffn;
    do {
      let byte = Number(value2 & 0x7fn);
      value2 >>= 7n;
      byte |= value2 ? 128 : 0;
      this.#array[this.#pos++] = byte;
    } while (value2);
  }
  #tag(tag, wireType) {
    this.#varint(tag << 3 | wireType);
  }
  bytes(tag, value2) {
    this.#tag(tag, LENGTH_DELIMITED);
    this.#varint(value2.byteLength);
    this.#ensure(value2.byteLength);
    this.#array.set(value2, this.#pos);
    this.#pos += value2.byteLength;
  }
  string(tag, value2) {
    this.bytes(tag, new TextEncoder().encode(value2));
  }
  message(tag, value2, fun) {
    const writer = new MessageWriter;
    fun(writer, value2);
    this.bytes(tag, writer.data());
  }
  int32(tag, value2) {
    this.#tag(tag, VARINT);
    this.#varint(value2);
  }
  uint32(tag, value2) {
    this.int32(tag, value2);
  }
  bool(tag, value2) {
    this.int32(tag, value2 ? 1 : 0);
  }
  sint64(tag, value2) {
    this.#tag(tag, VARINT);
    this.#varintBig(value2 << 1n ^ value2 >> 63n);
  }
  double(tag, value2) {
    this.#tag(tag, FIXED_64);
    this.#ensure(8);
    this.#view.setFloat64(this.#pos, value2, true);
    this.#pos += 8;
  }
  data() {
    return new Uint8Array(this.#buf, 0, this.#pos);
  }
}
// node_modules/@libsql/hrana-client/lib-esm/encoding/pr
class IdAlloc {
  #usedIds;
  #freeIds;
  constructor() {
    this.#usedIds = new Set;
    this.#freeIds = new Set;
  }
  alloc() {
    for (const freeId2 of this.#freeIds) {
      this.#freeIds.delete(freeId2);
      this.#usedIds.add(freeId2);
      if (!this.#usedIds.has(this.#usedIds.size - 1)) {
        this.#freeIds.add(this.#usedIds.size - 1);
      }
      return freeId2;
    }
    const freeId = this.#usedIds.size;
    this.#usedIds.add(freeId);
    return freeId;
  }
  free(id) {
    if (!this.#usedIds.delete(id)) {
      throw new InternalError("Freeing an id that is not allocated");
    }
    this.#freeIds.delete(this.#usedIds.size);
    if (id < this.#usedIds.size) {
      this.#freeIds.add(id);
    }
  }
}

// node_modules/@libsql/hrana-client/lib-esm/encodin
function impossible(value2, message) {
  throw new InternalError(message);
}

// node_modules/@libsql/hrana-client/lib-esm/encoding
function valueToProto(value2) {
  if (value2 === null) {
    return null;
  } else if (typeof value2 === "string") {
    return value2;
  } else if (typeof value2 === "number") {
    if (!Number.isFinite(value2)) {
      throw new RangeError("Only finite numbers (not Infinity or NaN) can be passed as arguments");
    }
    return value2;
  } else if (typeof value2 === "bigint") {
    if (value2 < minInteger2 || value2 > maxInteger2) {
      throw new RangeError("This bigint value is too large to be represented as a 64-bit integer and passed as argument");
    }
    return value2;
  } else if (typeof value2 === "boolean") {
    return value2 ? 1n : 0n;
  } else if (value2 instanceof ArrayBuffer) {
    return new Uint8Array(value2);
  } else if (value2 instanceof Uint8Array) {
    return value2;
  } else if (value2 instanceof Date) {
    return +value2.valueOf();
  } else if (typeof value2 === "object") {
    return "" + value2.toString();
  } else {
    throw new TypeError("Unsupported type of value");
  }
}
function valueFromProto(value2, intMode) {
  if (value2 === null) {
    return null;
  } else if (typeof value2 === "number") {
    return value2;
  } else if (typeof value2 === "string") {
    return value2;
  } else if (typeof value2 === "bigint") {
    if (intMode === "number") {
      const num = Number(value2);
      if (!Number.isSafeInteger(num)) {
        throw new RangeError("Received integer which is too large to be safely represented as a JavaScript number");
      }
      return num;
    } else if (intMode === "bigint") {
      return value2;
    } else if (intMode === "string") {
      return "" + value2;
    } else {
      throw new MisuseError("Invalid value for IntMode");
    }
  } else if (value2 instanceof Uint8Array) {
    return value2.slice().buffer;
  } else if (value2 === undefined) {
    throw new ProtoError("Received unrecognized type of Value");
  } else {
    throw impossible(value2, "Impossible type of Value");
  }
}
var minInteger2 = -9223372036854775808n;
var maxInteger2 = 9223372036854775807n;

// node_modules/@libsql/hrana-client/lib-esm/encoding/
function stmtResultFromProto(result) {
  return {
    affectedRowCount: result.affectedRowCount,
    lastInsertRowid: result.lastInsertRowid,
    columnNames: result.cols.map((col) => col.name),
    columnDecltypes: result.cols.map((col) => col.decltype)
  };
}
function rowsResultFromProto(result, intMode) {
  const stmtResult = stmtResultFromProto(result);
  const rows = result.rows.map((row) => rowFromProto(stmtResult.columnNames, row, intMode));
  return { ...stmtResult, rows };
}
function rowResultFromProto(result, intMode) {
  const stmtResult = stmtResultFromProto(result);
  let row;
  if (result.rows.length > 0) {
    row = rowFromProto(stmtResult.columnNames, result.rows[0], intMode);
  }
  return { ...stmtResult, row };
}
function valueResultFromProto(result, intMode) {
  const stmtResult = stmtResultFromProto(result);
  let value3;
  if (result.rows.length > 0 && stmtResult.columnNames.length > 0) {
    value3 = valueFromProto(result.rows[0][0], intMode);
  }
  return { ...stmtResult, value: value3 };
}
var rowFromProto = function(colNames, values, intMode) {
  const row = {};
  Object.defineProperty(row, "length", { value: values.length });
  for (let i = 0;i < values.length; ++i) {
    const value3 = valueFromProto(values[i], intMode);
    Object.defineProperty(row, i, { value: value3 });
    const colName = colNames[i];
    if (colName !== undefined && !Object.hasOwn(row, colName)) {
      Object.defineProperty(row, colName, { value: value3, enumerable: true });
    }
  }
  return row;
};
function errorFromProto(error6) {
  return new ResponseError(error6.message, error6);
}

// node_modules/@libsql/hrana-client/lib-esm/encodi
function sqlToProto(owner, sql) {
  if (sql instanceof Sql) {
    return { sqlId: sql._getSqlId(owner) };
  } else {
    return { sql: "" + sql };
  }
}

class Sql {
  #owner;
  #sqlId;
  #closed;
  constructor(owner, sqlId) {
    this.#owner = owner;
    this.#sqlId = sqlId;
    this.#closed = undefined;
  }
  _getSqlId(owner) {
    if (this.#owner !== owner) {
      throw new MisuseError("Attempted to use SQL text opened with other object");
    } else if (this.#closed !== undefined) {
      throw new ClosedError("SQL text is closed", this.#closed);
    }
    return this.#sqlId;
  }
  close() {
    this._setClosed(new ClientError("SQL text was manually closed"));
  }
  _setClosed(error6) {
    if (this.#closed === undefined) {
      this.#closed = error6;
      this.#owner._closeSql(this.#sqlId);
    }
  }
  get closed() {
    return this.#closed !== undefined;
  }
}

// node_modules/@libsql/hrana-client/lib-esm/encoding
class Queue {
  #pushStack;
  #shiftStack;
  constructor() {
    this.#pushStack = [];
    this.#shiftStack = [];
  }
  get length() {
    return this.#pushStack.length + this.#shiftStack.length;
  }
  push(elem) {
    this.#pushStack.push(elem);
  }
  shift() {
    if (this.#shiftStack.length === 0 && this.#pushStack.length > 0) {
      this.#shiftStack = this.#pushStack.reverse();
      this.#pushStack = [];
    }
    return this.#shiftStack.pop();
  }
  first() {
    return this.#shiftStack.length !== 0 ? this.#shiftStack[this.#shiftStack.length - 1] : this.#pushStack[0];
  }
}

// node_modules/@libsql/hrana-client/lib-esm/encodin
function stmtToProto(sqlOwner, stmt, wantRows) {
  let inSql;
  let args2 = [];
  let namedArgs = [];
  if (stmt instanceof Stmt) {
    inSql = stmt.sql;
    args2 = stmt._args;
    for (const [name, value4] of stmt._namedArgs.entries()) {
      namedArgs.push({ name, value: value4 });
    }
  } else if (Array.isArray(stmt)) {
    inSql = stmt[0];
    if (Array.isArray(stmt[1])) {
      args2 = stmt[1].map((arg) => valueToProto(arg));
    } else {
      namedArgs = Object.entries(stmt[1]).map(([name, value4]) => {
        return { name, value: valueToProto(value4) };
      });
    }
  } else {
    inSql = stmt;
  }
  const { sql: sql2, sqlId } = sqlToProto(sqlOwner, inSql);
  return { sql: sql2, sqlId, args: args2, namedArgs, wantRows };
}

class Stmt {
  sql;
  _args;
  _namedArgs;
  constructor(sql2) {
    this.sql = sql2;
    this._args = [];
    this._namedArgs = new Map;
  }
  bindIndexes(values) {
    this._args.length = 0;
    for (const value4 of values) {
      this._args.push(valueToProto(value4));
    }
    return this;
  }
  bindIndex(index, value4) {
    if (index !== (index | 0) || index <= 0) {
      throw new RangeError("Index of a positional argument must be positive integer");
    }
    while (this._args.length < index) {
      this._args.push(null);
    }
    this._args[index - 1] = valueToProto(value4);
    return this;
  }
  bindName(name, value4) {
    this._namedArgs.set(name, valueToProto(value4));
    return this;
  }
  unbindAll() {
    this._args.length = 0;
    this._namedArgs.clear();
    return this;
  }
}

// node_modules/@libsql/hrana-client/lib-esm/encoding
var executeRegular = function(stream2, steps, batch) {
  return stream2._batch(batch).then((result2) => {
    for (let step = 0;step < steps.length; ++step) {
      const stepResult = result2.stepResults.get(step);
      const stepError = result2.stepErrors.get(step);
      steps[step].callback(stepResult, stepError);
    }
  });
};
async function executeCursor(stream2, steps, batch) {
  const cursor = await stream2._openCursor(batch);
  try {
    let nextStep = 0;
    let beginEntry = undefined;
    let rows = [];
    for (;; ) {
      const entry = await cursor.next();
      if (entry === undefined) {
        break;
      }
      if (entry.type === "step_begin") {
        if (entry.step < nextStep || entry.step >= steps.length) {
          throw new ProtoError("Server produced StepBeginEntry for unexpected step");
        } else if (beginEntry !== undefined) {
          throw new ProtoError("Server produced StepBeginEntry before terminating previous step");
        }
        for (let step = nextStep;step < entry.step; ++step) {
          steps[step].callback(undefined, undefined);
        }
        nextStep = entry.step + 1;
        beginEntry = entry;
        rows = [];
      } else if (entry.type === "step_end") {
        if (beginEntry === undefined) {
          throw new ProtoError("Server produced StepEndEntry but no step is active");
        }
        const stmtResult = {
          cols: beginEntry.cols,
          rows,
          affectedRowCount: entry.affectedRowCount,
          lastInsertRowid: entry.lastInsertRowid
        };
        steps[beginEntry.step].callback(stmtResult, undefined);
        beginEntry = undefined;
        rows = [];
      } else if (entry.type === "step_error") {
        if (beginEntry === undefined) {
          if (entry.step >= steps.length) {
            throw new ProtoError("Server produced StepErrorEntry for unexpected step");
          }
          for (let step = nextStep;step < entry.step; ++step) {
            steps[step].callback(undefined, undefined);
          }
        } else {
          if (entry.step !== beginEntry.step) {
            throw new ProtoError("Server produced StepErrorEntry for unexpected step");
          }
          beginEntry = undefined;
          rows = [];
        }
        steps[entry.step].callback(undefined, entry.error);
        nextStep = entry.step + 1;
      } else if (entry.type === "row") {
        if (beginEntry === undefined) {
          throw new ProtoError("Server produced RowEntry but no step is active");
        }
        rows.push(entry.row);
      } else if (entry.type === "error") {
        throw errorFromProto(entry.error);
      } else if (entry.type === "none") {
        throw new ProtoError("Server produced unrecognized CursorEntry");
      } else {
        throw impossible(entry, "Impossible CursorEntry");
      }
    }
    if (beginEntry !== undefined) {
      throw new ProtoError("Server closed Cursor before terminating active step");
    }
    for (let step = nextStep;step < steps.length; ++step) {
      steps[step].callback(undefined, undefined);
    }
  } finally {
    cursor.close();
  }
}
var stepIndex = function(step) {
  if (step._index === undefined) {
    throw new MisuseError("Cannot add a condition referencing a step that has not been added to the batch");
  }
  return step._index;
};
var checkCondBatch = function(expectedBatch, cond) {
  if (cond._batch !== expectedBatch) {
    throw new MisuseError("Cannot mix BatchCond objects for different Batch objects");
  }
};

class Batch {
  _stream;
  #useCursor;
  _steps;
  #executed;
  constructor(stream2, useCursor) {
    this._stream = stream2;
    this.#useCursor = useCursor;
    this._steps = [];
    this.#executed = false;
  }
  step() {
    return new BatchStep(this);
  }
  execute() {
    if (this.#executed) {
      throw new MisuseError("This batch has already been executed");
    }
    this.#executed = true;
    const batch = {
      steps: this._steps.map((step) => step.proto)
    };
    if (this.#useCursor) {
      return executeCursor(this._stream, this._steps, batch);
    } else {
      return executeRegular(this._stream, this._steps, batch);
    }
  }
}

class BatchStep {
  _batch;
  #conds;
  _index;
  constructor(batch) {
    this._batch = batch;
    this.#conds = [];
    this._index = undefined;
  }
  condition(cond) {
    this.#conds.push(cond._proto);
    return this;
  }
  query(stmt2) {
    return this.#add(stmt2, true, rowsResultFromProto);
  }
  queryRow(stmt2) {
    return this.#add(stmt2, true, rowResultFromProto);
  }
  queryValue(stmt2) {
    return this.#add(stmt2, true, valueResultFromProto);
  }
  run(stmt2) {
    return this.#add(stmt2, false, stmtResultFromProto);
  }
  #add(inStmt, wantRows, fromProto) {
    if (this._index !== undefined) {
      throw new MisuseError("This BatchStep has already been added to the batch");
    }
    const stmt2 = stmtToProto(this._batch._stream._sqlOwner(), inStmt, wantRows);
    let condition;
    if (this.#conds.length === 0) {
      condition = undefined;
    } else if (this.#conds.length === 1) {
      condition = this.#conds[0];
    } else {
      condition = { type: "and", conds: this.#conds.slice() };
    }
    const proto2 = { stmt: stmt2, condition };
    return new Promise((outputCallback, errorCallback) => {
      const callback = (stepResult, stepError) => {
        if (stepResult !== undefined && stepError !== undefined) {
          errorCallback(new ProtoError("Server returned both result and error"));
        } else if (stepError !== undefined) {
          errorCallback(errorFromProto(stepError));
        } else if (stepResult !== undefined) {
          outputCallback(fromProto(stepResult, this._batch._stream.intMode));
        } else {
          outputCallback(undefined);
        }
      };
      this._index = this._batch._steps.length;
      this._batch._steps.push({ proto: proto2, callback });
    });
  }
}

class BatchCond {
  _batch;
  _proto;
  constructor(batch, proto2) {
    this._batch = batch;
    this._proto = proto2;
  }
  static ok(step) {
    return new BatchCond(step._batch, { type: "ok", step: stepIndex(step) });
  }
  static error(step) {
    return new BatchCond(step._batch, { type: "error", step: stepIndex(step) });
  }
  static not(cond) {
    return new BatchCond(cond._batch, { type: "not", cond: cond._proto });
  }
  static and(batch, conds) {
    for (const cond of conds) {
      checkCondBatch(batch, cond);
    }
    return new BatchCond(batch, { type: "and", conds: conds.map((e2) => e2._proto) });
  }
  static or(batch, conds) {
    for (const cond of conds) {
      checkCondBatch(batch, cond);
    }
    return new BatchCond(batch, { type: "or", conds: conds.map((e2) => e2._proto) });
  }
  static isAutocommit(batch) {
    batch._stream.client()._ensureVersion(3, "BatchCond.isAutocommit()");
    return new BatchCond(batch, { type: "is_autocommit" });
  }
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/pr
function describeResultFromProto(result2) {
  return {
    paramNames: result2.params.map((p) => p.name),
    columns: result2.cols,
    isExplain: result2.isExplain,
    isReadonly: result2.isReadonly
  };
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/
class Stream {
  constructor(intMode) {
    this.intMode = intMode;
  }
  query(stmt3) {
    return this.#execute(stmt3, true, rowsResultFromProto);
  }
  queryRow(stmt3) {
    return this.#execute(stmt3, true, rowResultFromProto);
  }
  queryValue(stmt3) {
    return this.#execute(stmt3, true, valueResultFromProto);
  }
  run(stmt3) {
    return this.#execute(stmt3, false, stmtResultFromProto);
  }
  #execute(inStmt, wantRows, fromProto) {
    const stmt3 = stmtToProto(this._sqlOwner(), inStmt, wantRows);
    return this._execute(stmt3).then((r2) => fromProto(r2, this.intMode));
  }
  batch(useCursor = false) {
    return new Batch(this, useCursor);
  }
  describe(inSql) {
    const protoSql = sqlToProto(this._sqlOwner(), inSql);
    return this._describe(protoSql).then(describeResultFromProto);
  }
  sequence(inSql) {
    const protoSql = sqlToProto(this._sqlOwner(), inSql);
    return this._sequence(protoSql);
  }
  intMode;
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/
class Cursor {
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/pro
var fetchChunkSize = 1000;
var fetchQueueSize = 10;

class WsCursor extends Cursor {
  #client;
  #stream;
  #cursorId;
  #entryQueue;
  #fetchQueue;
  #closed;
  #done;
  constructor(client, stream2, cursorId) {
    super();
    this.#client = client;
    this.#stream = stream2;
    this.#cursorId = cursorId;
    this.#entryQueue = new Queue;
    this.#fetchQueue = new Queue;
    this.#closed = undefined;
    this.#done = false;
  }
  async next() {
    for (;; ) {
      if (this.#closed !== undefined) {
        throw new ClosedError("Cursor is closed", this.#closed);
      }
      while (!this.#done && this.#fetchQueue.length < fetchQueueSize) {
        this.#fetchQueue.push(this.#fetch());
      }
      const entry = this.#entryQueue.shift();
      if (this.#done || entry !== undefined) {
        return entry;
      }
      await this.#fetchQueue.shift().then((response) => {
        if (response === undefined) {
          return;
        }
        for (const entry2 of response.entries) {
          this.#entryQueue.push(entry2);
        }
        this.#done ||= response.done;
      });
    }
  }
  #fetch() {
    return this.#stream._sendCursorRequest(this, {
      type: "fetch_cursor",
      cursorId: this.#cursorId,
      maxCount: fetchChunkSize
    }).then((resp) => resp, (error6) => {
      this._setClosed(error6);
      return;
    });
  }
  _setClosed(error6) {
    if (this.#closed !== undefined) {
      return;
    }
    this.#closed = error6;
    this.#stream._sendCursorRequest(this, {
      type: "close_cursor",
      cursorId: this.#cursorId
    }).catch(() => {
      return;
    });
    this.#stream._cursorClosed(this);
  }
  close() {
    this._setClosed(new ClientError("Cursor was manually closed"));
  }
  get closed() {
    return this.#closed !== undefined;
  }
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/pro
class WsStream extends Stream {
  #client;
  #streamId;
  #queue;
  #cursor;
  #closing;
  #closed;
  static open(client) {
    const streamId = client._streamIdAlloc.alloc();
    const stream3 = new WsStream(client, streamId);
    const responseCallback = () => {
      return;
    };
    const errorCallback = (e2) => stream3.#setClosed(e2);
    const request28 = { type: "open_stream", streamId };
    client._sendRequest(request28, { responseCallback, errorCallback });
    return stream3;
  }
  constructor(client, streamId) {
    super(client.intMode);
    this.#client = client;
    this.#streamId = streamId;
    this.#queue = new Queue;
    this.#cursor = undefined;
    this.#closing = false;
    this.#closed = undefined;
  }
  client() {
    return this.#client;
  }
  _sqlOwner() {
    return this.#client;
  }
  _execute(stmt3) {
    return this.#sendStreamRequest({
      type: "execute",
      streamId: this.#streamId,
      stmt: stmt3
    }).then((response) => {
      return response.result;
    });
  }
  _batch(batch2) {
    return this.#sendStreamRequest({
      type: "batch",
      streamId: this.#streamId,
      batch: batch2
    }).then((response) => {
      return response.result;
    });
  }
  _describe(protoSql) {
    this.#client._ensureVersion(2, "describe()");
    return this.#sendStreamRequest({
      type: "describe",
      streamId: this.#streamId,
      sql: protoSql.sql,
      sqlId: protoSql.sqlId
    }).then((response) => {
      return response.result;
    });
  }
  _sequence(protoSql) {
    this.#client._ensureVersion(2, "sequence()");
    return this.#sendStreamRequest({
      type: "sequence",
      streamId: this.#streamId,
      sql: protoSql.sql,
      sqlId: protoSql.sqlId
    }).then((_response) => {
      return;
    });
  }
  getAutocommit() {
    this.#client._ensureVersion(3, "getAutocommit()");
    return this.#sendStreamRequest({
      type: "get_autocommit",
      streamId: this.#streamId
    }).then((response) => {
      return response.isAutocommit;
    });
  }
  #sendStreamRequest(request28) {
    return new Promise((responseCallback, errorCallback) => {
      this.#pushToQueue({ type: "request", request: request28, responseCallback, errorCallback });
    });
  }
  _openCursor(batch2) {
    this.#client._ensureVersion(3, "cursor");
    return new Promise((cursorCallback, errorCallback) => {
      this.#pushToQueue({ type: "cursor", batch: batch2, cursorCallback, errorCallback });
    });
  }
  _sendCursorRequest(cursor3, request28) {
    if (cursor3 !== this.#cursor) {
      throw new InternalError("Cursor not associated with the stream attempted to execute a request");
    }
    return new Promise((responseCallback, errorCallback) => {
      if (this.#closed !== undefined) {
        errorCallback(new ClosedError("Stream is closed", this.#closed));
      } else {
        this.#client._sendRequest(request28, { responseCallback, errorCallback });
      }
    });
  }
  _cursorClosed(cursor3) {
    if (cursor3 !== this.#cursor) {
      throw new InternalError("Cursor was closed, but it was not associated with the stream");
    }
    this.#cursor = undefined;
    this.#flushQueue();
  }
  #pushToQueue(entry) {
    if (this.#closed !== undefined) {
      entry.errorCallback(new ClosedError("Stream is closed", this.#closed));
    } else if (this.#closing) {
      entry.errorCallback(new ClosedError("Stream is closing", undefined));
    } else {
      this.#queue.push(entry);
      this.#flushQueue();
    }
  }
  #flushQueue() {
    for (;; ) {
      const entry = this.#queue.first();
      if (entry === undefined && this.#cursor === undefined && this.#closing) {
        this.#setClosed(new ClientError("Stream was gracefully closed"));
        break;
      } else if (entry?.type === "request" && this.#cursor === undefined) {
        const { request: request28, responseCallback, errorCallback } = entry;
        this.#queue.shift();
        this.#client._sendRequest(request28, { responseCallback, errorCallback });
      } else if (entry?.type === "cursor" && this.#cursor === undefined) {
        const { batch: batch2, cursorCallback } = entry;
        this.#queue.shift();
        const cursorId = this.#client._cursorIdAlloc.alloc();
        const cursor3 = new WsCursor(this.#client, this, cursorId);
        const request28 = {
          type: "open_cursor",
          streamId: this.#streamId,
          cursorId,
          batch: batch2
        };
        const responseCallback = () => {
          return;
        };
        const errorCallback = (e2) => cursor3._setClosed(e2);
        this.#client._sendRequest(request28, { responseCallback, errorCallback });
        this.#cursor = cursor3;
        cursorCallback(cursor3);
      } else {
        break;
      }
    }
  }
  #setClosed(error6) {
    if (this.#closed !== undefined) {
      return;
    }
    this.#closed = error6;
    if (this.#cursor !== undefined) {
      this.#cursor._setClosed(error6);
    }
    for (;; ) {
      const entry = this.#queue.shift();
      if (entry !== undefined) {
        entry.errorCallback(error6);
      } else {
        break;
      }
    }
    const request28 = { type: "close_stream", streamId: this.#streamId };
    const responseCallback = () => this.#client._streamIdAlloc.free(this.#streamId);
    const errorCallback = () => {
      return;
    };
    this.#client._sendRequest(request28, { responseCallback, errorCallback });
  }
  close() {
    this.#setClosed(new ClientError("Stream was manually closed"));
  }
  closeGracefully() {
    this.#closing = true;
    this.#flushQueue();
  }
  get closed() {
    return this.#closed !== undefined || this.#closing;
  }
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/uti
function Stmt2(w, msg) {
  if (msg.sql !== undefined) {
    w.string("sql", msg.sql);
  }
  if (msg.sqlId !== undefined) {
    w.number("sql_id", msg.sqlId);
  }
  w.arrayObjects("args", msg.args, Value);
  w.arrayObjects("named_args", msg.namedArgs, NamedArg);
  w.boolean("want_rows", msg.wantRows);
}
var NamedArg = function(w, msg) {
  w.string("name", msg.name);
  w.object("value", msg.value, Value);
};
function Batch2(w, msg) {
  w.arrayObjects("steps", msg.steps, BatchStep2);
}
var BatchStep2 = function(w, msg) {
  if (msg.condition !== undefined) {
    w.object("condition", msg.condition, BatchCond2);
  }
  w.object("stmt", msg.stmt, Stmt2);
};
var BatchCond2 = function(w, msg) {
  w.stringRaw("type", msg.type);
  if (msg.type === "ok" || msg.type === "error") {
    w.number("step", msg.step);
  } else if (msg.type === "not") {
    w.object("cond", msg.cond, BatchCond2);
  } else if (msg.type === "and" || msg.type === "or") {
    w.arrayObjects("conds", msg.conds, BatchCond2);
  } else if (msg.type === "is_autocommit") {
  } else {
    throw impossible(msg, "Impossible type of BatchCond");
  }
};
var Value = function(w, msg) {
  if (msg === null) {
    w.stringRaw("type", "null");
  } else if (typeof msg === "bigint") {
    w.stringRaw("type", "integer");
    w.stringRaw("value", "" + msg);
  } else if (typeof msg === "number") {
    w.stringRaw("type", "float");
    w.number("value", msg);
  } else if (typeof msg === "string") {
    w.stringRaw("type", "text");
    w.string("value", msg);
  } else if (msg instanceof Uint8Array) {
    w.stringRaw("type", "blob");
    w.stringRaw("base64", gBase64.fromUint8Array(msg));
  } else if (msg === undefined) {
  } else {
    throw impossible(msg, "Impossible type of Value");
  }
};

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf
function ClientMsg(w, msg) {
  w.stringRaw("type", msg.type);
  if (msg.type === "hello") {
    if (msg.jwt !== undefined) {
      w.string("jwt", msg.jwt);
    }
  } else if (msg.type === "request") {
    w.number("request_id", msg.requestId);
    w.object("request", msg.request, Request2);
  } else {
    throw impossible(msg, "Impossible type of ClientMsg");
  }
}
var Request2 = function(w, msg) {
  w.stringRaw("type", msg.type);
  if (msg.type === "open_stream") {
    w.number("stream_id", msg.streamId);
  } else if (msg.type === "close_stream") {
    w.number("stream_id", msg.streamId);
  } else if (msg.type === "execute") {
    w.number("stream_id", msg.streamId);
    w.object("stmt", msg.stmt, Stmt2);
  } else if (msg.type === "batch") {
    w.number("stream_id", msg.streamId);
    w.object("batch", msg.batch, Batch2);
  } else if (msg.type === "open_cursor") {
    w.number("stream_id", msg.streamId);
    w.number("cursor_id", msg.cursorId);
    w.object("batch", msg.batch, Batch2);
  } else if (msg.type === "close_cursor") {
    w.number("cursor_id", msg.cursorId);
  } else if (msg.type === "fetch_cursor") {
    w.number("cursor_id", msg.cursorId);
    w.number("max_count", msg.maxCount);
  } else if (msg.type === "sequence") {
    w.number("stream_id", msg.streamId);
    if (msg.sql !== undefined) {
      w.string("sql", msg.sql);
    }
    if (msg.sqlId !== undefined) {
      w.number("sql_id", msg.sqlId);
    }
  } else if (msg.type === "describe") {
    w.number("stream_id", msg.streamId);
    if (msg.sql !== undefined) {
      w.string("sql", msg.sql);
    }
    if (msg.sqlId !== undefined) {
      w.number("sql_id", msg.sqlId);
    }
  } else if (msg.type === "store_sql") {
    w.number("sql_id", msg.sqlId);
    w.string("sql", msg.sql);
  } else if (msg.type === "close_sql") {
    w.number("sql_id", msg.sqlId);
  } else if (msg.type === "get_autocommit") {
    w.number("stream_id", msg.streamId);
  } else {
    throw impossible(msg, "Impossible type of Request");
  }
};

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/util.js
function Stmt3(w, msg) {
  if (msg.sql !== undefined) {
    w.string(1, msg.sql);
  }
  if (msg.sqlId !== undefined) {
    w.int32(2, msg.sqlId);
  }
  for (const arg of msg.args) {
    w.message(3, arg, Value2);
  }
  for (const arg of msg.namedArgs) {
    w.message(4, arg, NamedArg2);
  }
  w.bool(5, msg.wantRows);
}
var NamedArg2 = function(w, msg) {
  w.string(1, msg.name);
  w.message(2, msg.value, Value2);
};
function Batch3(w, msg) {
  for (const step of msg.steps) {
    w.message(1, step, BatchStep3);
  }
}
var BatchStep3 = function(w, msg) {
  if (msg.condition !== undefined) {
    w.message(1, msg.condition, BatchCond3);
  }
  w.message(2, msg.stmt, Stmt3);
};
var BatchCond3 = function(w, msg) {
  if (msg.type === "ok") {
    w.uint32(1, msg.step);
  } else if (msg.type === "error") {
    w.uint32(2, msg.step);
  } else if (msg.type === "not") {
    w.message(3, msg.cond, BatchCond3);
  } else if (msg.type === "and") {
    w.message(4, msg.conds, BatchCondList);
  } else if (msg.type === "or") {
    w.message(5, msg.conds, BatchCondList);
  } else if (msg.type === "is_autocommit") {
    w.message(6, undefined, Empty);
  } else {
    throw impossible(msg, "Impossible type of BatchCond");
  }
};
var BatchCondList = function(w, msg) {
  for (const cond of msg) {
    w.message(1, cond, BatchCond3);
  }
};
var Value2 = function(w, msg) {
  if (msg === null) {
    w.message(1, undefined, Empty);
  } else if (typeof msg === "bigint") {
    w.sint64(2, msg);
  } else if (typeof msg === "number") {
    w.double(3, msg);
  } else if (typeof msg === "string") {
    w.string(4, msg);
  } else if (msg instanceof Uint8Array) {
    w.bytes(5, msg);
  } else if (msg === undefined) {
  } else {
    throw impossible(msg, "Impossible type of Value");
  }
};
var Empty = function(_w, _msg) {
};

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/uti
function ClientMsg2(w, msg) {
  if (msg.type === "hello") {
    w.message(1, msg, HelloMsg);
  } else if (msg.type === "request") {
    w.message(2, msg, RequestMsg);
  } else {
    throw impossible(msg, "Impossible type of ClientMsg");
  }
}
var HelloMsg = function(w, msg) {
  if (msg.jwt !== undefined) {
    w.string(1, msg.jwt);
  }
};
var RequestMsg = function(w, msg) {
  w.int32(1, msg.requestId);
  const request28 = msg.request;
  if (request28.type === "open_stream") {
    w.message(2, request28, OpenStreamReq);
  } else if (request28.type === "close_stream") {
    w.message(3, request28, CloseStreamReq);
  } else if (request28.type === "execute") {
    w.message(4, request28, ExecuteReq);
  } else if (request28.type === "batch") {
    w.message(5, request28, BatchReq);
  } else if (request28.type === "open_cursor") {
    w.message(6, request28, OpenCursorReq);
  } else if (request28.type === "close_cursor") {
    w.message(7, request28, CloseCursorReq);
  } else if (request28.type === "fetch_cursor") {
    w.message(8, request28, FetchCursorReq);
  } else if (request28.type === "sequence") {
    w.message(9, request28, SequenceReq);
  } else if (request28.type === "describe") {
    w.message(10, request28, DescribeReq);
  } else if (request28.type === "store_sql") {
    w.message(11, request28, StoreSqlReq);
  } else if (request28.type === "close_sql") {
    w.message(12, request28, CloseSqlReq);
  } else if (request28.type === "get_autocommit") {
    w.message(13, request28, GetAutocommitReq);
  } else {
    throw impossible(request28, "Impossible type of Request");
  }
};
var OpenStreamReq = function(w, msg) {
  w.int32(1, msg.streamId);
};
var CloseStreamReq = function(w, msg) {
  w.int32(1, msg.streamId);
};
var ExecuteReq = function(w, msg) {
  w.int32(1, msg.streamId);
  w.message(2, msg.stmt, Stmt3);
};
var BatchReq = function(w, msg) {
  w.int32(1, msg.streamId);
  w.message(2, msg.batch, Batch3);
};
var OpenCursorReq = function(w, msg) {
  w.int32(1, msg.streamId);
  w.int32(2, msg.cursorId);
  w.message(3, msg.batch, Batch3);
};
var CloseCursorReq = function(w, msg) {
  w.int32(1, msg.cursorId);
};
var FetchCursorReq = function(w, msg) {
  w.int32(1, msg.cursorId);
  w.uint32(2, msg.maxCount);
};
var SequenceReq = function(w, msg) {
  w.int32(1, msg.streamId);
  if (msg.sql !== undefined) {
    w.string(2, msg.sql);
  }
  if (msg.sqlId !== undefined) {
    w.int32(3, msg.sqlId);
  }
};
var DescribeReq = function(w, msg) {
  w.int32(1, msg.streamId);
  if (msg.sql !== undefined) {
    w.string(2, msg.sql);
  }
  if (msg.sqlId !== undefined) {
    w.int32(3, msg.sqlId);
  }
};
var StoreSqlReq = function(w, msg) {
  w.int32(1, msg.sqlId);
  w.string(2, msg.sql);
};
var CloseSqlReq = function(w, msg) {
  w.int32(1, msg.sqlId);
};
var GetAutocommitReq = function(w, msg) {
  w.int32(1, msg.streamId);
};

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/uti
function Error2(obj) {
  const message = string(obj["message"]);
  const code = stringOpt(obj["code"]);
  return { message, code };
}
function StmtResult(obj) {
  const cols = arrayObjectsMap(obj["cols"], Col);
  const rows = array(obj["rows"]).map((rowObj) => arrayObjectsMap(rowObj, Value3));
  const affectedRowCount = number(obj["affected_row_count"]);
  const lastInsertRowidStr = stringOpt(obj["last_insert_rowid"]);
  const lastInsertRowid = lastInsertRowidStr !== undefined ? BigInt(lastInsertRowidStr) : undefined;
  return { cols, rows, affectedRowCount, lastInsertRowid };
}
var Col = function(obj) {
  const name = stringOpt(obj["name"]);
  const decltype = stringOpt(obj["decltype"]);
  return { name, decltype };
};
function BatchResult(obj) {
  const stepResults = new Map;
  array(obj["step_results"]).forEach((value4, i) => {
    if (value4 !== null) {
      stepResults.set(i, StmtResult(object(value4)));
    }
  });
  const stepErrors = new Map;
  array(obj["step_errors"]).forEach((value4, i) => {
    if (value4 !== null) {
      stepErrors.set(i, Error2(object(value4)));
    }
  });
  return { stepResults, stepErrors };
}
function CursorEntry(obj) {
  const type = string(obj["type"]);
  if (type === "step_begin") {
    const step = number(obj["step"]);
    const cols = arrayObjectsMap(obj["cols"], Col);
    return { type: "step_begin", step, cols };
  } else if (type === "step_end") {
    const affectedRowCount = number(obj["affected_row_count"]);
    const lastInsertRowidStr = stringOpt(obj["last_insert_rowid"]);
    const lastInsertRowid = lastInsertRowidStr !== undefined ? BigInt(lastInsertRowidStr) : undefined;
    return { type: "step_end", affectedRowCount, lastInsertRowid };
  } else if (type === "step_error") {
    const step = number(obj["step"]);
    const error6 = Error2(object(obj["error"]));
    return { type: "step_error", step, error: error6 };
  } else if (type === "row") {
    const row = arrayObjectsMap(obj["row"], Value3);
    return { type: "row", row };
  } else if (type === "error") {
    const error6 = Error2(object(obj["error"]));
    return { type: "error", error: error6 };
  } else {
    throw new ProtoError("Unexpected type of CursorEntry");
  }
}
function DescribeResult(obj) {
  const params = arrayObjectsMap(obj["params"], DescribeParam);
  const cols = arrayObjectsMap(obj["cols"], DescribeCol);
  const isExplain = boolean(obj["is_explain"]);
  const isReadonly = boolean(obj["is_readonly"]);
  return { params, cols, isExplain, isReadonly };
}
var DescribeParam = function(obj) {
  const name = stringOpt(obj["name"]);
  return { name };
};
var DescribeCol = function(obj) {
  const name = string(obj["name"]);
  const decltype = stringOpt(obj["decltype"]);
  return { name, decltype };
};
function Value3(obj) {
  const type = string(obj["type"]);
  if (type === "null") {
    return null;
  } else if (type === "integer") {
    const value4 = string(obj["value"]);
    return BigInt(value4);
  } else if (type === "float") {
    return number(obj["value"]);
  } else if (type === "text") {
    return string(obj["value"]);
  } else if (type === "blob") {
    return gBase64.toUint8Array(string(obj["base64"]));
  } else {
    throw new ProtoError("Unexpected type of Value");
  }
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf
function ServerMsg(obj) {
  const type = string(obj["type"]);
  if (type === "hello_ok") {
    return { type: "hello_ok" };
  } else if (type === "hello_error") {
    const error6 = Error2(object(obj["error"]));
    return { type: "hello_error", error: error6 };
  } else if (type === "response_ok") {
    const requestId = number(obj["request_id"]);
    const response = Response2(object(obj["response"]));
    return { type: "response_ok", requestId, response };
  } else if (type === "response_error") {
    const requestId = number(obj["request_id"]);
    const error6 = Error2(object(obj["error"]));
    return { type: "response_error", requestId, error: error6 };
  } else {
    throw new ProtoError("Unexpected type of ServerMsg");
  }
}
var Response2 = function(obj) {
  const type = string(obj["type"]);
  if (type === "open_stream") {
    return { type: "open_stream" };
  } else if (type === "close_stream") {
    return { type: "close_stream" };
  } else if (type === "execute") {
    const result3 = StmtResult(object(obj["result"]));
    return { type: "execute", result: result3 };
  } else if (type === "batch") {
    const result3 = BatchResult(object(obj["result"]));
    return { type: "batch", result: result3 };
  } else if (type === "open_cursor") {
    return { type: "open_cursor" };
  } else if (type === "close_cursor") {
    return { type: "close_cursor" };
  } else if (type === "fetch_cursor") {
    const entries = arrayObjectsMap(obj["entries"], CursorEntry);
    const done = boolean(obj["done"]);
    return { type: "fetch_cursor", entries, done };
  } else if (type === "sequence") {
    return { type: "sequence" };
  } else if (type === "describe") {
    const result3 = DescribeResult(object(obj["result"]));
    return { type: "describe", result: result3 };
  } else if (type === "store_sql") {
    return { type: "store_sql" };
  } else if (type === "close_sql") {
    return { type: "close_sql" };
  } else if (type === "get_autocommit") {
    const isAutocommit = boolean(obj["is_autocommit"]);
    return { type: "get_autocommit", isAutocommit };
  } else {
    throw new ProtoError("Unexpected type of Response");
  }
};

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/util.js
var Error3 = {
  default() {
    return { message: "", code: undefined };
  },
  1(r2, msg) {
    msg.message = r2.string();
  },
  2(r2, msg) {
    msg.code = r2.string();
  }
};
var StmtResult2 = {
  default() {
    return {
      cols: [],
      rows: [],
      affectedRowCount: 0,
      lastInsertRowid: undefined
    };
  },
  1(r2, msg) {
    msg.cols.push(r2.message(Col2));
  },
  2(r2, msg) {
    msg.rows.push(r2.message(Row));
  },
  3(r2, msg) {
    msg.affectedRowCount = Number(r2.uint64());
  },
  4(r2, msg) {
    msg.lastInsertRowid = r2.sint64();
  }
};
var Col2 = {
  default() {
    return { name: undefined, decltype: undefined };
  },
  1(r2, msg) {
    msg.name = r2.string();
  },
  2(r2, msg) {
    msg.decltype = r2.string();
  }
};
var Row = {
  default() {
    return [];
  },
  1(r2, msg) {
    msg.push(r2.message(Value4));
  }
};
var BatchResult2 = {
  default() {
    return { stepResults: new Map, stepErrors: new Map };
  },
  1(r2, msg) {
    const [key, value4] = r2.message(BatchResultStepResult);
    msg.stepResults.set(key, value4);
  },
  2(r2, msg) {
    const [key, value4] = r2.message(BatchResultStepError);
    msg.stepErrors.set(key, value4);
  }
};
var BatchResultStepResult = {
  default() {
    return [0, StmtResult2.default()];
  },
  1(r2, msg) {
    msg[0] = r2.uint32();
  },
  2(r2, msg) {
    msg[1] = r2.message(StmtResult2);
  }
};
var BatchResultStepError = {
  default() {
    return [0, Error3.default()];
  },
  1(r2, msg) {
    msg[0] = r2.uint32();
  },
  2(r2, msg) {
    msg[1] = r2.message(Error3);
  }
};
var CursorEntry2 = {
  default() {
    return { type: "none" };
  },
  1(r2) {
    return r2.message(StepBeginEntry);
  },
  2(r2) {
    return r2.message(StepEndEntry);
  },
  3(r2) {
    return r2.message(StepErrorEntry);
  },
  4(r2) {
    return { type: "row", row: r2.message(Row) };
  },
  5(r2) {
    return { type: "error", error: r2.message(Error3) };
  }
};
var StepBeginEntry = {
  default() {
    return { type: "step_begin", step: 0, cols: [] };
  },
  1(r2, msg) {
    msg.step = r2.uint32();
  },
  2(r2, msg) {
    msg.cols.push(r2.message(Col2));
  }
};
var StepEndEntry = {
  default() {
    return {
      type: "step_end",
      affectedRowCount: 0,
      lastInsertRowid: undefined
    };
  },
  1(r2, msg) {
    msg.affectedRowCount = r2.uint32();
  },
  2(r2, msg) {
    msg.lastInsertRowid = r2.uint64();
  }
};
var StepErrorEntry = {
  default() {
    return {
      type: "step_error",
      step: 0,
      error: Error3.default()
    };
  },
  1(r2, msg) {
    msg.step = r2.uint32();
  },
  2(r2, msg) {
    msg.error = r2.message(Error3);
  }
};
var DescribeResult2 = {
  default() {
    return {
      params: [],
      cols: [],
      isExplain: false,
      isReadonly: false
    };
  },
  1(r2, msg) {
    msg.params.push(r2.message(DescribeParam2));
  },
  2(r2, msg) {
    msg.cols.push(r2.message(DescribeCol2));
  },
  3(r2, msg) {
    msg.isExplain = r2.bool();
  },
  4(r2, msg) {
    msg.isReadonly = r2.bool();
  }
};
var DescribeParam2 = {
  default() {
    return { name: undefined };
  },
  1(r2, msg) {
    msg.name = r2.string();
  }
};
var DescribeCol2 = {
  default() {
    return { name: "", decltype: undefined };
  },
  1(r2, msg) {
    msg.name = r2.string();
  },
  2(r2, msg) {
    msg.decltype = r2.string();
  }
};
var Value4 = {
  default() {
    return;
  },
  1(r2) {
    return null;
  },
  2(r2) {
    return r2.sint64();
  },
  3(r2) {
    return r2.double();
  },
  4(r2) {
    return r2.string();
  },
  5(r2) {
    return r2.bytes();
  }
};

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/uti
var ServerMsg2 = {
  default() {
    return { type: "none" };
  },
  1(r2) {
    return { type: "hello_ok" };
  },
  2(r2) {
    return r2.message(HelloErrorMsg);
  },
  3(r2) {
    return r2.message(ResponseOkMsg);
  },
  4(r2) {
    return r2.message(ResponseErrorMsg);
  }
};
var HelloErrorMsg = {
  default() {
    return { type: "hello_error", error: Error3.default() };
  },
  1(r2, msg) {
    msg.error = r2.message(Error3);
  }
};
var ResponseErrorMsg = {
  default() {
    return { type: "response_error", requestId: 0, error: Error3.default() };
  },
  1(r2, msg) {
    msg.requestId = r2.int32();
  },
  2(r2, msg) {
    msg.error = r2.message(Error3);
  }
};
var ResponseOkMsg = {
  default() {
    return {
      type: "response_ok",
      requestId: 0,
      response: { type: "none" }
    };
  },
  1(r2, msg) {
    msg.requestId = r2.int32();
  },
  2(r2, msg) {
    msg.response = { type: "open_stream" };
  },
  3(r2, msg) {
    msg.response = { type: "close_stream" };
  },
  4(r2, msg) {
    msg.response = r2.message(ExecuteResp);
  },
  5(r2, msg) {
    msg.response = r2.message(BatchResp);
  },
  6(r2, msg) {
    msg.response = { type: "open_cursor" };
  },
  7(r2, msg) {
    msg.response = { type: "close_cursor" };
  },
  8(r2, msg) {
    msg.response = r2.message(FetchCursorResp);
  },
  9(r2, msg) {
    msg.response = { type: "sequence" };
  },
  10(r2, msg) {
    msg.response = r2.message(DescribeResp);
  },
  11(r2, msg) {
    msg.response = { type: "store_sql" };
  },
  12(r2, msg) {
    msg.response = { type: "close_sql" };
  },
  13(r2, msg) {
    msg.response = r2.message(GetAutocommitResp);
  }
};
var ExecuteResp = {
  default() {
    return { type: "execute", result: StmtResult2.default() };
  },
  1(r2, msg) {
    msg.result = r2.message(StmtResult2);
  }
};
var BatchResp = {
  default() {
    return { type: "batch", result: BatchResult2.default() };
  },
  1(r2, msg) {
    msg.result = r2.message(BatchResult2);
  }
};
var FetchCursorResp = {
  default() {
    return { type: "fetch_cursor", entries: [], done: false };
  },
  1(r2, msg) {
    msg.entries.push(r2.message(CursorEntry2));
  },
  2(r2, msg) {
    msg.done = r2.bool();
  }
};
var DescribeResp = {
  default() {
    return { type: "describe", result: DescribeResult2.default() };
  },
  1(r2, msg) {
    msg.result = r2.message(DescribeResult2);
  }
};
var GetAutocommitResp = {
  default() {
    return { type: "get_autocommit", isAutocommit: false };
  },
  1(r2, msg) {
    msg.isAutocommit = r2.bool();
  }
};

// node_modules/@libsql/hrana-client/lib-esm/encoding/pro
var subprotocolsV2 = new Map([
  ["hrana2", { version: 2, encoding: "json" }],
  ["hrana1", { version: 1, encoding: "json" }]
]);
var subprotocolsV3 = new Map([
  ["hrana3-protobuf", { version: 3, encoding: "protobuf" }],
  ["hrana3", { version: 3, encoding: "json" }],
  ["hrana2", { version: 2, encoding: "json" }],
  ["hrana1", { version: 1, encoding: "json" }]
]);

class WsClient extends Client {
  #socket;
  #openCallbacks;
  #opened;
  #closed;
  #recvdHello;
  #subprotocol;
  #getVersionCalled;
  #responseMap;
  #requestIdAlloc;
  _streamIdAlloc;
  _cursorIdAlloc;
  #sqlIdAlloc;
  constructor(socket, jwt2) {
    super();
    this.#socket = socket;
    this.#openCallbacks = [];
    this.#opened = false;
    this.#closed = undefined;
    this.#recvdHello = false;
    this.#subprotocol = undefined;
    this.#getVersionCalled = false;
    this.#responseMap = new Map;
    this.#requestIdAlloc = new IdAlloc;
    this._streamIdAlloc = new IdAlloc;
    this._cursorIdAlloc = new IdAlloc;
    this.#sqlIdAlloc = new IdAlloc;
    this.#socket.binaryType = "arraybuffer";
    this.#socket.addEventListener("open", () => this.#onSocketOpen());
    this.#socket.addEventListener("close", (event) => this.#onSocketClose(event));
    this.#socket.addEventListener("error", (event) => this.#onSocketError(event));
    this.#socket.addEventListener("message", (event) => this.#onSocketMessage(event));
    this.#send({ type: "hello", jwt: jwt2 });
  }
  #send(msg) {
    if (this.#closed !== undefined) {
      throw new InternalError("Trying to send a message on a closed client");
    }
    if (this.#opened) {
      this.#sendToSocket(msg);
    } else {
      const openCallback = () => this.#sendToSocket(msg);
      const errorCallback = () => {
        return;
      };
      this.#openCallbacks.push({ openCallback, errorCallback });
    }
  }
  #onSocketOpen() {
    const protocol = this.#socket.protocol;
    if (protocol === undefined) {
      this.#setClosed(new ClientError("The `WebSocket.protocol` property is undefined. This most likely means that the WebSocket implementation provided by the environment is broken. If you are using Miniflare 2, please update to Miniflare 3, which fixes this problem."));
      return;
    } else if (protocol === "") {
      this.#subprotocol = { version: 1, encoding: "json" };
    } else {
      this.#subprotocol = subprotocolsV3.get(protocol);
      if (this.#subprotocol === undefined) {
        this.#setClosed(new ProtoError(`Unrecognized WebSocket subprotocol: ${JSON.stringify(protocol)}`));
        return;
      }
    }
    for (const callbacks of this.#openCallbacks) {
      callbacks.openCallback();
    }
    this.#openCallbacks.length = 0;
    this.#opened = true;
  }
  #sendToSocket(msg) {
    const encoding2 = this.#subprotocol.encoding;
    if (encoding2 === "json") {
      const jsonMsg = writeJsonObject(msg, ClientMsg);
      this.#socket.send(jsonMsg);
    } else if (encoding2 === "protobuf") {
      const protobufMsg = writeProtobufMessage(msg, ClientMsg2);
      this.#socket.send(protobufMsg);
    } else {
      throw impossible(encoding2, "Impossible encoding");
    }
  }
  getVersion() {
    return new Promise((versionCallback, errorCallback) => {
      this.#getVersionCalled = true;
      if (this.#closed !== undefined) {
        errorCallback(this.#closed);
      } else if (!this.#opened) {
        const openCallback = () => versionCallback(this.#subprotocol.version);
        this.#openCallbacks.push({ openCallback, errorCallback });
      } else {
        versionCallback(this.#subprotocol.version);
      }
    });
  }
  _ensureVersion(minVersion, feature) {
    if (this.#subprotocol === undefined || !this.#getVersionCalled) {
      throw new ProtocolVersionError(`${feature} is supported only on protocol version ${minVersion} and higher, ` + "but the version supported by the WebSocket server is not yet known. Use Client.getVersion() to wait until the version is available.");
    } else if (this.#subprotocol.version < minVersion) {
      throw new ProtocolVersionError(`${feature} is supported on protocol version ${minVersion} and higher, ` + `but the WebSocket server only supports version ${this.#subprotocol.version}`);
    }
  }
  _sendRequest(request28, callbacks) {
    if (this.#closed !== undefined) {
      callbacks.errorCallback(new ClosedError("Client is closed", this.#closed));
      return;
    }
    const requestId = this.#requestIdAlloc.alloc();
    this.#responseMap.set(requestId, { ...callbacks, type: request28.type });
    this.#send({ type: "request", requestId, request: request28 });
  }
  #onSocketError(event) {
    const eventMessage = event.message;
    const message = eventMessage ?? "WebSocket was closed due to an error";
    this.#setClosed(new WebSocketError(message));
  }
  #onSocketClose(event) {
    let message = `WebSocket was closed with code ${event.code}`;
    if (event.reason) {
      message += `: ${event.reason}`;
    }
    this.#setClosed(new WebSocketError(message));
  }
  #setClosed(error6) {
    if (this.#closed !== undefined) {
      return;
    }
    this.#closed = error6;
    for (const callbacks of this.#openCallbacks) {
      callbacks.errorCallback(error6);
    }
    this.#openCallbacks.length = 0;
    for (const [requestId, responseState] of this.#responseMap.entries()) {
      responseState.errorCallback(error6);
      this.#requestIdAlloc.free(requestId);
    }
    this.#responseMap.clear();
    this.#socket.close();
  }
  #onSocketMessage(event) {
    if (this.#closed !== undefined) {
      return;
    }
    try {
      let msg;
      const encoding2 = this.#subprotocol.encoding;
      if (encoding2 === "json") {
        if (typeof event.data !== "string") {
          this.#socket.close(3003, "Only text messages are accepted with JSON encoding");
          this.#setClosed(new ProtoError("Received non-text message from server with JSON encoding"));
          return;
        }
        msg = readJsonObject(JSON.parse(event.data), ServerMsg);
      } else if (encoding2 === "protobuf") {
        if (!(event.data instanceof ArrayBuffer)) {
          this.#socket.close(3003, "Only binary messages are accepted with Protobuf encoding");
          this.#setClosed(new ProtoError("Received non-binary message from server with Protobuf encoding"));
          return;
        }
        msg = readProtobufMessage(new Uint8Array(event.data), ServerMsg2);
      } else {
        throw impossible(encoding2, "Impossible encoding");
      }
      this.#handleMsg(msg);
    } catch (e2) {
      this.#socket.close(3007, "Could not handle message");
      this.#setClosed(e2);
    }
  }
  #handleMsg(msg) {
    if (msg.type === "none") {
      throw new ProtoError("Received an unrecognized ServerMsg");
    } else if (msg.type === "hello_ok" || msg.type === "hello_error") {
      if (this.#recvdHello) {
        throw new ProtoError("Received a duplicated hello response");
      }
      this.#recvdHello = true;
      if (msg.type === "hello_error") {
        throw errorFromProto(msg.error);
      }
      return;
    } else if (!this.#recvdHello) {
      throw new ProtoError("Received a non-hello message before a hello response");
    }
    if (msg.type === "response_ok") {
      const requestId = msg.requestId;
      const responseState = this.#responseMap.get(requestId);
      this.#responseMap.delete(requestId);
      if (responseState === undefined) {
        throw new ProtoError("Received unexpected OK response");
      }
      this.#requestIdAlloc.free(requestId);
      try {
        if (responseState.type !== msg.response.type) {
          console.dir({ responseState, msg });
          throw new ProtoError("Received unexpected type of response");
        }
        responseState.responseCallback(msg.response);
      } catch (e2) {
        responseState.errorCallback(e2);
        throw e2;
      }
    } else if (msg.type === "response_error") {
      const requestId = msg.requestId;
      const responseState = this.#responseMap.get(requestId);
      this.#responseMap.delete(requestId);
      if (responseState === undefined) {
        throw new ProtoError("Received unexpected error response");
      }
      this.#requestIdAlloc.free(requestId);
      responseState.errorCallback(errorFromProto(msg.error));
    } else {
      throw impossible(msg, "Impossible ServerMsg type");
    }
  }
  openStream() {
    return WsStream.open(this);
  }
  storeSql(sql4) {
    this._ensureVersion(2, "storeSql()");
    const sqlId = this.#sqlIdAlloc.alloc();
    const sqlObj = new Sql(this, sqlId);
    const responseCallback = () => {
      return;
    };
    const errorCallback = (e2) => sqlObj._setClosed(e2);
    const request28 = { type: "store_sql", sqlId, sql: sql4 };
    this._sendRequest(request28, { responseCallback, errorCallback });
    return sqlObj;
  }
  _closeSql(sqlId) {
    if (this.#closed !== undefined) {
      return;
    }
    const responseCallback = () => this.#sqlIdAlloc.free(sqlId);
    const errorCallback = (e2) => this.#setClosed(e2);
    const request28 = { type: "close_sql", sqlId };
    this._sendRequest(request28, { responseCallback, errorCallback });
  }
  close() {
    this.#setClosed(new ClientError("Client was manually closed"));
  }
  get closed() {
    return this.#closed !== undefined;
  }
}

// node_modules/@libsql/hrana-client/lib-esm/en
var _fetch = fetch;
var _Request = Request;
var _Headers = Headers;

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/
var _queueMicrotask;
if (typeof queueMicrotask !== "undefined") {
  _queueMicrotask = queueMicrotask;
} else {
  const resolved = Promise.resolve();
  _queueMicrotask = (callback) => {
    resolved.then(callback);
  };
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/prot
class ByteQueue {
  #array;
  #shiftPos;
  #pushPos;
  constructor(initialCap) {
    this.#array = new Uint8Array(new ArrayBuffer(initialCap));
    this.#shiftPos = 0;
    this.#pushPos = 0;
  }
  get length() {
    return this.#pushPos - this.#shiftPos;
  }
  data() {
    return this.#array.slice(this.#shiftPos, this.#pushPos);
  }
  push(chunk) {
    this.#ensurePush(chunk.byteLength);
    this.#array.set(chunk, this.#pushPos);
    this.#pushPos += chunk.byteLength;
  }
  #ensurePush(pushLength) {
    if (this.#pushPos + pushLength <= this.#array.byteLength) {
      return;
    }
    const filledLength = this.#pushPos - this.#shiftPos;
    if (filledLength + pushLength <= this.#array.byteLength && 2 * this.#pushPos >= this.#array.byteLength) {
      this.#array.copyWithin(0, this.#shiftPos, this.#pushPos);
    } else {
      let newCap = this.#array.byteLength;
      do {
        newCap *= 2;
      } while (filledLength + pushLength > newCap);
      const newArray = new Uint8Array(new ArrayBuffer(newCap));
      newArray.set(this.#array.slice(this.#shiftPos, this.#pushPos), 0);
      this.#array = newArray;
    }
    this.#pushPos = filledLength;
    this.#shiftPos = 0;
  }
  shift(length) {
    this.#shiftPos += length;
  }
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/u
function PipelineRespBody(obj) {
  const baton = stringOpt(obj["baton"]);
  const baseUrl = stringOpt(obj["base_url"]);
  const results = arrayObjectsMap(obj["results"], StreamResult);
  return { baton, baseUrl, results };
}
var StreamResult = function(obj) {
  const type = string(obj["type"]);
  if (type === "ok") {
    const response = StreamResponse(object(obj["response"]));
    return { type: "ok", response };
  } else if (type === "error") {
    const error6 = Error2(object(obj["error"]));
    return { type: "error", error: error6 };
  } else {
    throw new ProtoError("Unexpected type of StreamResult");
  }
};
var StreamResponse = function(obj) {
  const type = string(obj["type"]);
  if (type === "close") {
    return { type: "close" };
  } else if (type === "execute") {
    const result4 = StmtResult(object(obj["result"]));
    return { type: "execute", result: result4 };
  } else if (type === "batch") {
    const result4 = BatchResult(object(obj["result"]));
    return { type: "batch", result: result4 };
  } else if (type === "sequence") {
    return { type: "sequence" };
  } else if (type === "describe") {
    const result4 = DescribeResult(object(obj["result"]));
    return { type: "describe", result: result4 };
  } else if (type === "store_sql") {
    return { type: "store_sql" };
  } else if (type === "close_sql") {
    return { type: "close_sql" };
  } else if (type === "get_autocommit") {
    const isAutocommit = boolean(obj["is_autocommit"]);
    return { type: "get_autocommit", isAutocommit };
  } else {
    throw new ProtoError("Unexpected type of StreamResponse");
  }
};
function CursorRespBody(obj) {
  const baton = stringOpt(obj["baton"]);
  const baseUrl = stringOpt(obj["base_url"]);
  return { baton, baseUrl };
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/util.
var PipelineRespBody2 = {
  default() {
    return { baton: undefined, baseUrl: undefined, results: [] };
  },
  1(r2, msg) {
    msg.baton = r2.string();
  },
  2(r2, msg) {
    msg.baseUrl = r2.string();
  },
  3(r2, msg) {
    msg.results.push(r2.message(StreamResult2));
  }
};
var StreamResult2 = {
  default() {
    return { type: "none" };
  },
  1(r2) {
    return { type: "ok", response: r2.message(StreamResponse2) };
  },
  2(r2) {
    return { type: "error", error: r2.message(Error3) };
  }
};
var StreamResponse2 = {
  default() {
    return { type: "none" };
  },
  1(r2) {
    return { type: "close" };
  },
  2(r2) {
    return r2.message(ExecuteStreamResp);
  },
  3(r2) {
    return r2.message(BatchStreamResp);
  },
  4(r2) {
    return { type: "sequence" };
  },
  5(r2) {
    return r2.message(DescribeStreamResp);
  },
  6(r2) {
    return { type: "store_sql" };
  },
  7(r2) {
    return { type: "close_sql" };
  },
  8(r2) {
    return r2.message(GetAutocommitStreamResp);
  }
};
var ExecuteStreamResp = {
  default() {
    return { type: "execute", result: StmtResult2.default() };
  },
  1(r2, msg) {
    msg.result = r2.message(StmtResult2);
  }
};
var BatchStreamResp = {
  default() {
    return { type: "batch", result: BatchResult2.default() };
  },
  1(r2, msg) {
    msg.result = r2.message(BatchResult2);
  }
};
var DescribeStreamResp = {
  default() {
    return { type: "describe", result: DescribeResult2.default() };
  },
  1(r2, msg) {
    msg.result = r2.message(DescribeResult2);
  }
};
var GetAutocommitStreamResp = {
  default() {
    return { type: "get_autocommit", isAutocommit: false };
  },
  1(r2, msg) {
    msg.isAutocommit = r2.bool();
  }
};
var CursorRespBody2 = {
  default() {
    return { baton: undefined, baseUrl: undefined };
  },
  1(r2, msg) {
    msg.baton = r2.string();
  },
  2(r2, msg) {
    msg.baseUrl = r2.string();
  }
};

// node_modules/@libsql/hrana-client/lib-esm/encoding/proto
class HttpCursor extends Cursor {
  #stream;
  #encoding;
  #reader;
  #queue;
  #closed;
  #done;
  constructor(stream4, encoding2) {
    super();
    this.#stream = stream4;
    this.#encoding = encoding2;
    this.#reader = undefined;
    this.#queue = new ByteQueue(16 * 1024);
    this.#closed = undefined;
    this.#done = false;
  }
  async open(response) {
    if (response.body === null) {
      throw new ProtoError("No response body for cursor request");
    }
    this.#reader = response.body.getReader();
    const respBody = await this.#nextItem(CursorRespBody, CursorRespBody2);
    if (respBody === undefined) {
      throw new ProtoError("Empty response to cursor request");
    }
    return respBody;
  }
  next() {
    return this.#nextItem(CursorEntry, CursorEntry2);
  }
  close() {
    this._setClosed(new ClientError("Cursor was manually closed"));
  }
  _setClosed(error6) {
    if (this.#closed !== undefined) {
      return;
    }
    this.#closed = error6;
    this.#stream._cursorClosed(this);
    if (this.#reader !== undefined) {
      this.#reader.cancel();
    }
  }
  get closed() {
    return this.#closed !== undefined;
  }
  async#nextItem(jsonFun, protobufDef) {
    for (;; ) {
      if (this.#done) {
        return;
      } else if (this.#closed !== undefined) {
        throw new ClosedError("Cursor is closed", this.#closed);
      }
      if (this.#encoding === "json") {
        const jsonData = this.#parseItemJson();
        if (jsonData !== undefined) {
          const jsonText = new TextDecoder().decode(jsonData);
          const jsonValue = JSON.parse(jsonText);
          return readJsonObject(jsonValue, jsonFun);
        }
      } else if (this.#encoding === "protobuf") {
        const protobufData = this.#parseItemProtobuf();
        if (protobufData !== undefined) {
          return readProtobufMessage(protobufData, protobufDef);
        }
      } else {
        throw impossible(this.#encoding, "Impossible encoding");
      }
      if (this.#reader === undefined) {
        throw new InternalError("Attempted to read from HTTP cursor before it was opened");
      }
      const { value: value4, done } = await this.#reader.read();
      if (done && this.#queue.length === 0) {
        this.#done = true;
      } else if (done) {
        throw new ProtoError("Unexpected end of cursor stream");
      } else {
        this.#queue.push(value4);
      }
    }
  }
  #parseItemJson() {
    const data = this.#queue.data();
    const newlineByte = 10;
    const newlinePos = data.indexOf(newlineByte);
    if (newlinePos < 0) {
      return;
    }
    const jsonData = data.slice(0, newlinePos);
    this.#queue.shift(newlinePos + 1);
    return jsonData;
  }
  #parseItemProtobuf() {
    const data = this.#queue.data();
    let varintValue = 0;
    let varintLength = 0;
    for (;; ) {
      if (varintLength >= data.byteLength) {
        return;
      }
      const byte = data[varintLength];
      varintValue |= (byte & 127) << 7 * varintLength;
      varintLength += 1;
      if (!(byte & 128)) {
        break;
      }
    }
    if (data.byteLength < varintLength + varintValue) {
      return;
    }
    const protobufData = data.slice(varintLength, varintLength + varintValue);
    this.#queue.shift(varintLength + varintValue);
    return protobufData;
  }
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/u
function PipelineReqBody(w, msg) {
  if (msg.baton !== undefined) {
    w.string("baton", msg.baton);
  }
  w.arrayObjects("requests", msg.requests, StreamRequest);
}
var StreamRequest = function(w, msg) {
  w.stringRaw("type", msg.type);
  if (msg.type === "close") {
  } else if (msg.type === "execute") {
    w.object("stmt", msg.stmt, Stmt2);
  } else if (msg.type === "batch") {
    w.object("batch", msg.batch, Batch2);
  } else if (msg.type === "sequence") {
    if (msg.sql !== undefined) {
      w.string("sql", msg.sql);
    }
    if (msg.sqlId !== undefined) {
      w.number("sql_id", msg.sqlId);
    }
  } else if (msg.type === "describe") {
    if (msg.sql !== undefined) {
      w.string("sql", msg.sql);
    }
    if (msg.sqlId !== undefined) {
      w.number("sql_id", msg.sqlId);
    }
  } else if (msg.type === "store_sql") {
    w.number("sql_id", msg.sqlId);
    w.string("sql", msg.sql);
  } else if (msg.type === "close_sql") {
    w.number("sql_id", msg.sqlId);
  } else if (msg.type === "get_autocommit") {
  } else {
    throw impossible(msg, "Impossible type of StreamRequest");
  }
};
function CursorReqBody(w, msg) {
  if (msg.baton !== undefined) {
    w.string("baton", msg.baton);
  }
  w.object("batch", msg.batch, Batch2);
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/protobuf/util.
function PipelineReqBody2(w, msg) {
  if (msg.baton !== undefined) {
    w.string(1, msg.baton);
  }
  for (const req of msg.requests) {
    w.message(2, req, StreamRequest2);
  }
}
var StreamRequest2 = function(w, msg) {
  if (msg.type === "close") {
    w.message(1, msg, CloseStreamReq2);
  } else if (msg.type === "execute") {
    w.message(2, msg, ExecuteStreamReq);
  } else if (msg.type === "batch") {
    w.message(3, msg, BatchStreamReq);
  } else if (msg.type === "sequence") {
    w.message(4, msg, SequenceStreamReq);
  } else if (msg.type === "describe") {
    w.message(5, msg, DescribeStreamReq);
  } else if (msg.type === "store_sql") {
    w.message(6, msg, StoreSqlStreamReq);
  } else if (msg.type === "close_sql") {
    w.message(7, msg, CloseSqlStreamReq);
  } else if (msg.type === "get_autocommit") {
    w.message(8, msg, GetAutocommitStreamReq);
  } else {
    throw impossible(msg, "Impossible type of StreamRequest");
  }
};
var CloseStreamReq2 = function(_w, _msg) {
};
var ExecuteStreamReq = function(w, msg) {
  w.message(1, msg.stmt, Stmt3);
};
var BatchStreamReq = function(w, msg) {
  w.message(1, msg.batch, Batch3);
};
var SequenceStreamReq = function(w, msg) {
  if (msg.sql !== undefined) {
    w.string(1, msg.sql);
  }
  if (msg.sqlId !== undefined) {
    w.int32(2, msg.sqlId);
  }
};
var DescribeStreamReq = function(w, msg) {
  if (msg.sql !== undefined) {
    w.string(1, msg.sql);
  }
  if (msg.sqlId !== undefined) {
    w.int32(2, msg.sqlId);
  }
};
var StoreSqlStreamReq = function(w, msg) {
  w.int32(1, msg.sqlId);
  w.string(2, msg.sql);
};
var CloseSqlStreamReq = function(w, msg) {
  w.int32(1, msg.sqlId);
};
var GetAutocommitStreamReq = function(_w, _msg) {
};
function CursorReqBody2(w, msg) {
  if (msg.baton !== undefined) {
    w.string(1, msg.baton);
  }
  w.message(2, msg.batch, Batch3);
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/proto
var handlePipelineResponse = function(pipeline, respBody) {
  if (respBody.results.length !== pipeline.length) {
    throw new ProtoError("Server returned unexpected number of pipeline results");
  }
  for (let i = 0;i < pipeline.length; ++i) {
    const result5 = respBody.results[i];
    const entry = pipeline[i];
    if (result5.type === "ok") {
      if (result5.response.type !== entry.request.type) {
        throw new ProtoError("Received unexpected type of response");
      }
      entry.responseCallback(result5.response);
    } else if (result5.type === "error") {
      entry.errorCallback(errorFromProto(result5.error));
    } else if (result5.type === "none") {
      throw new ProtoError("Received unrecognized type of StreamResult");
    } else {
      throw impossible(result5, "Received impossible type of StreamResult");
    }
  }
};
async function decodePipelineResponse(resp, encoding3) {
  if (encoding3 === "json") {
    const respJson = await resp.json();
    return readJsonObject(respJson, PipelineRespBody);
  } else if (encoding3 === "protobuf") {
    const respData = await resp.arrayBuffer();
    return readProtobufMessage(new Uint8Array(respData), PipelineRespBody2);
  } else {
    throw impossible(encoding3, "Impossible encoding");
  }
}
async function errorFromResponse(resp) {
  const respType = resp.headers.get("content-type") ?? "text/plain";
  if (respType === "application/json") {
    const respBody = await resp.json();
    if ("message" in respBody) {
      return errorFromProto(respBody);
    }
  }
  let message = `Server returned HTTP status ${resp.status}`;
  if (respType === "text/plain") {
    const respBody = (await resp.text()).trim();
    if (respBody !== "") {
      message += `: ${respBody}`;
    }
  }
  if (resp.status === 404) {
    message += ". It seems that the libsql server is outdated, please try updating the database.";
  }
  return new HttpServerError(message, resp.status);
}

class HttpStream extends Stream {
  #client;
  #baseUrl;
  #jwt;
  #fetch;
  #baton;
  #queue;
  #flushing;
  #cursor;
  #closing;
  #closeQueued;
  #closed;
  #sqlIdAlloc;
  constructor(client2, baseUrl, jwt2, customFetch) {
    super(client2.intMode);
    this.#client = client2;
    this.#baseUrl = baseUrl.toString();
    this.#jwt = jwt2;
    this.#fetch = customFetch;
    this.#baton = undefined;
    this.#queue = new Queue;
    this.#flushing = false;
    this.#closing = false;
    this.#closeQueued = false;
    this.#closed = undefined;
    this.#sqlIdAlloc = new IdAlloc;
  }
  client() {
    return this.#client;
  }
  _sqlOwner() {
    return this;
  }
  storeSql(sql5) {
    const sqlId = this.#sqlIdAlloc.alloc();
    this.#sendStreamRequest({ type: "store_sql", sqlId, sql: sql5 }).then(() => {
      return;
    }, (error6) => this._setClosed(error6));
    return new Sql(this, sqlId);
  }
  _closeSql(sqlId) {
    if (this.#closed !== undefined) {
      return;
    }
    this.#sendStreamRequest({ type: "close_sql", sqlId }).then(() => this.#sqlIdAlloc.free(sqlId), (error6) => this._setClosed(error6));
  }
  _execute(stmt3) {
    return this.#sendStreamRequest({ type: "execute", stmt: stmt3 }).then((response) => {
      return response.result;
    });
  }
  _batch(batch2) {
    return this.#sendStreamRequest({ type: "batch", batch: batch2 }).then((response) => {
      return response.result;
    });
  }
  _describe(protoSql) {
    return this.#sendStreamRequest({
      type: "describe",
      sql: protoSql.sql,
      sqlId: protoSql.sqlId
    }).then((response) => {
      return response.result;
    });
  }
  _sequence(protoSql) {
    return this.#sendStreamRequest({
      type: "sequence",
      sql: protoSql.sql,
      sqlId: protoSql.sqlId
    }).then((_response) => {
      return;
    });
  }
  getAutocommit() {
    this.#client._ensureVersion(3, "getAutocommit()");
    return this.#sendStreamRequest({
      type: "get_autocommit"
    }).then((response) => {
      return response.isAutocommit;
    });
  }
  #sendStreamRequest(request28) {
    return new Promise((responseCallback, errorCallback) => {
      this.#pushToQueue({ type: "pipeline", request: request28, responseCallback, errorCallback });
    });
  }
  _openCursor(batch2) {
    return new Promise((cursorCallback, errorCallback) => {
      this.#pushToQueue({ type: "cursor", batch: batch2, cursorCallback, errorCallback });
    });
  }
  _cursorClosed(cursor5) {
    if (cursor5 !== this.#cursor) {
      throw new InternalError("Cursor was closed, but it was not associated with the stream");
    }
    this.#cursor = undefined;
    _queueMicrotask(() => this.#flushQueue());
  }
  close() {
    this._setClosed(new ClientError("Stream was manually closed"));
  }
  closeGracefully() {
    this.#closing = true;
    _queueMicrotask(() => this.#flushQueue());
  }
  get closed() {
    return this.#closed !== undefined || this.#closing;
  }
  _setClosed(error6) {
    if (this.#closed !== undefined) {
      return;
    }
    this.#closed = error6;
    if (this.#cursor !== undefined) {
      this.#cursor._setClosed(error6);
    }
    this.#client._streamClosed(this);
    for (;; ) {
      const entry = this.#queue.shift();
      if (entry !== undefined) {
        entry.errorCallback(error6);
      } else {
        break;
      }
    }
    if ((this.#baton !== undefined || this.#flushing) && !this.#closeQueued) {
      this.#queue.push({
        type: "pipeline",
        request: { type: "close" },
        responseCallback: () => {
          return;
        },
        errorCallback: () => {
          return;
        }
      });
      this.#closeQueued = true;
      _queueMicrotask(() => this.#flushQueue());
    }
  }
  #pushToQueue(entry) {
    if (this.#closed !== undefined) {
      throw new ClosedError("Stream is closed", this.#closed);
    } else if (this.#closing) {
      throw new ClosedError("Stream is closing", undefined);
    } else {
      this.#queue.push(entry);
      _queueMicrotask(() => this.#flushQueue());
    }
  }
  #flushQueue() {
    if (this.#flushing || this.#cursor !== undefined) {
      return;
    }
    if (this.#closing && this.#queue.length === 0) {
      this._setClosed(new ClientError("Stream was gracefully closed"));
      return;
    }
    const endpoint = this.#client._endpoint;
    if (endpoint === undefined) {
      this.#client._endpointPromise.then(() => this.#flushQueue(), (error6) => this._setClosed(error6));
      return;
    }
    const firstEntry = this.#queue.shift();
    if (firstEntry === undefined) {
      return;
    } else if (firstEntry.type === "pipeline") {
      const pipeline = [firstEntry];
      for (;; ) {
        const entry = this.#queue.first();
        if (entry !== undefined && entry.type === "pipeline") {
          pipeline.push(entry);
          this.#queue.shift();
        } else if (entry === undefined && this.#closing && !this.#closeQueued) {
          pipeline.push({
            type: "pipeline",
            request: { type: "close" },
            responseCallback: () => {
              return;
            },
            errorCallback: () => {
              return;
            }
          });
          this.#closeQueued = true;
          break;
        } else {
          break;
        }
      }
      this.#flushPipeline(endpoint, pipeline);
    } else if (firstEntry.type === "cursor") {
      this.#flushCursor(endpoint, firstEntry);
    } else {
      throw impossible(firstEntry, "Impossible type of QueueEntry");
    }
  }
  #flushPipeline(endpoint, pipeline) {
    this.#flush(() => this.#createPipelineRequest(pipeline, endpoint), (resp) => decodePipelineResponse(resp, endpoint.encoding), (respBody) => respBody.baton, (respBody) => respBody.baseUrl, (respBody) => handlePipelineResponse(pipeline, respBody), (error6) => pipeline.forEach((entry) => entry.errorCallback(error6)));
  }
  #flushCursor(endpoint, entry) {
    const cursor5 = new HttpCursor(this, endpoint.encoding);
    this.#cursor = cursor5;
    this.#flush(() => this.#createCursorRequest(entry, endpoint), (resp) => cursor5.open(resp), (respBody) => respBody.baton, (respBody) => respBody.baseUrl, (_respBody) => entry.cursorCallback(cursor5), (error6) => entry.errorCallback(error6));
  }
  #flush(createRequest, decodeResponse, getBaton, getBaseUrl, handleResponse, handleError) {
    let promise;
    try {
      const request28 = createRequest();
      const fetch2 = this.#fetch;
      promise = fetch2(request28);
    } catch (error6) {
      promise = Promise.reject(error6);
    }
    this.#flushing = true;
    promise.then((resp) => {
      if (!resp.ok) {
        return errorFromResponse(resp).then((error6) => {
          throw error6;
        });
      }
      return decodeResponse(resp);
    }).then((r2) => {
      this.#baton = getBaton(r2);
      this.#baseUrl = getBaseUrl(r2) ?? this.#baseUrl;
      handleResponse(r2);
    }).catch((error6) => {
      this._setClosed(error6);
      handleError(error6);
    }).finally(() => {
      this.#flushing = false;
      this.#flushQueue();
    });
  }
  #createPipelineRequest(pipeline, endpoint) {
    return this.#createRequest(new URL(endpoint.pipelinePath, this.#baseUrl), {
      baton: this.#baton,
      requests: pipeline.map((entry) => entry.request)
    }, endpoint.encoding, PipelineReqBody, PipelineReqBody2);
  }
  #createCursorRequest(entry, endpoint) {
    if (endpoint.cursorPath === undefined) {
      throw new ProtocolVersionError("Cursors are supported only on protocol version 3 and higher, " + `but the HTTP server only supports version ${endpoint.version}.`);
    }
    return this.#createRequest(new URL(endpoint.cursorPath, this.#baseUrl), {
      baton: this.#baton,
      batch: entry.batch
    }, endpoint.encoding, CursorReqBody, CursorReqBody2);
  }
  #createRequest(url3, reqBody, encoding3, jsonFun, protobufFun) {
    let bodyData;
    let contentType;
    if (encoding3 === "json") {
      bodyData = writeJsonObject(reqBody, jsonFun);
      contentType = "application/json";
    } else if (encoding3 === "protobuf") {
      bodyData = writeProtobufMessage(reqBody, protobufFun);
      contentType = "application/x-protobuf";
    } else {
      throw impossible(encoding3, "Impossible encoding");
    }
    const headers = new _Headers;
    headers.set("content-type", contentType);
    if (this.#jwt !== undefined) {
      headers.set("authorization", `Bearer ${this.#jwt}`);
    }
    return new _Request(url3.toString(), { method: "POST", headers, body: bodyData });
  }
}

// node_modules/@libsql/hrana-client/lib-esm/encoding/proto
async function findEndpoint(customFetch, clientUrl) {
  const fetch2 = customFetch;
  for (const endpoint of checkEndpoints) {
    const url3 = new URL(endpoint.versionPath, clientUrl);
    const request28 = new _Request(url3.toString(), { method: "GET" });
    const response = await fetch2(request28);
    await response.arrayBuffer();
    if (response.ok) {
      return endpoint;
    }
  }
  return fallbackEndpoint;
}
var checkEndpoints = [
  {
    versionPath: "v3-protobuf",
    pipelinePath: "v3-protobuf/pipeline",
    cursorPath: "v3-protobuf/cursor",
    version: 3,
    encoding: "protobuf"
  }
];
var fallbackEndpoint = {
  versionPath: "v2",
  pipelinePath: "v2/pipeline",
  cursorPath: undefined,
  version: 2,
  encoding: "json"
};

class HttpClient extends Client {
  #url;
  #jwt;
  #fetch;
  #closed;
  #streams;
  _endpointPromise;
  _endpoint;
  constructor(url3, jwt2, customFetch, protocolVersion = 2) {
    super();
    this.#url = url3;
    this.#jwt = jwt2;
    this.#fetch = customFetch ?? _fetch;
    this.#closed = undefined;
    this.#streams = new Set;
    if (protocolVersion == 3) {
      this._endpointPromise = findEndpoint(this.#fetch, this.#url);
      this._endpointPromise.then((endpoint) => this._endpoint = endpoint, (error6) => this.#setClosed(error6));
    } else {
      this._endpointPromise = Promise.resolve(fallbackEndpoint);
      this._endpointPromise.then((endpoint) => this._endpoint = endpoint, (error6) => this.#setClosed(error6));
    }
  }
  async getVersion() {
    if (this._endpoint !== undefined) {
      return this._endpoint.version;
    }
    return (await this._endpointPromise).version;
  }
  _ensureVersion(minVersion, feature) {
    if (minVersion <= fallbackEndpoint.version) {
      return;
    } else if (this._endpoint === undefined) {
      throw new ProtocolVersionError(`${feature} is supported only on protocol version ${minVersion} and higher, ` + "but the version supported by the HTTP server is not yet known. Use Client.getVersion() to wait until the version is available.");
    } else if (this._endpoint.version < minVersion) {
      throw new ProtocolVersionError(`${feature} is supported only on protocol version ${minVersion} and higher, ` + `but the HTTP server only supports version ${this._endpoint.version}.`);
    }
  }
  openStream() {
    if (this.#closed !== undefined) {
      throw new ClosedError("Client is closed", this.#closed);
    }
    const stream6 = new HttpStream(this, this.#url, this.#jwt, this.#fetch);
    this.#streams.add(stream6);
    return stream6;
  }
  _streamClosed(stream6) {
    this.#streams.delete(stream6);
  }
  close() {
    this.#setClosed(new ClientError("Client was manually closed"));
  }
  get closed() {
    return this.#closed !== undefined;
  }
  #setClosed(error6) {
    if (this.#closed !== undefined) {
      return;
    }
    this.#closed = error6;
    for (const stream6 of Array.from(this.#streams)) {
      stream6._setClosed(new ClosedError("Client was closed", error6));
    }
  }
}

// node_modules/@libsql/hrana-client/lib-esm/encoding
function openWs(url3, jwt2, protocolVersion = 2) {
  if (typeof _WebSocket === "undefined") {
    throw new WebSocketUnsupportedError("WebSockets are not supported in this environment");
  }
  var subprotocols = undefined;
  if (protocolVersion == 3) {
    subprotocols = Array.from(subprotocolsV3.keys());
  } else {
    subprotocols = Array.from(subprotocolsV2.keys());
  }
  const socket = new _WebSocket(url3, subprotocols);
  return new WsClient(socket, jwt2);
}
function openHttp(url3, jwt2, customFetch, protocolVersion = 2) {
  return new HttpClient(url3 instanceof URL ? url3 : new URL(url3), jwt2, customFetch, protocolVersion);
}

// node_modules/@libsql/hrana-client/lib-esm/en
async function executeHranaBatch(mode, version2, batch2, hranaStmts) {
  const beginStep = batch2.step();
  const beginPromise = beginStep.run(transactionModeToBegin(mode));
  let lastStep = beginStep;
  const stmtPromises = hranaStmts.map((hranaStmt) => {
    const stmtStep = batch2.step().condition(BatchCond.ok(lastStep));
    if (version2 >= 3) {
      stmtStep.condition(BatchCond.not(BatchCond.isAutocommit(batch2)));
    }
    const stmtPromise = stmtStep.query(hranaStmt);
    lastStep = stmtStep;
    return stmtPromise;
  });
  const commitStep = batch2.step().condition(BatchCond.ok(lastStep));
  if (version2 >= 3) {
    commitStep.condition(BatchCond.not(BatchCond.isAutocommit(batch2)));
  }
  const commitPromise = commitStep.run("COMMIT");
  const rollbackStep = batch2.step().condition(BatchCond.not(BatchCond.ok(commitStep)));
  rollbackStep.run("ROLLBACK").catch((_) => {
    return;
  });
  await batch2.execute();
  const resultSets = [];
  await beginPromise;
  for (const stmtPromise of stmtPromises) {
    const hranaRows = await stmtPromise;
    if (hranaRows === undefined) {
      throw new LibsqlError("Statement in a batch was not executed, probably because the transaction has been rolled back", "TRANSACTION_CLOSED");
    }
    resultSets.push(resultSetFromHrana(hranaRows));
  }
  await commitPromise;
  return resultSets;
}
function stmtToHrana(stmt3) {
  if (typeof stmt3 === "string") {
    return new Stmt(stmt3);
  }
  const hranaStmt = new Stmt(stmt3.sql);
  if (Array.isArray(stmt3.args)) {
    hranaStmt.bindIndexes(stmt3.args);
  } else {
    for (const [key, value4] of Object.entries(stmt3.args)) {
      hranaStmt.bindName(key, value4);
    }
  }
  return hranaStmt;
}
function resultSetFromHrana(hranaRows) {
  const columns = hranaRows.columnNames.map((c) => c ?? "");
  const columnTypes = hranaRows.columnDecltypes.map((c) => c ?? "");
  const rows = hranaRows.rows;
  const rowsAffected = hranaRows.affectedRowCount;
  const lastInsertRowid = hranaRows.lastInsertRowid !== undefined ? hranaRows.lastInsertRowid : undefined;
  return new ResultSetImpl(columns, columnTypes, rows, rowsAffected, lastInsertRowid);
}
function mapHranaError(e2) {
  if (e2 instanceof ClientError) {
    const code = mapHranaErrorCode(e2);
    return new LibsqlError(e2.message, code, e2);
  }
  return e2;
}
var mapHranaErrorCode = function(e2) {
  if (e2 instanceof ResponseError && e2.code !== undefined) {
    return e2.code;
  } else if (e2 instanceof ProtoError) {
    return "HRANA_PROTO_ERROR";
  } else if (e2 instanceof ClosedError) {
    return e2.cause instanceof ClientError ? mapHranaErrorCode(e2.cause) : "HRANA_CLOSED_ERROR";
  } else if (e2 instanceof WebSocketError) {
    return "HRANA_WEBSOCKET_ERROR";
  } else if (e2 instanceof HttpServerError) {
    return "SERVER_ERROR";
  } else if (e2 instanceof ProtocolVersionError) {
    return "PROTOCOL_VERSION_ERROR";
  } else if (e2 instanceof InternalError) {
    return "INTERNAL_ERROR";
  } else {
    return "UNKNOWN";
  }
};

class HranaTransaction {
  #mode;
  #version;
  #started;
  constructor(mode, version2) {
    this.#mode = mode;
    this.#version = version2;
    this.#started = undefined;
  }
  execute(stmt3) {
    return this.batch([stmt3]).then((results) => results[0]);
  }
  async batch(stmts) {
    const stream6 = this._getStream();
    if (stream6.closed) {
      throw new LibsqlError("Cannot execute statements because the transaction is closed", "TRANSACTION_CLOSED");
    }
    try {
      const hranaStmts = stmts.map(stmtToHrana);
      let rowsPromises;
      if (this.#started === undefined) {
        this._getSqlCache().apply(hranaStmts);
        const batch2 = stream6.batch(this.#version >= 3);
        const beginStep = batch2.step();
        const beginPromise = beginStep.run(transactionModeToBegin(this.#mode));
        let lastStep = beginStep;
        rowsPromises = hranaStmts.map((hranaStmt) => {
          const stmtStep = batch2.step().condition(BatchCond.ok(lastStep));
          if (this.#version >= 3) {
            stmtStep.condition(BatchCond.not(BatchCond.isAutocommit(batch2)));
          }
          const rowsPromise = stmtStep.query(hranaStmt);
          rowsPromise.catch(() => {
            return;
          });
          lastStep = stmtStep;
          return rowsPromise;
        });
        this.#started = batch2.execute().then(() => beginPromise).then(() => {
          return;
        });
        try {
          await this.#started;
        } catch (e2) {
          this.close();
          throw e2;
        }
      } else {
        if (this.#version < 3) {
          await this.#started;
        } else {
        }
        this._getSqlCache().apply(hranaStmts);
        const batch2 = stream6.batch(this.#version >= 3);
        let lastStep = undefined;
        rowsPromises = hranaStmts.map((hranaStmt) => {
          const stmtStep = batch2.step();
          if (lastStep !== undefined) {
            stmtStep.condition(BatchCond.ok(lastStep));
          }
          if (this.#version >= 3) {
            stmtStep.condition(BatchCond.not(BatchCond.isAutocommit(batch2)));
          }
          const rowsPromise = stmtStep.query(hranaStmt);
          rowsPromise.catch(() => {
            return;
          });
          lastStep = stmtStep;
          return rowsPromise;
        });
        await batch2.execute();
      }
      const resultSets = [];
      for (const rowsPromise of rowsPromises) {
        const rows = await rowsPromise;
        if (rows === undefined) {
          throw new LibsqlError("Statement in a transaction was not executed, probably because the transaction has been rolled back", "TRANSACTION_CLOSED");
        }
        resultSets.push(resultSetFromHrana(rows));
      }
      return resultSets;
    } catch (e2) {
      throw mapHranaError(e2);
    }
  }
  async executeMultiple(sql5) {
    const stream6 = this._getStream();
    if (stream6.closed) {
      throw new LibsqlError("Cannot execute statements because the transaction is closed", "TRANSACTION_CLOSED");
    }
    try {
      if (this.#started === undefined) {
        this.#started = stream6.run(transactionModeToBegin(this.#mode)).then(() => {
          return;
        });
        try {
          await this.#started;
        } catch (e2) {
          this.close();
          throw e2;
        }
      } else {
        await this.#started;
      }
      await stream6.sequence(sql5);
    } catch (e2) {
      throw mapHranaError(e2);
    }
  }
  async rollback() {
    try {
      const stream6 = this._getStream();
      if (stream6.closed) {
        return;
      }
      if (this.#started !== undefined) {
      } else {
        return;
      }
      const promise = stream6.run("ROLLBACK").catch((e2) => {
        throw mapHranaError(e2);
      });
      stream6.closeGracefully();
      await promise;
    } catch (e2) {
      throw mapHranaError(e2);
    } finally {
      this.close();
    }
  }
  async commit() {
    try {
      const stream6 = this._getStream();
      if (stream6.closed) {
        throw new LibsqlError("Cannot commit the transaction because it is already closed", "TRANSACTION_CLOSED");
      }
      if (this.#started !== undefined) {
        await this.#started;
      } else {
        return;
      }
      const promise = stream6.run("COMMIT").catch((e2) => {
        throw mapHranaError(e2);
      });
      stream6.closeGracefully();
      await promise;
    } catch (e2) {
      throw mapHranaError(e2);
    } finally {
      this.close();
    }
  }
}

// node_modules/@libsql/hrana-client/lib-esm/encodi
class SqlCache {
  #owner;
  #sqls;
  capacity;
  constructor(owner, capacity) {
    this.#owner = owner;
    this.#sqls = new Lru;
    this.capacity = capacity;
  }
  apply(hranaStmts) {
    if (this.capacity <= 0) {
      return;
    }
    const usedSqlObjs = new Set;
    for (const hranaStmt of hranaStmts) {
      if (typeof hranaStmt.sql !== "string") {
        continue;
      }
      const sqlText = hranaStmt.sql;
      let sqlObj = this.#sqls.get(sqlText);
      if (sqlObj === undefined) {
        while (this.#sqls.size + 1 > this.capacity) {
          const [evictSqlText, evictSqlObj] = this.#sqls.peekLru();
          if (usedSqlObjs.has(evictSqlObj)) {
            break;
          }
          evictSqlObj.close();
          this.#sqls.delete(evictSqlText);
        }
        if (this.#sqls.size + 1 <= this.capacity) {
          sqlObj = this.#owner.storeSql(sqlText);
          this.#sqls.set(sqlText, sqlObj);
        }
      }
      if (sqlObj !== undefined) {
        hranaStmt.sql = sqlObj;
        usedSqlObjs.add(sqlObj);
      }
    }
  }
}

class Lru {
  #cache;
  constructor() {
    this.#cache = new Map;
  }
  get(key) {
    const value4 = this.#cache.get(key);
    if (value4 !== undefined) {
      this.#cache.delete(key);
      this.#cache.set(key, value4);
    }
    return value4;
  }
  set(key, value4) {
    this.#cache.set(key, value4);
  }
  peekLru() {
    for (const entry of this.#cache.entries()) {
      return entry;
    }
    return;
  }
  delete(key) {
    this.#cache.delete(key);
  }
  get size() {
    return this.#cache.size;
  }
}
// node_modules/@libsql/hrana-client/lib-esm
function _createClient2(config6) {
  if (config6.scheme !== "wss" && config6.scheme !== "ws") {
    throw new LibsqlError('The WebSocket client supports only "libsql:", "wss:" and "ws:" URLs, ' + `got ${JSON.stringify(config6.scheme + ":")}. For more information, please read ${supportedUrlLink}`, "URL_SCHEME_NOT_SUPPORTED");
  }
  if (config6.scheme === "ws" && config6.tls) {
    throw new LibsqlError(`A "ws:" URL cannot opt into TLS by using ?tls=1`, "URL_INVALID");
  } else if (config6.scheme === "wss" && !config6.tls) {
    throw new LibsqlError(`A "wss:" URL cannot opt out of TLS by using ?tls=0`, "URL_INVALID");
  }
  const url3 = encodeBaseUrl(config6.scheme, config6.authority, config6.path);
  let client6;
  try {
    client6 = openWs(url3, config6.authToken);
  } catch (e2) {
    if (e2 instanceof WebSocketUnsupportedError) {
      const suggestedScheme = config6.scheme === "wss" ? "https" : "http";
      const suggestedUrl = encodeBaseUrl(suggestedScheme, config6.authority, config6.path);
      throw new LibsqlError("This environment does not support WebSockets, please switch to the HTTP client by using " + `a "${suggestedScheme}:" URL (${JSON.stringify(suggestedUrl)}). ` + `For more information, please read ${supportedUrlLink}`, "WEBSOCKETS_NOT_SUPPORTED");
    }
    throw mapHranaError(e2);
  }
  return new WsClient2(client6, url3, config6.authToken, config6.intMode);
}
var maxConnAgeMillis = 60 * 1000;
var sqlCacheCapacity = 100;

class WsClient2 {
  #url;
  #authToken;
  #intMode;
  #connState;
  #futureConnState;
  closed;
  protocol;
  constructor(client6, url3, authToken, intMode) {
    this.#url = url3;
    this.#authToken = authToken;
    this.#intMode = intMode;
    this.#connState = this.#openConn(client6);
    this.#futureConnState = undefined;
    this.closed = false;
    this.protocol = "ws";
  }
  async execute(stmt3) {
    const streamState = await this.#openStream();
    try {
      const hranaStmt = stmtToHrana(stmt3);
      streamState.conn.sqlCache.apply([hranaStmt]);
      const hranaRowsPromise = streamState.stream.query(hranaStmt);
      streamState.stream.closeGracefully();
      return resultSetFromHrana(await hranaRowsPromise);
    } catch (e2) {
      throw mapHranaError(e2);
    } finally {
      this._closeStream(streamState);
    }
  }
  async batch(stmts, mode = "deferred") {
    const streamState = await this.#openStream();
    try {
      const hranaStmts = stmts.map(stmtToHrana);
      const version2 = await streamState.conn.client.getVersion();
      streamState.conn.sqlCache.apply(hranaStmts);
      const batch2 = streamState.stream.batch(version2 >= 3);
      const resultsPromise = executeHranaBatch(mode, version2, batch2, hranaStmts);
      return await resultsPromise;
    } catch (e2) {
      throw mapHranaError(e2);
    } finally {
      this._closeStream(streamState);
    }
  }
  async transaction(mode = "write") {
    const streamState = await this.#openStream();
    try {
      const version2 = await streamState.conn.client.getVersion();
      return new WsTransaction(this, streamState, mode, version2);
    } catch (e2) {
      this._closeStream(streamState);
      throw mapHranaError(e2);
    }
  }
  async executeMultiple(sql5) {
    const streamState = await this.#openStream();
    try {
      const promise = streamState.stream.sequence(sql5);
      streamState.stream.closeGracefully();
      await promise;
    } catch (e2) {
      throw mapHranaError(e2);
    } finally {
      this._closeStream(streamState);
    }
  }
  sync() {
    return Promise.resolve();
  }
  async#openStream() {
    if (this.closed) {
      throw new LibsqlError("The client is closed", "CLIENT_CLOSED");
    }
    const now = new Date;
    const ageMillis = now.valueOf() - this.#connState.openTime.valueOf();
    if (ageMillis > maxConnAgeMillis && this.#futureConnState === undefined) {
      const futureConnState = this.#openConn();
      this.#futureConnState = futureConnState;
      futureConnState.client.getVersion().then((_version) => {
        if (this.#connState !== futureConnState) {
          if (this.#connState.streamStates.size === 0) {
            this.#connState.client.close();
          } else {
          }
        }
        this.#connState = futureConnState;
        this.#futureConnState = undefined;
      }, (_e) => {
        this.#futureConnState = undefined;
      });
    }
    if (this.#connState.client.closed) {
      try {
        if (this.#futureConnState !== undefined) {
          this.#connState = this.#futureConnState;
        } else {
          this.#connState = this.#openConn();
        }
      } catch (e2) {
        throw mapHranaError(e2);
      }
    }
    const connState = this.#connState;
    try {
      if (connState.useSqlCache === undefined) {
        connState.useSqlCache = await connState.client.getVersion() >= 2;
        if (connState.useSqlCache) {
          connState.sqlCache.capacity = sqlCacheCapacity;
        }
      }
      const stream6 = connState.client.openStream();
      stream6.intMode = this.#intMode;
      const streamState = { conn: connState, stream: stream6 };
      connState.streamStates.add(streamState);
      return streamState;
    } catch (e2) {
      throw mapHranaError(e2);
    }
  }
  #openConn(client6) {
    try {
      client6 ??= openWs(this.#url, this.#authToken);
      return {
        client: client6,
        useSqlCache: undefined,
        sqlCache: new SqlCache(client6, 0),
        openTime: new Date,
        streamStates: new Set
      };
    } catch (e2) {
      throw mapHranaError(e2);
    }
  }
  _closeStream(streamState) {
    streamState.stream.close();
    const connState = streamState.conn;
    connState.streamStates.delete(streamState);
    if (connState.streamStates.size === 0 && connState !== this.#connState) {
      connState.client.close();
    }
  }
  close() {
    this.#connState.client.close();
    this.closed = true;
  }
}

class WsTransaction extends HranaTransaction {
  #client;
  #streamState;
  constructor(client6, state, mode, version2) {
    super(mode, version2);
    this.#client = client6;
    this.#streamState = state;
  }
  _getStream() {
    return this.#streamState.stream;
  }
  _getSqlCache() {
    return this.#streamState.conn.sqlCache;
  }
  close() {
    this.#client._closeStream(this.#streamState);
  }
  get closed() {
    return this.#streamState.stream.closed;
  }
}
// node_modules/@libsql/hrana-client/lib-esm/e
function _createClient3(config7) {
  if (config7.scheme !== "https" && config7.scheme !== "http") {
    throw new LibsqlError('The HTTP client supports only "libsql:", "https:" and "http:" URLs, ' + `got ${JSON.stringify(config7.scheme + ":")}. For more information, please read ${supportedUrlLink}`, "URL_SCHEME_NOT_SUPPORTED");
  }
  if (config7.scheme === "http" && config7.tls) {
    throw new LibsqlError(`A "http:" URL cannot opt into TLS by using ?tls=1`, "URL_INVALID");
  } else if (config7.scheme === "https" && !config7.tls) {
    throw new LibsqlError(`A "https:" URL cannot opt out of TLS by using ?tls=0`, "URL_INVALID");
  }
  const url3 = encodeBaseUrl(config7.scheme, config7.authority, config7.path);
  return new HttpClient2(url3, config7.authToken, config7.intMode, config7.fetch);
}
var sqlCacheCapacity2 = 30;

class HttpClient2 {
  #client;
  protocol;
  constructor(url3, authToken, intMode, customFetch) {
    this.#client = openHttp(url3, authToken, customFetch);
    this.#client.intMode = intMode;
    this.protocol = "http";
  }
  async execute(stmt3) {
    try {
      const hranaStmt = stmtToHrana(stmt3);
      let rowsPromise;
      const stream6 = this.#client.openStream();
      try {
        rowsPromise = stream6.query(hranaStmt);
      } finally {
        stream6.closeGracefully();
      }
      return resultSetFromHrana(await rowsPromise);
    } catch (e2) {
      throw mapHranaError(e2);
    }
  }
  async batch(stmts, mode = "deferred") {
    try {
      const hranaStmts = stmts.map(stmtToHrana);
      const version2 = await this.#client.getVersion();
      let resultsPromise;
      const stream6 = this.#client.openStream();
      try {
        const sqlCache = new SqlCache(stream6, sqlCacheCapacity2);
        sqlCache.apply(hranaStmts);
        const batch2 = stream6.batch(false);
        resultsPromise = executeHranaBatch(mode, version2, batch2, hranaStmts);
      } finally {
        stream6.closeGracefully();
      }
      return await resultsPromise;
    } catch (e2) {
      throw mapHranaError(e2);
    }
  }
  async transaction(mode = "write") {
    try {
      const version2 = await this.#client.getVersion();
      return new HttpTransaction(this.#client.openStream(), mode, version2);
    } catch (e2) {
      throw mapHranaError(e2);
    }
  }
  async executeMultiple(sql5) {
    try {
      let promise;
      const stream6 = this.#client.openStream();
      try {
        promise = stream6.sequence(sql5);
      } finally {
        stream6.closeGracefully();
      }
      await promise;
    } catch (e2) {
      throw mapHranaError(e2);
    }
  }
  sync() {
    return Promise.resolve();
  }
  close() {
    this.#client.close();
  }
  get closed() {
    return this.#client.closed;
  }
}

class HttpTransaction extends HranaTransaction {
  #stream;
  #sqlCache;
  constructor(stream6, mode, version2) {
    super(mode, version2);
    this.#stream = stream6;
    this.#sqlCache = new SqlCache(stream6, sqlCacheCapacity2);
  }
  _getStream() {
    return this.#stream;
  }
  _getSqlCache() {
    return this.#sqlCache;
  }
  close() {
    this.#stream.close();
  }
  get closed() {
    return this.#stream.closed;
  }
}

// node_modules/@libsql/hrana-client/lib-esm/e
function createClient(config8) {
  return _createClient4(expandConfig(config8, true));
}
var _createClient4 = function(config8) {
  if (config8.scheme === "wss" || config8.scheme === "ws") {
    return _createClient2(config8);
  } else if (config8.scheme === "https" || config8.scheme === "http") {
    return _createClient3(config8);
  } else {
    return _createClient(config8);
  }
};

// node_modules/@libsql/hrana-client/lib-esm/e
var is = function(value4, type) {
  if (!value4 || typeof value4 !== "object") {
    return false;
  }
  if (value4 instanceof type) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type, entityKind)) {
    throw new Error(`Class "${type.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
  }
  let cls = value4.constructor;
  if (cls) {
    while (cls) {
      if ((entityKind in cls) && cls[entityKind] === type[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
};
var mapResultRow = function(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result5 = columns.reduce((result6, { path, field }, columnIndex) => {
    let decoder2;
    if (is(field, Column)) {
      decoder2 = field;
    } else if (is(field, SQL)) {
      decoder2 = field.decoder;
    } else {
      decoder2 = field.sql.decoder;
    }
    let node = result6;
    for (const [pathChunkIndex, pathChunk] of path.entries()) {
      if (pathChunkIndex < path.length - 1) {
        if (!(pathChunk in node)) {
          node[pathChunk] = {};
        }
        node = node[pathChunk];
      } else {
        const rawValue = row[columnIndex];
        const value4 = node[pathChunk] = rawValue === null ? null : decoder2.mapFromDriverValue(rawValue);
        if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
          const objectName = path[0];
          if (!(objectName in nullifyMap)) {
            nullifyMap[objectName] = value4 === null ? getTableName(field.table) : false;
          } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
            nullifyMap[objectName] = false;
          }
        }
      }
    }
    return result6;
  }, {});
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result5[objectName] = null;
      }
    }
  }
  return result5;
};
var orderSelectedFields = function(fields, pathPrefix) {
  return Object.entries(fields).reduce((result5, [name, field]) => {
    if (typeof name !== "string") {
      return result5;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result5.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result5.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result5.push(...orderSelectedFields(field, newPath));
    }
    return result5;
  }, []);
};
var mapUpdateSet = function(table, values) {
  const entries = Object.entries(values).filter(([, value4]) => value4 !== undefined).map(([key, value4]) => {
    if (is(value4, SQL)) {
      return [key, value4];
    } else {
      return [key, new Param(value4, table[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
};
var applyMixins = function(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      Object.defineProperty(baseClass.prototype, name, Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || Object.create(null));
    }
  }
};
var getTableColumns = function(table) {
  return table[Table.Symbol.Columns];
};
var getTableLikeName = function(table) {
  return is(table, Subquery) ? table[SubqueryConfig].alias : is(table, View) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : table[Table.Symbol.IsAlias] ? table[Table.Symbol.Name] : table[Table.Symbol.BaseName];
};
var isTable = function(table) {
  return typeof table === "object" && table !== null && (IsDrizzleTable in table);
};
var getTableName = function(table) {
  return table[TableName];
};
var uniqueKeyName = function(table, columns) {
  return `${table[PgTable.Symbol.Name]}_${columns.join("_")}_unique`;
};
var getOperators = function() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql: sql5
  };
};
var getOrderByOperators = function() {
  return {
    sql: sql5,
    asc,
    desc
  };
};
var extractTablesRelationalConfig = function(schema, configHelpers) {
  if (Object.keys(schema).length === 1 && ("default" in schema) && !is(schema["default"], Table)) {
    schema = schema["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value4] of Object.entries(schema)) {
    if (isTable(value4)) {
      const dbName = value4[Table.Symbol.Name];
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value4[Table.Symbol.Name],
        columns: value4[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column of Object.values(value4[Table.Symbol.Columns])) {
        if (column.primary) {
          tablesConfig[key].primaryKey.push(column);
        }
      }
      const extraConfig = value4[Table.Symbol.ExtraConfigBuilder]?.(value4);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value4, Relations)) {
      const dbName = value4.table[Table.Symbol.Name];
      const tableName = tableNamesMap[dbName];
      const relations = value4.config(configHelpers(value4.table));
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
};
var relations = function(table, relations2) {
  return new Relations(table, (helpers) => Object.fromEntries(Object.entries(relations2(helpers)).map(([key, value4]) => [
    key,
    value4.withFieldName(key)
  ])));
};
var createOne = function(sourceTable) {
  return function one(table, config8) {
    return new One(sourceTable, table, config8, config8?.fields.reduce((res, f) => res && f.notNull, true) ?? false);
  };
};
var createMany = function(sourceTable) {
  return function many(referencedTable, config8) {
    return new Many(sourceTable, referencedTable, config8);
  };
};
var normalizeRelation = function(schema, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[relation.referencedTable[Table.Symbol.Name]];
  if (!referencedTableTsName) {
    throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
  }
  const referencedTableConfig = schema[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[sourceTable[Table.Symbol.Name]];
  if (!sourceTableTsName) {
    throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(referencedTableConfig.relations)) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`) : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
};
var createTableRelationsHelpers = function(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
};
var mapRelationalRow = function(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value4) => value4) {
  const result5 = {};
  for (const [selectionItemIndex, selectionItem] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result5[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRows, selectionItem.selection, mapColumnValue) : subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRow, selectionItem.selection, mapColumnValue));
    } else {
      const value4 = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder2;
      if (is(field, Column)) {
        decoder2 = field;
      } else if (is(field, SQL)) {
        decoder2 = field.decoder;
      } else {
        decoder2 = field.sql.decoder;
      }
      result5[selectionItem.tsKey] = value4 === null ? null : decoder2.mapFromDriverValue(value4);
    }
  }
  return result5;
};
var bindIfParam = function(value4, column) {
  if (isDriverValueEncoder(column) && !isSQLWrapper(value4) && !is(value4, Param) && !is(value4, Placeholder) && !is(value4, Column) && !is(value4, Table) && !is(value4, View)) {
    return new Param(value4, column);
  }
  return value4;
};
var and = function(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql5.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
};
var or = function(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c) => c !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql5.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
};
var not = function(condition) {
  return sql5`not ${condition}`;
};
var inArray = function(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      throw new Error("inArray requires at least one value");
    }
    return sql5`${column} in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql5`${column} in ${bindIfParam(values, column)}`;
};
var notInArray = function(column, values) {
  if (Array.isArray(values)) {
    if (values.length === 0) {
      throw new Error("notInArray requires at least one value");
    }
    return sql5`${column} not in ${values.map((v) => bindIfParam(v, column))}`;
  }
  return sql5`${column} not in ${bindIfParam(values, column)}`;
};
var isNull = function(value4) {
  return sql5`${value4} is null`;
};
var isNotNull = function(value4) {
  return sql5`${value4} is not null`;
};
var exists = function(subquery) {
  return sql5`exists (${subquery})`;
};
var notExists = function(subquery) {
  return sql5`not exists (${subquery})`;
};
var between = function(column, min, max) {
  return sql5`${column} between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
};
var notBetween = function(column, min, max) {
  return sql5`${column} not between ${bindIfParam(min, column)} and ${bindIfParam(max, column)}`;
};
var like = function(column, value4) {
  return sql5`${column} like ${value4}`;
};
var notLike = function(column, value4) {
  return sql5`${column} not like ${value4}`;
};
var ilike = function(column, value4) {
  return sql5`${column} ilike ${value4}`;
};
var notIlike = function(column, value4) {
  return sql5`${column} not ilike ${value4}`;
};
var asc = function(column) {
  return sql5`${column} asc`;
};
var desc = function(column) {
  return sql5`${column} desc`;
};
var isSQLWrapper = function(value4) {
  return typeof value4 === "object" && value4 !== null && ("getSQL" in value4) && typeof value4.getSQL === "function";
};
var mergeQueries = function(queries) {
  const result5 = { sql: "", params: [] };
  for (const query of queries) {
    result5.sql += query.sql;
    result5.params.push(...query.params);
    if (query.typings?.length) {
      if (!result5.typings) {
        result5.typings = [];
      }
      result5.typings.push(...query.typings);
    }
  }
  return result5;
};
var isDriverValueEncoder = function(value4) {
  return typeof value4 === "object" && value4 !== null && ("mapToDriverValue" in value4) && typeof value4.mapToDriverValue === "function";
};
var sql5 = function(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param] of params.entries()) {
    queryChunks.push(param, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
};
var fillPlaceholders = function(params, values) {
  return params.map((p) => {
    if (is(p, Placeholder)) {
      if (!(p.name in values)) {
        throw new Error(`No value for placeholder "${p.name}" was provided`);
      }
      return values[p.name];
    }
    return p;
  });
};
var aliasedTable = function(table, tableAlias) {
  return new Proxy(table, new TableAliasProxyHandler(tableAlias, false));
};
var aliasedTableColumn = function(column, tableAlias) {
  return new Proxy(column, new ColumnAliasProxyHandler(new Proxy(column.table, new TableAliasProxyHandler(tableAlias, false))));
};
var mapColumnsInAliasedSQLToAlias = function(query, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query.sql, alias), query.fieldAlias);
};
var mapColumnsInSQLToAlias = function(query, alias) {
  return sql5.join(query.queryChunks.map((c) => {
    if (is(c, Column)) {
      return aliasedTableColumn(c, alias);
    }
    if (is(c, SQL)) {
      return mapColumnsInSQLToAlias(c, alias);
    }
    if (is(c, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c, alias);
    }
    return c;
  }));
};
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");

class Column {
  table;
  static [entityKind] = "Column";
  name;
  primary;
  notNull;
  default;
  defaultFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = undefined;
  config;
  constructor(table, config8) {
    this.table = table;
    this.config = config8;
    this.name = config8.name;
    this.notNull = config8.notNull;
    this.default = config8.default;
    this.defaultFn = config8.defaultFn;
    this.hasDefault = config8.hasDefault;
    this.primary = config8.primaryKey;
    this.isUnique = config8.isUnique;
    this.uniqueName = config8.uniqueName;
    this.uniqueType = config8.uniqueType;
    this.dataType = config8.dataType;
    this.columnType = config8.columnType;
  }
  mapFromDriverValue(value4) {
    return value4;
  }
  mapToDriverValue(value4) {
    return value4;
  }
}
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");

class View {
  static [entityKind] = "View";
  [ViewBaseConfig];
  constructor({ name, schema, selectedFields, query }) {
    this[ViewBaseConfig] = {
      name,
      originalName: name,
      schema,
      selectedFields,
      query,
      isExisting: !query,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
}
var SubqueryConfig = Symbol.for("drizzle:SubqueryConfig");

class Subquery {
  static [entityKind] = "Subquery";
  [SubqueryConfig];
  constructor(sql6, selection, alias, isWith = false) {
    this[SubqueryConfig] = {
      sql: sql6,
      selection,
      alias,
      isWith
    };
  }
  getSQL() {
    return new SQL([this]);
  }
}

class WithSubquery extends Subquery {
  static [entityKind] = "WithSubquery";
}

class SelectionProxyHandler {
  static [entityKind] = "SelectionProxyHandler";
  config;
  constructor(config8) {
    this.config = { ...config8 };
  }
  get(subquery, prop) {
    if (prop === SubqueryConfig) {
      return {
        ...subquery[SubqueryConfig],
        selection: new Proxy(subquery[SubqueryConfig].selection, this)
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery[ViewBaseConfig],
        selectedFields: new Proxy(subquery[ViewBaseConfig].selectedFields, this)
      };
    }
    if (typeof prop === "symbol") {
      return subquery[prop];
    }
    const columns = is(subquery, Subquery) ? subquery[SubqueryConfig].selection : is(subquery, View) ? subquery[ViewBaseConfig].selectedFields : subquery;
    const value4 = columns[prop];
    if (is(value4, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value4.isSelectionField) {
        return value4.sql;
      }
      const newValue = value4.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is(value4, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value4;
      }
      throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
    }
    if (is(value4, Column)) {
      if (this.config.alias) {
        return new Proxy(value4, new ColumnAliasProxyHandler(new Proxy(value4.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
      }
      return value4;
    }
    if (typeof value4 !== "object" || value4 === null) {
      return value4;
    }
    return new Proxy(value4, new SelectionProxyHandler(this.config));
  }
}
var TableName = Symbol.for("drizzle:Name");
var Schema = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");

class Table {
  static [entityKind] = "Table";
  static Symbol = {
    Name: TableName,
    Schema,
    OriginalName,
    Columns,
    BaseName,
    IsAlias,
    ExtraConfigBuilder
  };
  [TableName];
  [OriginalName];
  [Schema];
  [Columns];
  [BaseName];
  [IsAlias] = false;
  [ExtraConfigBuilder] = undefined;
  [IsDrizzleTable] = true;
  constructor(name, schema, baseName) {
    this[TableName] = this[OriginalName] = name;
    this[Schema] = schema;
    this[BaseName] = baseName;
  }
  getSQL() {
    return new SQL([this]);
  }
}

class QueryPromise {
  static [entityKind] = "QueryPromise";
  [Symbol.toStringTag] = "QueryPromise";
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value4) => {
      onFinally?.();
      return value4;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
}
var tracer = {
  startActiveSpan(name, fn) {
    {
      return fn();
    }
  }
};

class DrizzleError extends Error {
  static [entityKind] = "DrizzleError";
  constructor(message) {
    super(message);
    this.name = "DrizzleError";
  }
  static wrap(error6, message) {
    return error6 instanceof Error ? new DrizzleError(message ? `${message}: ${error6.message}` : error6.message) : new DrizzleError(message ?? String(error6));
  }
}

class TransactionRollbackError extends DrizzleError {
  static [entityKind] = "TransactionRollbackError";
  constructor() {
    super("Rollback");
  }
}
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");

class PgTable extends Table {
  static [entityKind] = "PgTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys
  });
  [InlineForeignKeys] = [];
  [Table.Symbol.ExtraConfigBuilder] = undefined;
}
class PrimaryKeyBuilder {
  static [entityKind] = "PgPrimaryKeyBuilder";
  columns;
  constructor(columns) {
    this.columns = columns;
  }
  build(table) {
    return new PrimaryKey(table, this.columns);
  }
}

class PrimaryKey {
  table;
  static [entityKind] = "PgPrimaryKey";
  columns;
  constructor(table, columns) {
    this.table = table;
    this.columns = columns;
  }
  getName() {
    return `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column) => column.name).join("_")}_pk`;
  }
}
class ColumnBuilder {
  static [entityKind] = "ColumnBuilder";
  config;
  constructor(name, dataType, columnType) {
    this.config = {
      name,
      notNull: false,
      default: undefined,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: undefined,
      uniqueType: undefined,
      dataType,
      columnType
    };
  }
  $type() {
    return this;
  }
  notNull() {
    this.config.notNull = true;
    return this;
  }
  default(value4) {
    this.config.default = value4;
    this.config.hasDefault = true;
    return this;
  }
  $defaultFn(fn) {
    this.config.defaultFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $default = this.$defaultFn;
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
}
class PgColumn extends Column {
  table;
  static [entityKind] = "PgColumn";
  constructor(table, config8) {
    if (!config8.uniqueName) {
      config8.uniqueName = uniqueKeyName(table, [config8.name]);
    }
    super(table, config8);
    this.table = table;
  }
}
class PgUUID extends PgColumn {
  static [entityKind] = "PgUUID";
  getSQLType() {
    return "uuid";
  }
}
class TypedQueryBuilder {
  static [entityKind] = "TypedQueryBuilder";
  getSelectedFields() {
    return this._.selectedFields;
  }
}
class PgSelectQueryBuilder extends TypedQueryBuilder {
  static [entityKind] = "PgSelectQueryBuilder";
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  constructor({ table, fields, isPartialSelect, session: session2, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table,
      fields: { ...fields },
      distinct
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session2;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields
    };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  createJoin(joinType) {
    return (table, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins?.some((join2) => join2.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table, SQL)) {
          const selection = is(table, Subquery) ? table[SubqueryConfig].selection : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  where(where) {
    if (typeof where === "function") {
      where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.where = where;
    return this;
  }
  having(having) {
    if (typeof having === "function") {
      having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.orderBy = Array.isArray(orderBy) ? orderBy : [orderBy];
    } else {
      this.config.orderBy = columns;
    }
    return this;
  }
  limit(limit) {
    this.config.limit = limit;
    return this;
  }
  offset(offset) {
    this.config.offset = offset;
    return this;
  }
  for(strength, config8 = {}) {
    if (!this.config.lockingClauses) {
      this.config.lockingClauses = [];
    }
    this.config.lockingClauses.push({ strength, config: config8 });
    return this;
  }
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
}

class PgSelect extends PgSelectQueryBuilder {
  static [entityKind] = "PgSelect";
  _prepare(name) {
    const { session: session2, config: config8, dialect, joinsNotNullableMap } = this;
    if (!session2) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const fieldsList = orderSelectedFields(config8.fields);
      const query = session2.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name);
      query.joinsNotNullableMap = joinsNotNullableMap;
      return query;
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
}
applyMixins(PgSelect, [QueryPromise]);
var PgViewConfig = Symbol.for("drizzle:PgViewConfig");
var PgMaterializedViewConfig = Symbol.for("drizzle:PgMaterializedViewConfig");
class Relation {
  sourceTable;
  referencedTable;
  relationName;
  static [entityKind] = "Relation";
  referencedTableName;
  fieldName;
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
}

class Relations {
  table;
  config;
  static [entityKind] = "Relations";
  constructor(table, config8) {
    this.table = table;
    this.config = config8;
  }
}

class One extends Relation {
  config;
  isNullable;
  static [entityKind] = "One";
  constructor(sourceTable, referencedTable, config8, isNullable) {
    super(sourceTable, referencedTable, config8?.relationName);
    this.config = config8;
    this.isNullable = isNullable;
  }
  withFieldName(fieldName) {
    const relation = new One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
    relation.fieldName = fieldName;
    return relation;
  }
}

class Many extends Relation {
  config;
  static [entityKind] = "Many";
  constructor(sourceTable, referencedTable, config8) {
    super(sourceTable, referencedTable, config8?.relationName);
    this.config = config8;
  }
  withFieldName(fieldName) {
    const relation = new Many(this.sourceTable, this.referencedTable, this.config);
    relation.fieldName = fieldName;
    return relation;
  }
}
var eq = (left, right) => {
  return sql5`${left} = ${bindIfParam(right, left)}`;
};
var ne = (left, right) => {
  return sql5`${left} <> ${bindIfParam(right, left)}`;
};
var gt = (left, right) => {
  return sql5`${left} > ${bindIfParam(right, left)}`;
};
var gte = (left, right) => {
  return sql5`${left} >= ${bindIfParam(right, left)}`;
};
var lt = (left, right) => {
  return sql5`${left} < ${bindIfParam(right, left)}`;
};
var lte = (left, right) => {
  return sql5`${left} <= ${bindIfParam(right, left)}`;
};
class StringChunk {
  static [entityKind] = "StringChunk";
  value;
  constructor(value4) {
    this.value = Array.isArray(value4) ? value4 : [value4];
  }
  getSQL() {
    return new SQL([this]);
  }
}

class SQL {
  queryChunks;
  static [entityKind] = "SQL";
  decoder = noopDecoder;
  shouldInlineParams = false;
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
  }
  append(query) {
    this.queryChunks.push(...query.queryChunks);
    return this;
  }
  toQuery(config8) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query = this.buildQueryFromSourceParams(this.queryChunks, config8);
      span?.setAttributes({
        "drizzle.query.text": query.sql,
        "drizzle.query.params": JSON.stringify(query.params)
      });
      return query;
    });
  }
  buildQueryFromSourceParams(chunks, _config) {
    const config8 = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const { escapeName: escapeName2, escapeParam, prepareTyping, inlineParams, paramStartIndex } = config8;
    return mergeQueries(chunks.map((chunk) => {
      if (is(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is(chunk, Name)) {
        return { sql: escapeName2(chunk.value), params: [] };
      }
      if (chunk === undefined) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result5 = [new StringChunk("(")];
        for (const [i, p] of chunk.entries()) {
          result5.push(p);
          if (i < chunk.length - 1) {
            result5.push(new StringChunk(", "));
          }
        }
        result5.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result5, config8);
      }
      if (is(chunk, SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config8,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === undefined ? escapeName2(tableName) : escapeName2(schemaName) + "." + escapeName2(tableName),
          params: []
        };
      }
      if (is(chunk, Column)) {
        return { sql: escapeName2(chunk.table[Table.Symbol.Name]) + "." + escapeName2(chunk.name), params: [] };
      }
      if (is(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === undefined ? escapeName2(viewName) : escapeName2(schemaName) + "." + escapeName2(viewName),
          params: []
        };
      }
      if (is(chunk, Param)) {
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is(mappedValue, SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config8);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config8), params: [] };
        }
        let typings;
        if (prepareTyping !== undefined) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
      }
      if (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {
        return { sql: escapeName2(chunk.fieldAlias), params: [] };
      }
      if (is(chunk, Subquery)) {
        if (chunk[SubqueryConfig].isWith) {
          return { sql: escapeName2(chunk[SubqueryConfig].alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk[SubqueryConfig].sql,
          new StringChunk(") "),
          new Name(chunk[SubqueryConfig].alias)
        ], config8);
      }
      if (isSQLWrapper(chunk)) {
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config8);
      }
      if (is(chunk, Relation)) {
        return this.buildQueryFromSourceParams([
          chunk.sourceTable,
          new StringChunk("."),
          sql5.identifier(chunk.fieldName)
        ], config8);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config8), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === undefined) {
      return this;
    }
    return new SQL.Aliased(this, alias);
  }
  mapWith(decoder2) {
    this.decoder = typeof decoder2 === "function" ? { mapFromDriverValue: decoder2 } : decoder2;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
}

class Name {
  value;
  static [entityKind] = "Name";
  brand;
  constructor(value4) {
    this.value = value4;
  }
  getSQL() {
    return new SQL([this]);
  }
}
var noopDecoder = {
  mapFromDriverValue: (value4) => value4
};
var noopEncoder = {
  mapToDriverValue: (value4) => value4
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};

class Param {
  value;
  encoder;
  static [entityKind] = "Param";
  brand;
  constructor(value4, encoder2 = noopEncoder) {
    this.value = value4;
    this.encoder = encoder2;
  }
  getSQL() {
    return new SQL([this]);
  }
}
(function(sql6) {
  function empty() {
    return new SQL([]);
  }
  sql6.empty = empty;
  function fromList(list) {
    return new SQL(list);
  }
  sql6.fromList = fromList;
  function raw(str) {
    return new SQL([new StringChunk(str)]);
  }
  sql6.raw = raw;
  function join2(chunks, separator) {
    const result5 = [];
    for (const [i, chunk] of chunks.entries()) {
      if (i > 0 && separator !== undefined) {
        result5.push(separator);
      }
      result5.push(chunk);
    }
    return new SQL(result5);
  }
  sql6.join = join2;
  function identifier(value4) {
    return new Name(value4);
  }
  sql6.identifier = identifier;
  function placeholder(name) {
    return new Placeholder(name);
  }
  sql6.placeholder = placeholder;
  function param(value4, encoder2) {
    return new Param(value4, encoder2);
  }
  sql6.param = param;
})(sql5 || (sql5 = {}));
(function(SQL2) {

  class Aliased {
    sql;
    fieldAlias;
    static [entityKind] = "SQL.Aliased";
    isSelectionField = false;
    constructor(sql6, fieldAlias) {
      this.sql = sql6;
      this.fieldAlias = fieldAlias;
    }
    getSQL() {
      return this.sql;
    }
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));

class Placeholder {
  name;
  static [entityKind] = "Placeholder";
  constructor(name) {
    this.name = name;
  }
  getSQL() {
    return new SQL([this]);
  }
}
Column.prototype.getSQL = function() {
  return new SQL([this]);
};

class ColumnAliasProxyHandler {
  table;
  static [entityKind] = "ColumnAliasProxyHandler";
  constructor(table) {
    this.table = table;
  }
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
}

class TableAliasProxyHandler {
  alias;
  replaceOriginalName;
  static [entityKind] = "TableAliasProxyHandler";
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(columns[key], new ColumnAliasProxyHandler(new Proxy(target, this)));
      });
      return proxiedColumns;
    }
    const value4 = target[prop];
    if (is(value4, Column)) {
      return new Proxy(value4, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value4;
  }
}

// node_modules/@libsql/hrana-client/
class ConsoleLogWriter {
  static [entityKind] = "ConsoleLogWriter";
  write(message) {
    console.log(message);
  }
}

class DefaultLogger {
  static [entityKind] = "DefaultLogger";
  writer;
  constructor(config8) {
    this.writer = config8?.writer ?? new ConsoleLogWriter;
  }
  logQuery(query, params) {
    const stringifiedParams = params.map((p) => {
      try {
        return JSON.stringify(p);
      } catch {
        return String(p);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query}${paramsStr}`);
  }
}

class NoopLogger {
  static [entityKind] = "NoopLogger";
  logQuery() {
  }
}

// node_modules/@libsql/hrana-client/lib-esm/enc
var sqliteTableBase = function(name2, columns, extraConfig, schema, baseName = name2) {
  const rawTable = new SQLiteTable(name2, schema, baseName);
  const builtColumns = Object.fromEntries(Object.entries(columns).map(([name3, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    const column = colBuilder.build(rawTable);
    rawTable[InlineForeignKeys2].push(...colBuilder.buildForeignKeys(column, rawTable));
    return [name3, column];
  }));
  const table = Object.assign(rawTable, builtColumns);
  table[Table.Symbol.Columns] = builtColumns;
  if (extraConfig) {
    table[SQLiteTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table;
};
var uniqueKeyName2 = function(table, columns) {
  return `${table[SQLiteTable.Symbol.Name]}_${columns.join("_")}_unique`;
};
var InlineForeignKeys2 = Symbol.for("drizzle:SQLiteInlineForeignKeys");

class SQLiteTable extends Table {
  static [entityKind] = "SQLiteTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys: InlineForeignKeys2
  });
  [Table.Symbol.Columns];
  [InlineForeignKeys2] = [];
  [Table.Symbol.ExtraConfigBuilder] = undefined;
}
var sqliteTable = (name2, columns, extraConfig) => {
  return sqliteTableBase(name2, columns, extraConfig);
};

class SQLiteDelete extends QueryPromise {
  table;
  session;
  dialect;
  static [entityKind] = "SQLiteDelete";
  config;
  constructor(table, session2, dialect) {
    super();
    this.table = table;
    this.session = session2;
    this.dialect = dialect;
    this.config = { table };
  }
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.table[SQLiteTable.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  prepare(isOneTimeQuery) {
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](this.dialect.sqlToQuery(this.getSQL()), this.config.returning, this.config.returning ? "all" : "run");
  }
  run = (placeholderValues) => {
    return this.prepare(true).run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this.prepare(true).all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this.prepare(true).get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this.prepare(true).values(placeholderValues);
  };
  async execute(placeholderValues) {
    return this.prepare(true).execute(placeholderValues);
  }
}

class SQLiteInsertBuilder {
  table;
  session;
  dialect;
  static [entityKind] = "SQLiteInsertBuilder";
  constructor(table, session2, dialect) {
    this.table = table;
    this.session = session2;
    this.dialect = dialect;
  }
  values(values) {
    values = Array.isArray(values) ? values : [values];
    if (values.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values.map((entry) => {
      const result5 = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result5[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result5;
    });
    return new SQLiteInsert(this.table, mappedValues, this.session, this.dialect);
  }
}

class SQLiteInsert extends QueryPromise {
  session;
  dialect;
  static [entityKind] = "SQLiteInsert";
  config;
  constructor(table, values, session2, dialect) {
    super();
    this.session = session2;
    this.dialect = dialect;
    this.config = { table, values };
  }
  returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  onConflictDoNothing(config8 = {}) {
    if (config8.target === undefined) {
      this.config.onConflict = sql5`do nothing`;
    } else {
      const targetSql = Array.isArray(config8.target) ? sql5`${config8.target}` : sql5`${[config8.target]}`;
      const whereSql = config8.where ? sql5` where ${config8.where}` : sql5``;
      this.config.onConflict = sql5`${targetSql} do nothing${whereSql}`;
    }
    return this;
  }
  onConflictDoUpdate(config8) {
    const targetSql = Array.isArray(config8.target) ? sql5`${config8.target}` : sql5`${[config8.target]}`;
    const whereSql = config8.where ? sql5` where ${config8.where}` : sql5``;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config8.set));
    this.config.onConflict = sql5`${targetSql} do update set ${setSql}${whereSql}`;
    return this;
  }
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  prepare(isOneTimeQuery) {
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](this.dialect.sqlToQuery(this.getSQL()), this.config.returning, this.config.returning ? "all" : "run");
  }
  run = (placeholderValues) => {
    return this.prepare(true).run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this.prepare(true).all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this.prepare(true).get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this.prepare(true).values(placeholderValues);
  };
  async execute() {
    return this.config.returning ? this.all() : this.run();
  }
}

class ForeignKeyBuilder {
  static [entityKind] = "SQLiteForeignKeyBuilder";
  reference;
  _onUpdate;
  _onDelete;
  constructor(config8, actions) {
    this.reference = () => {
      const { columns, foreignColumns } = config8();
      return { columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action;
    return this;
  }
  build(table) {
    return new ForeignKey(table, this);
  }
}

class ForeignKey {
  table;
  static [entityKind] = "SQLiteForeignKey";
  reference;
  onUpdate;
  onDelete;
  constructor(table, builder) {
    this.table = table;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  getName() {
    const { columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column) => column.name);
    const foreignColumnNames = foreignColumns.map((column) => column.name);
    const chunks = [
      this.table[SQLiteTable.Symbol.Name],
      ...columnNames,
      foreignColumns[0].table[SQLiteTable.Symbol.Name],
      ...foreignColumnNames
    ];
    return `${chunks.join("_")}_fk`;
  }
}
class SQLiteColumnBuilder extends ColumnBuilder {
  static [entityKind] = "SQLiteColumnBuilder";
  foreignKeyConfigs = [];
  references(ref, actions = {}) {
    this.foreignKeyConfigs.push({ ref, actions });
    return this;
  }
  unique(name2) {
    this.config.isUnique = true;
    this.config.uniqueName = name2;
    return this;
  }
  buildForeignKeys(column, table) {
    return this.foreignKeyConfigs.map(({ ref, actions }) => {
      return ((ref2, actions2) => {
        const builder = new ForeignKeyBuilder(() => {
          const foreignColumn = ref2();
          return { columns: [column], foreignColumns: [foreignColumn] };
        });
        if (actions2.onUpdate) {
          builder.onUpdate(actions2.onUpdate);
        }
        if (actions2.onDelete) {
          builder.onDelete(actions2.onDelete);
        }
        return builder.build(table);
      })(ref, actions);
    });
  }
}

class SQLiteColumn extends Column {
  table;
  static [entityKind] = "SQLiteColumn";
  constructor(table, config8) {
    if (!config8.uniqueName) {
      config8.uniqueName = uniqueKeyName2(table, [config8.name]);
    }
    super(table, config8);
    this.table = table;
  }
}
class SQLiteViewBase extends View {
  static [entityKind] = "SQLiteViewBase";
}
var SQLiteViewConfig = Symbol.for("drizzle:SQLiteViewConfig");
class SQLiteDialect {
  static [entityKind] = "SQLiteDialect";
  escapeName(name2) {
    return `"${name2}"`;
  }
  escapeParam(_num) {
    return "?";
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildDeleteQuery({ table, where, returning }) {
    const returningSql = returning ? sql5` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql5` where ${where}` : undefined;
    return sql5`delete from ${table}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table, set) {
    const setEntries = Object.entries(set);
    const setSize = setEntries.length;
    return sql5.join(setEntries.flatMap(([colName, value4], i) => {
      const col = table[Table.Symbol.Columns][colName];
      const res = sql5`${sql5.identifier(col.name)} = ${value4}`;
      if (i < setSize - 1) {
        return [res, sql5.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table, set, where, returning }) {
    const setSql = this.buildUpdateSet(table, set);
    const returningSql = returning ? sql5` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql5` where ${where}` : undefined;
    return sql5`update ${table} set ${setSql}${whereSql}${returningSql}`;
  }
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql5.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(new SQL(query.queryChunks.map((c) => {
            if (is(c, Column)) {
              return sql5.identifier(c.name);
            }
            return c;
          })));
        } else {
          chunk.push(query);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql5` as ${sql5.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        const tableName = field.table[Table.Symbol.Name];
        const columnName = field.name;
        if (isSingleTable) {
          chunk.push(sql5.identifier(columnName));
        } else {
          chunk.push(sql5`${sql5.identifier(tableName)}.${sql5.identifier(columnName)}`);
        }
      }
      if (i < columnsLen - 1) {
        chunk.push(sql5`, `);
      }
      return chunk;
    });
    return sql5.join(chunks);
  }
  buildSelectQuery({ withList, fields, fieldsFlat, where, having, table, joins, orderBy, groupBy, limit, offset, distinct }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f of fieldsList) {
      if (is(f.field, Column) && getTableName(f.field.table) !== (is(table, Subquery) ? table[SubqueryConfig].alias : is(table, SQLiteViewBase) ? table[ViewBaseConfig].name : is(table, SQL) ? undefined : getTableName(table)) && !((table2) => joins?.some(({ alias }) => alias === (table2[Table.Symbol.IsAlias] ? getTableName(table2) : table2[Table.Symbol.BaseName])))(f.field.table)) {
        const tableName = getTableName(f.field.table);
        throw new Error(`Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    let withSql;
    if (withList?.length) {
      const withSqlChunks = [sql5`with `];
      for (const [i, w] of withList.entries()) {
        withSqlChunks.push(sql5`${sql5.identifier(w[SubqueryConfig].alias)} as (${w[SubqueryConfig].sql})`);
        if (i < withList.length - 1) {
          withSqlChunks.push(sql5`, `);
        }
      }
      withSqlChunks.push(sql5` `);
      withSql = sql5.join(withSqlChunks);
    }
    const distinctSql = distinct ? sql5` distinct` : undefined;
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = (() => {
      if (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {
        return sql5`${sql5.identifier(table[Table.Symbol.OriginalName])} ${sql5.identifier(table[Table.Symbol.Name])}`;
      }
      return table;
    })();
    const joinsArray = [];
    if (joins) {
      for (const [index, joinMeta] of joins.entries()) {
        if (index === 0) {
          joinsArray.push(sql5` `);
        }
        const table2 = joinMeta.table;
        if (is(table2, SQLiteTable)) {
          const tableName = table2[SQLiteTable.Symbol.Name];
          const tableSchema = table2[SQLiteTable.Symbol.Schema];
          const origTableName = table2[SQLiteTable.Symbol.OriginalName];
          const alias = tableName === origTableName ? undefined : joinMeta.alias;
          joinsArray.push(sql5`${sql5.raw(joinMeta.joinType)} join ${tableSchema ? sql5`${sql5.identifier(tableSchema)}.` : undefined}${sql5.identifier(origTableName)}${alias && sql5` ${sql5.identifier(alias)}`} on ${joinMeta.on}`);
        } else {
          joinsArray.push(sql5`${sql5.raw(joinMeta.joinType)} join ${table2} on ${joinMeta.on}`);
        }
        if (index < joins.length - 1) {
          joinsArray.push(sql5` `);
        }
      }
    }
    const joinsSql = sql5.join(joinsArray);
    const whereSql = where ? sql5` where ${where}` : undefined;
    const havingSql = having ? sql5` having ${having}` : undefined;
    const orderByList = [];
    if (orderBy) {
      for (const [index, orderByValue] of orderBy.entries()) {
        orderByList.push(orderByValue);
        if (index < orderBy.length - 1) {
          orderByList.push(sql5`, `);
        }
      }
    }
    const groupByList = [];
    if (groupBy) {
      for (const [index, groupByValue] of groupBy.entries()) {
        groupByList.push(groupByValue);
        if (index < groupBy.length - 1) {
          groupByList.push(sql5`, `);
        }
      }
    }
    const groupBySql = groupByList.length > 0 ? sql5` group by ${sql5.join(groupByList)}` : undefined;
    const orderBySql = orderByList.length > 0 ? sql5` order by ${sql5.join(orderByList)}` : undefined;
    const limitSql = limit ? sql5` limit ${limit}` : undefined;
    const offsetSql = offset ? sql5` offset ${offset}` : undefined;
    return sql5`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table, values, onConflict, returning }) {
    const valuesSqlList = [];
    const columns = table[Table.Symbol.Columns];
    const colEntries = Object.entries(columns);
    const insertOrder = colEntries.map(([, column]) => sql5.identifier(column.name));
    for (const [valueIndex, value4] of values.entries()) {
      const valueList = [];
      for (const [fieldName, col] of colEntries) {
        const colValue = value4[fieldName];
        if (colValue === undefined || is(colValue, Param) && colValue.value === undefined) {
          let defaultValue;
          if (col.default !== null && col.default !== undefined) {
            defaultValue = is(col.default, SQL) ? col.default : sql5.param(col.default, col);
          } else if (col.defaultFn !== undefined) {
            const defaultFnResult = col.defaultFn();
            defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql5.param(defaultFnResult, col);
          } else {
            defaultValue = sql5`null`;
          }
          valueList.push(defaultValue);
        } else {
          valueList.push(colValue);
        }
      }
      valuesSqlList.push(valueList);
      if (valueIndex < values.length - 1) {
        valuesSqlList.push(sql5`, `);
      }
    }
    const valuesSql = sql5.join(valuesSqlList);
    const returningSql = returning ? sql5` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const onConflictSql = onConflict ? sql5` on conflict ${onConflict}` : undefined;
    return sql5`insert into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
  }
  sqlToQuery(sql6) {
    return sql6.toQuery({
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString
    });
  }
  buildRelationalQuery({ fullSchema, schema, tableNamesMap, table, tableConfig, queryConfig: config8, tableAlias, nestedQueryRelation, joinOn }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config8 === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value4]) => ({
        dbKey: value4.name,
        tsKey: key,
        field: aliasedTableColumn(value4, tableAlias),
        relationTableTsKey: undefined,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value4]) => [key, aliasedTableColumn(value4, tableAlias)]));
      if (config8.where) {
        const whereSql = typeof config8.where === "function" ? config8.where(aliasedColumns, getOperators()) : config8.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config8.columns) {
        let isIncludeMode = false;
        for (const [field, value4] of Object.entries(config8.columns)) {
          if (value4 === undefined) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value4 === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c) => config8.columns?.[c] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column });
      }
      let selectedRelations = [];
      if (config8.with) {
        selectedRelations = Object.entries(config8.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config8.extras) {
        extras = typeof config8.extras === "function" ? config8.extras(aliasedColumns, { sql: sql5 }) : config8.extras;
        for (const [tsKey, value4] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value4, tableAlias)
          });
        }
      }
      for (const { tsKey, value: value4 } of fieldsSelection) {
        selection.push({
          dbKey: is(value4, SQL.Aliased) ? value4.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value4, Column) ? aliasedTableColumn(value4, tableAlias) : value4,
          relationTableTsKey: undefined,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config8.orderBy === "function" ? config8.orderBy(aliasedColumns, getOrderByOperators()) : config8.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config8.limit;
      offset = config8.offset;
      for (const { tsKey: selectedRelationTsKey, queryConfig: selectedRelationConfigValue, relation } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
        const relationTableName = relation.referencedTable[Table.Symbol.Name];
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(...normalizedRelation.fields.map((field2, i) => eq(aliasedTableColumn(normalizedRelation.references[i], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
        const builtRelation = this.buildRelationalQuery({
          fullSchema,
          schema,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql5`(${builtRelation.sql})`.as(selectedRelationTsKey);
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`);
    }
    let result5;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql5`json_array(${sql5.join(selection.map(({ field: field2 }) => is(field2, SQLiteColumn) ? sql5.identifier(field2.name) : is(field2, SQL.Aliased) ? field2.sql : field2), sql5`, `)})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql5`coalesce(json_group_array(${field}), json_array())`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
      if (needsSubquery) {
        result5 = this.buildSelectQuery({
          table: aliasedTable(table, tableAlias),
          fields: {},
          fieldsFlat: [
            {
              path: [],
              field: sql5.raw("*")
            }
          ],
          where,
          limit,
          offset,
          orderBy
        });
        where = undefined;
        limit = undefined;
        offset = undefined;
        orderBy = undefined;
      } else {
        result5 = aliasedTable(table, tableAlias);
      }
      result5 = this.buildSelectQuery({
        table: is(result5, SQLiteTable) ? result5 : new Subquery(result5, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy
      });
    } else {
      result5 = this.buildSelectQuery({
        table: aliasedTable(table, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result5,
      selection
    };
  }
}

class SQLiteSyncDialect extends SQLiteDialect {
  static [entityKind] = "SQLiteSyncDialect";
  migrate(migrations, session2) {
    const migrationTableCreate = sql5`
			CREATE TABLE IF NOT EXISTS "__drizzle_migrations" (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
    session2.run(migrationTableCreate);
    const dbMigrations = session2.values(sql5`SELECT id, hash, created_at FROM "__drizzle_migrations" ORDER BY created_at DESC LIMIT 1`);
    const lastDbMigration = dbMigrations[0] ?? undefined;
    session2.run(sql5`BEGIN`);
    try {
      for (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
          for (const stmt3 of migration.sql) {
            session2.run(sql5.raw(stmt3));
          }
          session2.run(sql5`INSERT INTO "__drizzle_migrations" ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`);
        }
      }
      session2.run(sql5`COMMIT`);
    } catch (e2) {
      session2.run(sql5`ROLLBACK`);
      throw e2;
    }
  }
}

class SQLiteAsyncDialect extends SQLiteDialect {
  static [entityKind] = "SQLiteAsyncDialect";
  async migrate(migrations, session2) {
    const migrationTableCreate = sql5`
			CREATE TABLE IF NOT EXISTS "__drizzle_migrations" (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at numeric
			)
		`;
    await session2.run(migrationTableCreate);
    const dbMigrations = await session2.values(sql5`SELECT id, hash, created_at FROM "__drizzle_migrations" ORDER BY created_at DESC LIMIT 1`);
    const lastDbMigration = dbMigrations[0] ?? undefined;
    await session2.transaction(async (tx) => {
      for (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration[2]) < migration.folderMillis) {
          for (const stmt3 of migration.sql) {
            await tx.run(sql5.raw(stmt3));
          }
          await tx.run(sql5`INSERT INTO "__drizzle_migrations" ("hash", "created_at") VALUES(${migration.hash}, ${migration.folderMillis})`);
        }
      }
    });
  }
}

class SQLiteSelectBuilder {
  static [entityKind] = "SQLiteSelectBuilder";
  fields;
  session;
  dialect;
  withList;
  distinct;
  constructor(config8) {
    this.fields = config8.fields;
    this.session = config8.session;
    this.dialect = config8.dialect;
    this.withList = config8.withList;
    this.distinct = config8.distinct;
  }
  from(source) {
    const isPartialSelect = !!this.fields;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(source, Subquery)) {
      fields = Object.fromEntries(Object.keys(source[SubqueryConfig].selection).map((key) => [key, source[key]]));
    } else if (is(source, SQLiteViewBase)) {
      fields = source[ViewBaseConfig].selectedFields;
    } else if (is(source, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(source);
    }
    return new SQLiteSelect({
      table: source,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    });
  }
}

class SQLiteSelectQueryBuilder extends TypedQueryBuilder {
  static [entityKind] = "SQLiteSelectQueryBuilder";
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  constructor({ table, fields, isPartialSelect, session: session2, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table,
      fields: { ...fields },
      distinct
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session2;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields
    };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  createJoin(joinType) {
    return (table, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins?.some((join2) => join2.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table, SQL)) {
          const selection = is(table, Subquery) ? table[SubqueryConfig].selection : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  where(where) {
    if (typeof where === "function") {
      where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.where = where;
    return this;
  }
  having(having) {
    if (typeof having === "function") {
      having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.orderBy = Array.isArray(orderBy) ? orderBy : [orderBy];
    } else {
      this.config.orderBy = columns;
    }
    return this;
  }
  limit(limit) {
    this.config.limit = limit;
    return this;
  }
  offset(offset) {
    this.config.offset = offset;
    return this;
  }
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  getSelectedFields() {
    return new Proxy(this.config.fields, new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
}

class SQLiteSelect extends SQLiteSelectQueryBuilder {
  static [entityKind] = "SQLiteSelect";
  prepare(isOneTimeQuery) {
    if (!this.session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    const fieldsList = orderSelectedFields(this.config.fields);
    const query = this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](this.dialect.sqlToQuery(this.getSQL()), fieldsList, "all");
    query.joinsNotNullableMap = this.joinsNotNullableMap;
    return query;
  }
  run = (placeholderValues) => {
    return this.prepare(true).run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this.prepare(true).all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this.prepare(true).get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this.prepare(true).values(placeholderValues);
  };
  async execute() {
    return this.all();
  }
}
applyMixins(SQLiteSelect, [QueryPromise]);

class QueryBuilder {
  static [entityKind] = "SQLiteQueryBuilder";
  dialect;
  $with(alias) {
    const queryBuilder = this;
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(queryBuilder);
        }
        return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
  }
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        withList: queries,
        distinct: true
      });
    }
    return { select, selectDistinct };
  }
  select(fields) {
    return new SQLiteSelectBuilder({ fields: fields ?? undefined, session: undefined, dialect: this.getDialect() });
  }
  selectDistinct(fields) {
    return new SQLiteSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  getDialect() {
    if (!this.dialect) {
      this.dialect = new SQLiteSyncDialect;
    }
    return this.dialect;
  }
}

class SQLiteUpdateBuilder {
  table;
  session;
  dialect;
  static [entityKind] = "SQLiteUpdateBuilder";
  constructor(table, session2, dialect) {
    this.table = table;
    this.session = session2;
    this.dialect = dialect;
  }
  set(values) {
    return new SQLiteUpdate(this.table, mapUpdateSet(this.table, values), this.session, this.dialect);
  }
}

class SQLiteUpdate extends QueryPromise {
  session;
  dialect;
  static [entityKind] = "SQLiteUpdate";
  config;
  constructor(table, set, session2, dialect) {
    super();
    this.session = session2;
    this.dialect = dialect;
    this.config = { set, table };
  }
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[SQLiteTable.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  prepare(isOneTimeQuery) {
    return this.session[isOneTimeQuery ? "prepareOneTimeQuery" : "prepareQuery"](this.dialect.sqlToQuery(this.getSQL()), this.config.returning, this.config.returning ? "all" : "run");
  }
  run = (placeholderValues) => {
    return this.prepare(true).run(placeholderValues);
  };
  all = (placeholderValues) => {
    return this.prepare(true).all(placeholderValues);
  };
  get = (placeholderValues) => {
    return this.prepare(true).get(placeholderValues);
  };
  values = (placeholderValues) => {
    return this.prepare(true).values(placeholderValues);
  };
  async execute() {
    return this.config.returning ? this.all() : this.run();
  }
}

class RelationalQueryBuilder {
  mode;
  fullSchema;
  schema;
  tableNamesMap;
  table;
  tableConfig;
  dialect;
  session;
  static [entityKind] = "SQLiteAsyncRelationalQueryBuilder";
  constructor(mode, fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session2) {
    this.mode = mode;
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session2;
  }
  findMany(config8) {
    return this.mode === "sync" ? new SQLiteSyncRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config8 ? config8 : {}, "many") : new SQLiteRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config8 ? config8 : {}, "many");
  }
  findFirst(config8) {
    return this.mode === "sync" ? new SQLiteSyncRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config8 ? { ...config8, limit: 1 } : { limit: 1 }, "first") : new SQLiteRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config8 ? { ...config8, limit: 1 } : { limit: 1 }, "first");
  }
}

class SQLiteRelationalQuery extends QueryPromise {
  fullSchema;
  schema;
  tableNamesMap;
  table;
  tableConfig;
  dialect;
  session;
  config;
  static [entityKind] = "SQLiteAsyncRelationalQuery";
  mode;
  constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session2, config8, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema;
    this.tableNamesMap = tableNamesMap;
    this.table = table;
    this.tableConfig = tableConfig;
    this.dialect = dialect;
    this.session = session2;
    this.config = config8;
    this.mode = mode;
  }
  getSQL() {
    return this.dialect.buildRelationalQuery({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    }).sql;
  }
  prepare() {
    const { query, builtQuery } = this._toSQL();
    return this.session.prepareQuery(builtQuery, undefined, this.mode === "first" ? "get" : "all", (rawRows, mapColumnValue) => {
      const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection, mapColumnValue));
      if (this.mode === "first") {
        return rows[0];
      }
      return rows;
    });
  }
  _toSQL() {
    const query = this.dialect.buildRelationalQuery({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
    const builtQuery = this.dialect.sqlToQuery(query.sql);
    return { query, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  executeRaw() {
    if (this.mode === "first") {
      return this.prepare().get();
    }
    return this.prepare().all();
  }
  async execute() {
    return this.executeRaw();
  }
}

class SQLiteSyncRelationalQuery extends SQLiteRelationalQuery {
  static [entityKind] = "SQLiteSyncRelationalQuery";
  sync() {
    return this.executeRaw();
  }
}

class SQLiteRaw extends QueryPromise {
  cb;
  getSQLCb;
  static [entityKind] = "SQLiteRaw";
  config;
  constructor(cb, getSQLCb, action) {
    super();
    this.cb = cb;
    this.getSQLCb = getSQLCb;
    this.config = { action };
  }
  getSQL() {
    return this.getSQLCb();
  }
  async execute() {
    return this.cb();
  }
}

class BaseSQLiteDatabase {
  resultKind;
  dialect;
  session;
  static [entityKind] = "BaseSQLiteDatabase";
  query;
  constructor(resultKind, dialect, session2, schema) {
    this.resultKind = resultKind;
    this.dialect = dialect;
    this.session = session2;
    this._ = schema ? { schema: schema.schema, tableNamesMap: schema.tableNamesMap } : { schema: undefined, tableNamesMap: {} };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder(resultKind, schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns, dialect, session2);
      }
    }
  }
  $with(alias) {
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder);
        }
        return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
  }
  with(...queries) {
    const self2 = this;
    function select(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: true
      });
    }
    return { select, selectDistinct };
  }
  select(fields) {
    return new SQLiteSelectBuilder({ fields: fields ?? undefined, session: this.session, dialect: this.dialect });
  }
  selectDistinct(fields) {
    return new SQLiteSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  update(table) {
    return new SQLiteUpdateBuilder(table, this.session, this.dialect);
  }
  insert(into) {
    return new SQLiteInsertBuilder(into, this.session, this.dialect);
  }
  delete(from) {
    return new SQLiteDelete(from, this.session, this.dialect);
  }
  run(query) {
    const sql6 = query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(async () => this.session.run(sql6), () => sql6, "run");
    }
    return this.session.run(sql6);
  }
  all(query) {
    const sql6 = query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(async () => this.session.all(sql6), () => sql6, "all");
    }
    return this.session.all(sql6);
  }
  get(query) {
    const sql6 = query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(async () => this.session.get(sql6), () => sql6, "get");
    }
    return this.session.get(sql6);
  }
  values(query) {
    const sql6 = query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(async () => this.session.values(sql6), () => sql6, "values");
    }
    return this.session.values(sql6);
  }
  transaction(transaction, config8) {
    return this.session.transaction(transaction, config8);
  }
}

class ExecuteResultSync extends QueryPromise {
  resultCb;
  static [entityKind] = "ExecuteResultSync";
  constructor(resultCb) {
    super();
    this.resultCb = resultCb;
  }
  async execute() {
    return this.resultCb();
  }
  sync() {
    return this.resultCb();
  }
}
var PreparedQuery$1 = class PreparedQuery {
  mode;
  executeMethod;
  static [entityKind] = "PreparedQuery";
  joinsNotNullableMap;
  constructor(mode, executeMethod) {
    this.mode = mode;
    this.executeMethod = executeMethod;
  }
  execute(placeholderValues) {
    if (this.mode === "async") {
      return this[this.executeMethod](placeholderValues);
    }
    return new ExecuteResultSync(() => this[this.executeMethod](placeholderValues));
  }
};

class SQLiteSession {
  dialect;
  static [entityKind] = "SQLiteSession";
  constructor(dialect) {
    this.dialect = dialect;
  }
  prepareOneTimeQuery(query, fields, executeMethod) {
    return this.prepareQuery(query, fields, executeMethod);
  }
  run(query) {
    const staticQuery = this.dialect.sqlToQuery(query);
    try {
      return this.prepareOneTimeQuery(staticQuery, undefined, "run").run();
    } catch (err) {
      throw DrizzleError.wrap(err, `Failed to run the query '${staticQuery.sql}'`);
    }
  }
  all(query) {
    return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined, "run").all();
  }
  get(query) {
    return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined, "run").get();
  }
  values(query) {
    return this.prepareOneTimeQuery(this.dialect.sqlToQuery(query), undefined, "run").values();
  }
}

class SQLiteTransaction extends BaseSQLiteDatabase {
  schema;
  nestedIndex;
  static [entityKind] = "SQLiteTransaction";
  constructor(resultType, dialect, session2, schema, nestedIndex = 0) {
    super(resultType, dialect, session2, schema);
    this.schema = schema;
    this.nestedIndex = nestedIndex;
  }
  rollback() {
    throw new TransactionRollbackError;
  }
}

// node_modules/@libsql/hrana-client/lib-esm
var normalizeRow = function(obj) {
  return Object.keys(obj).reduce((acc, key) => {
    if (Object.prototype.propertyIsEnumerable.call(obj, key)) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
};
var normalizeFieldValue = function(value4) {
  if (value4 instanceof ArrayBuffer) {
    if (typeof Buffer !== "undefined") {
      if (!(value4 instanceof Buffer)) {
        return Buffer.from(value4);
      }
      return value4;
    }
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(value4);
    }
    throw new Error("TextDecoder is not available. Please provide either Buffer or TextDecoder polyfill.");
  }
  return value4;
};
var drizzle = function(client7, config8 = {}) {
  const dialect = new SQLiteAsyncDialect;
  let logger2;
  if (config8.logger === true) {
    logger2 = new DefaultLogger;
  } else if (config8.logger !== false) {
    logger2 = config8.logger;
  }
  let schema;
  if (config8.schema) {
    const tablesConfig = extractTablesRelationalConfig(config8.schema, createTableRelationsHelpers);
    schema = {
      fullSchema: config8.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session2 = new LibSQLSession(client7, dialect, schema, { logger: logger2 }, undefined);
  return new LibSQLDatabase("async", dialect, session2, schema);
};

class LibSQLSession extends SQLiteSession {
  client;
  schema;
  options;
  tx;
  static [entityKind] = "LibSQLSession";
  logger;
  constructor(client7, dialect, schema, options, tx) {
    super(dialect);
    this.client = client7;
    this.schema = schema;
    this.options = options;
    this.tx = tx;
    this.logger = options.logger ?? new NoopLogger;
  }
  prepareQuery(query, fields, executeMethod, customResultMapper) {
    return new PreparedQuery2(this.client, query.sql, query.params, this.logger, fields, this.tx, executeMethod, customResultMapper);
  }
  batch(queries) {
    const queryToType = [];
    const builtQueries = queries.map((query) => {
      const builtQuery = this.dialect.sqlToQuery(query.getSQL());
      if (is(query, SQLiteSelect)) {
        const prepared = query.prepare();
        prepared.fields === undefined ? queryToType.push({ mode: "all" }) : queryToType.push({
          mode: "all_mapped",
          config: { fields: prepared.fields, joinsNotNullableMap: prepared.joinsNotNullableMap }
        });
      } else if (is(query, SQLiteInsert) || is(query, SQLiteUpdate) || is(query, SQLiteDelete)) {
        queryToType.push(query.config.returning ? {
          mode: "all_mapped",
          config: { fields: query.config.returning }
        } : { mode: "raw" });
      } else if (is(query, SQLiteRaw)) {
        queryToType.push(query.config.action === "run" ? { mode: "raw" } : { mode: query.config.action });
      } else if (is(query, SQLiteRelationalQuery)) {
        const preparedRqb = query.prepare();
        queryToType.push({ mode: "rqb", mapper: preparedRqb.customResultMapper });
      }
      return { sql: builtQuery.sql, args: builtQuery.params };
    });
    const res = this.client.batch(builtQueries).then((stmt3) => stmt3.map(({ rows }, index) => {
      const action = queryToType[index];
      if (action.mode === "all") {
        return rows.map((row) => normalizeRow(row));
      }
      if (action.mode === "all_mapped") {
        return rows.map((row) => {
          return mapResultRow(action.config.fields, Array.prototype.slice.call(row).map((v) => normalizeFieldValue(v)), action.config.joinsNotNullableMap);
        });
      }
      if (action.mode === "get") {
        return normalizeRow(rows[0]);
      }
      if (action.mode === "values") {
        return rows.map((row) => Object.values(row));
      }
      if (action.mode === "raw") {
        return stmt3[index];
      }
      return action.mapper(rows, normalizeFieldValue);
    }));
    return res;
  }
  async transaction(transaction, _config) {
    const libsqlTx = await this.client.transaction();
    const session2 = new LibSQLSession(this.client, this.dialect, this.schema, this.options, libsqlTx);
    const tx = new LibSQLTransaction("async", this.dialect, session2, this.schema);
    try {
      const result5 = await transaction(tx);
      await libsqlTx.commit();
      return result5;
    } catch (err) {
      await libsqlTx.rollback();
      throw err;
    }
  }
}

class LibSQLTransaction extends SQLiteTransaction {
  static [entityKind] = "LibSQLTransaction";
  async transaction(transaction) {
    const savepointName = `sp${this.nestedIndex}`;
    const tx = new LibSQLTransaction("async", this.dialect, this.session, this.schema, this.nestedIndex + 1);
    await this.session.run(sql5.raw(`savepoint ${savepointName}`));
    try {
      const result5 = await transaction(tx);
      await this.session.run(sql5.raw(`release savepoint ${savepointName}`));
      return result5;
    } catch (err) {
      await this.session.run(sql5.raw(`rollback to savepoint ${savepointName}`));
      throw err;
    }
  }
}

class PreparedQuery2 extends PreparedQuery$1 {
  client;
  queryString;
  params;
  logger;
  tx;
  static [entityKind] = "LibSQLPreparedQuery";
  customResultMapper;
  fields;
  constructor(client7, queryString, params, logger2, fields, tx, executeMethod, customResultMapper) {
    super("async", executeMethod);
    this.client = client7;
    this.queryString = queryString;
    this.params = params;
    this.logger = logger2;
    this.tx = tx;
    this.customResultMapper = customResultMapper;
    this.fields = fields;
  }
  run(placeholderValues) {
    const params = fillPlaceholders(this.params, placeholderValues ?? {});
    this.logger.logQuery(this.queryString, params);
    const stmt3 = { sql: this.queryString, args: params };
    return this.tx ? this.tx.execute(stmt3) : this.client.execute(stmt3);
  }
  async all(placeholderValues) {
    const { fields, joinsNotNullableMap, logger: logger2, queryString, tx, client: client7, customResultMapper } = this;
    if (!fields && !customResultMapper) {
      const params = fillPlaceholders(this.params, placeholderValues ?? {});
      logger2.logQuery(queryString, params);
      const stmt3 = { sql: queryString, args: params };
      return (tx ? tx.execute(stmt3) : client7.execute(stmt3)).then(({ rows: rows2 }) => rows2.map((row) => normalizeRow(row)));
    }
    const rows = await this.values(placeholderValues);
    if (customResultMapper) {
      return customResultMapper(rows, normalizeFieldValue);
    }
    return rows.map((row) => {
      return mapResultRow(fields, Array.prototype.slice.call(row).map((v) => normalizeFieldValue(v)), joinsNotNullableMap);
    });
  }
  async get(placeholderValues) {
    const { fields, joinsNotNullableMap, logger: logger2, queryString, tx, client: client7, customResultMapper } = this;
    if (!fields && !customResultMapper) {
      const params = fillPlaceholders(this.params, placeholderValues ?? {});
      logger2.logQuery(queryString, params);
      const stmt3 = { sql: queryString, args: params };
      return (tx ? tx.execute(stmt3) : client7.execute(stmt3)).then(({ rows: rows2 }) => normalizeRow(rows2[0]));
    }
    const rows = await this.values(placeholderValues);
    if (!rows[0]) {
      return;
    }
    if (customResultMapper) {
      return customResultMapper(rows, normalizeFieldValue);
    }
    return mapResultRow(fields, Array.prototype.slice.call(rows[0]).map((v) => normalizeFieldValue(v)), joinsNotNullableMap);
  }
  values(placeholderValues) {
    const params = fillPlaceholders(this.params, placeholderValues ?? {});
    this.logger.logQuery(this.queryString, params);
    const stmt3 = { sql: this.queryString, args: params };
    return (this.tx ? this.tx.execute(stmt3) : this.client.execute(stmt3)).then(({ rows }) => rows);
  }
}

class LibSQLDatabase extends BaseSQLiteDatabase {
  static [entityKind] = "LibSQLDatabase";
  async batch(batch2) {
    return await this.session.batch(batch2);
  }
}

// node_modules/@libsql/h
var exports_schema = {};
__export(exports_schema, {
  userRelations: () => {
    {
      return userRelations;
    }
  },
  user: () => {
    {
      return user;
    }
  },
  tweetsRelations: () => {
    {
      return tweetsRelations;
    }
  },
  tweets: () => {
    {
      return tweets;
    }
  },
  session: () => {
    {
      return session2;
    }
  },
  key: () => {
    {
      return key;
    }
  }
});

// node_modules/@libsql/hrana-client/lib-esm/enco
var blob = function(name2, config8) {
  if (config8?.mode === "json") {
    return new SQLiteBlobJsonBuilder(name2);
  }
  if (config8?.mode === "bigint") {
    return new SQLiteBigIntBuilder(name2);
  }
  return new SQLiteBlobBufferBuilder(name2);
};
var integer = function(name2, config8) {
  if (config8?.mode === "timestamp" || config8?.mode === "timestamp_ms") {
    return new SQLiteTimestampBuilder(name2, config8.mode);
  }
  if (config8?.mode === "boolean") {
    return new SQLiteBooleanBuilder(name2, config8.mode);
  }
  return new SQLiteIntegerBuilder(name2);
};
var text = function(name2, config8 = {}) {
  return config8.mode === "json" ? new SQLiteTextJsonBuilder(name2) : new SQLiteTextBuilder(name2, config8);
};
var index = function(name2) {
  return new IndexBuilderOn(name2, false);
};
class SQLiteBigIntBuilder extends SQLiteColumnBuilder {
  static [entityKind] = "SQLiteBigIntBuilder";
  constructor(name2) {
    super(name2, "bigint", "SQLiteBigInt");
  }
  build(table) {
    return new SQLiteBigInt(table, this.config);
  }
}

class SQLiteBigInt extends SQLiteColumn {
  static [entityKind] = "SQLiteBigInt";
  getSQLType() {
    return "blob";
  }
  mapFromDriverValue(value4) {
    return BigInt(value4.toString());
  }
  mapToDriverValue(value4) {
    return Buffer.from(value4.toString());
  }
}

class SQLiteBlobJsonBuilder extends SQLiteColumnBuilder {
  static [entityKind] = "SQLiteBlobJsonBuilder";
  constructor(name2) {
    super(name2, "json", "SQLiteBlobJson");
  }
  build(table) {
    return new SQLiteBlobJson(table, this.config);
  }
}

class SQLiteBlobJson extends SQLiteColumn {
  static [entityKind] = "SQLiteBlobJson";
  getSQLType() {
    return "blob";
  }
  mapFromDriverValue(value4) {
    return JSON.parse(value4.toString());
  }
  mapToDriverValue(value4) {
    return Buffer.from(JSON.stringify(value4));
  }
}

class SQLiteBlobBufferBuilder extends SQLiteColumnBuilder {
  static [entityKind] = "SQLiteBlobBufferBuilder";
  constructor(name2) {
    super(name2, "buffer", "SQLiteBlobBuffer");
  }
  build(table) {
    return new SQLiteBlobBuffer(table, this.config);
  }
}

class SQLiteBlobBuffer extends SQLiteColumn {
  static [entityKind] = "SQLiteBlobBuffer";
  getSQLType() {
    return "blob";
  }
}
class SQLiteBaseIntegerBuilder extends SQLiteColumnBuilder {
  static [entityKind] = "SQLiteBaseIntegerBuilder";
  constructor(name2, dataType, columnType) {
    super(name2, dataType, columnType);
    this.config.autoIncrement = false;
  }
  primaryKey(config8) {
    if (config8?.autoIncrement) {
      this.config.autoIncrement = true;
    }
    this.config.hasDefault = true;
    return super.primaryKey();
  }
}

class SQLiteBaseInteger extends SQLiteColumn {
  static [entityKind] = "SQLiteBaseInteger";
  autoIncrement = this.config.autoIncrement;
  getSQLType() {
    return "integer";
  }
}

class SQLiteIntegerBuilder extends SQLiteBaseIntegerBuilder {
  static [entityKind] = "SQLiteIntegerBuilder";
  constructor(name2) {
    super(name2, "number", "SQLiteInteger");
  }
  build(table) {
    return new SQLiteInteger(table, this.config);
  }
}

class SQLiteInteger extends SQLiteBaseInteger {
  static [entityKind] = "SQLiteInteger";
}

class SQLiteTimestampBuilder extends SQLiteBaseIntegerBuilder {
  static [entityKind] = "SQLiteTimestampBuilder";
  constructor(name2, mode) {
    super(name2, "date", "SQLiteTimestamp");
    this.config.mode = mode;
  }
  defaultNow() {
    return this.default(sql5`(cast((julianday('now') - 2440587.5)*86400000 as integer))`);
  }
  build(table) {
    return new SQLiteTimestamp(table, this.config);
  }
}

class SQLiteTimestamp extends SQLiteBaseInteger {
  static [entityKind] = "SQLiteTimestamp";
  mode = this.config.mode;
  mapFromDriverValue(value4) {
    if (this.config.mode === "timestamp") {
      return new Date(value4 * 1000);
    }
    return new Date(value4);
  }
  mapToDriverValue(value4) {
    const unix = value4.getTime();
    if (this.config.mode === "timestamp") {
      return Math.floor(unix / 1000);
    }
    return unix;
  }
}

class SQLiteBooleanBuilder extends SQLiteBaseIntegerBuilder {
  static [entityKind] = "SQLiteBooleanBuilder";
  constructor(name2, mode) {
    super(name2, "boolean", "SQLiteBoolean");
    this.config.mode = mode;
  }
  build(table) {
    return new SQLiteBoolean(table, this.config);
  }
}

class SQLiteBoolean extends SQLiteBaseInteger {
  static [entityKind] = "SQLiteBoolean";
  mode = this.config.mode;
  mapFromDriverValue(value4) {
    return Number(value4) === 1;
  }
  mapToDriverValue(value4) {
    return value4 ? 1 : 0;
  }
}
class SQLiteTextBuilder extends SQLiteColumnBuilder {
  static [entityKind] = "SQLiteTextBuilder";
  constructor(name2, config8) {
    super(name2, "string", "SQLiteText");
    this.config.enumValues = config8.enum;
    this.config.length = config8.length;
  }
  build(table) {
    return new SQLiteText(table, this.config);
  }
}

class SQLiteText extends SQLiteColumn {
  static [entityKind] = "SQLiteText";
  enumValues = this.config.enumValues;
  length = this.config.length;
  constructor(table, config8) {
    super(table, config8);
  }
  getSQLType() {
    return `text${this.config.length ? `(${this.config.length})` : ""}`;
  }
}

class SQLiteTextJsonBuilder extends SQLiteColumnBuilder {
  static [entityKind] = "SQLiteTextJsonBuilder";
  constructor(name2) {
    super(name2, "json", "SQLiteTextJson");
  }
  build(table) {
    return new SQLiteTextJson(table, this.config);
  }
}

class SQLiteTextJson extends SQLiteColumn {
  static [entityKind] = "SQLiteTextJson";
  getSQLType() {
    return "text";
  }
  mapFromDriverValue(value4) {
    return JSON.parse(value4);
  }
  mapToDriverValue(value4) {
    return JSON.stringify(value4);
  }
}
class IndexBuilderOn {
  name;
  unique;
  static [entityKind] = "SQLiteIndexBuilderOn";
  constructor(name2, unique2) {
    this.name = name2;
    this.unique = unique2;
  }
  on(...columns) {
    return new IndexBuilder(this.name, columns, this.unique);
  }
}

class IndexBuilder {
  static [entityKind] = "SQLiteIndexBuilder";
  config;
  constructor(name2, columns, unique2) {
    this.config = {
      name: name2,
      columns,
      unique: unique2,
      where: undefined
    };
  }
  where(condition) {
    this.config.where = condition;
    return this;
  }
  build(table) {
    return new Index(this.config, table);
  }
}

class Index {
  static [entityKind] = "SQLiteIndex";
  config;
  constructor(config8, table) {
    this.config = { ...config8, table };
  }
}

// node_modules/@libsql/
var user = sqliteTable("user", {
  id: text("id").primaryKey(),
  handle: text("handle").notNull()
});
var session2 = sqliteTable("user_session", {
  id: text("id").primaryKey(),
  userId: text("user_id").notNull().references(() => user.id),
  activeExpires: blob("active_expires", {
    mode: "bigint"
  }).notNull(),
  idleExpires: blob("idle_expires", {
    mode: "bigint"
  }).notNull()
});
var key = sqliteTable("user_key", {
  id: text("id").primaryKey(),
  userId: text("user_id").notNull().references(() => user.id),
  hashedPassword: text("hashed_password")
});

// node_modules/@libsql/hrana-client/lib-
var typebox2 = __toESM(require_typebox(), 1);

// node_modules/@libsql/hrana-client/lib-esm/
var uniqueKeyName3 = function(table, columns) {
  return `${table[MySqlTable.Symbol.Name]}_${columns.join("_")}_unique`;
};
var InlineForeignKeys3 = Symbol.for("drizzle:MySqlInlineForeignKeys");

class MySqlTable extends Table {
  static [entityKind] = "MySqlTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys: InlineForeignKeys3
  });
  [Table.Symbol.Columns];
  [InlineForeignKeys3] = [];
  [Table.Symbol.ExtraConfigBuilder] = undefined;
}
class MySqlColumn extends Column {
  table;
  static [entityKind] = "MySqlColumn";
  constructor(table, config8) {
    if (!config8.uniqueName) {
      config8.uniqueName = uniqueKeyName3(table, [config8.name]);
    }
    super(table, config8);
    this.table = table;
  }
}
class MySqlColumnWithAutoIncrement extends MySqlColumn {
  static [entityKind] = "MySqlColumnWithAutoIncrement";
  autoIncrement = this.config.autoIncrement;
}

class MySqlDelete extends QueryPromise {
  table;
  session;
  dialect;
  static [entityKind] = "MySqlDelete";
  config;
  constructor(table, session3, dialect) {
    super();
    this.table = table;
    this.session = session3;
    this.dialect = dialect;
    this.config = { table };
  }
  where(where) {
    this.config.where = where;
    return this;
  }
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  prepare() {
    return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning);
  }
  execute = (placeholderValues) => {
    return this.prepare().execute(placeholderValues);
  };
  createIterator = () => {
    const self2 = this;
    return async function* (placeholderValues) {
      yield* self2.prepare().iterator(placeholderValues);
    };
  };
  iterator = this.createIterator();
}
class MySqlInsert extends QueryPromise {
  session;
  dialect;
  static [entityKind] = "MySqlInsert";
  config;
  constructor(table, values, ignore, session3, dialect) {
    super();
    this.session = session3;
    this.dialect = dialect;
    this.config = { table, values, ignore };
  }
  onDuplicateKeyUpdate(config8) {
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config8.set));
    this.config.onConflict = sql5`update ${setSql}`;
    return this;
  }
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  prepare() {
    return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), undefined);
  }
  execute = (placeholderValues) => {
    return this.prepare().execute(placeholderValues);
  };
  createIterator = () => {
    const self2 = this;
    return async function* (placeholderValues) {
      yield* self2.prepare().iterator(placeholderValues);
    };
  };
  iterator = this.createIterator();
}
class MySqlSelectQueryBuilder extends TypedQueryBuilder {
  static [entityKind] = "MySqlSelectQueryBuilder";
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  constructor({ table, fields, isPartialSelect, session: session3, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table,
      fields: { ...fields },
      distinct
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session3;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields
    };
    this.tableName = getTableLikeName(table);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  createJoin(joinType) {
    return (table, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table);
      if (typeof tableName === "string" && this.config.joins?.some((join2) => join2.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table, SQL)) {
          const selection = is(table, Subquery) ? table[SubqueryConfig].selection : is(table, View) ? table[ViewBaseConfig].selectedFields : table[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key2]) => [key2, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key2]) => [key2, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  where(where) {
    if (typeof where === "function") {
      where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.where = where;
    return this;
  }
  having(having) {
    if (typeof having === "function") {
      having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns) {
    if (typeof columns[0] === "function") {
      const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns;
    }
    return this;
  }
  orderBy(...columns) {
    if (typeof columns[0] === "function") {
      const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.orderBy = Array.isArray(orderBy) ? orderBy : [orderBy];
    } else {
      this.config.orderBy = columns;
    }
    return this;
  }
  limit(limit) {
    this.config.limit = limit;
    return this;
  }
  offset(offset) {
    this.config.offset = offset;
    return this;
  }
  for(strength, config8 = {}) {
    this.config.lockingClause = { strength, config: config8 };
    return this;
  }
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  as(alias) {
    return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias), new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
}

class MySqlSelect extends MySqlSelectQueryBuilder {
  static [entityKind] = "MySqlSelect";
  prepare() {
    if (!this.session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    const fieldsList = orderSelectedFields(this.config.fields);
    const query = this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), fieldsList);
    query.joinsNotNullableMap = this.joinsNotNullableMap;
    return query;
  }
  execute = (placeholderValues) => {
    return this.prepare().execute(placeholderValues);
  };
  createIterator = () => {
    const self2 = this;
    return async function* (placeholderValues) {
      yield* self2.prepare().iterator(placeholderValues);
    };
  };
  iterator = this.createIterator();
}
applyMixins(MySqlSelect, [QueryPromise]);
class MySqlUpdate extends QueryPromise {
  session;
  dialect;
  static [entityKind] = "MySqlUpdate";
  config;
  constructor(table, set, session3, dialect) {
    super();
    this.session = session3;
    this.dialect = dialect;
    this.config = { set, table };
  }
  where(where) {
    this.config.where = where;
    return this;
  }
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
    return rest;
  }
  prepare() {
    return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning);
  }
  execute = (placeholderValues) => {
    return this.prepare().execute(placeholderValues);
  };
  createIterator = () => {
    const self2 = this;
    return async function* (placeholderValues) {
      yield* self2.prepare().iterator(placeholderValues);
    };
  };
  iterator = this.createIterator();
}
var MySqlViewConfig = Symbol.for("drizzle:MySqlViewConfig");

// node_modules/@libsql/hrana-client/lib-esm/enc
class MySqlBinary extends MySqlColumn {
  static [entityKind] = "MySqlBinary";
  length = this.config.length;
  getSQLType() {
    return this.length === undefined ? `binary` : `binary(${this.length})`;
  }
}
class MySqlChar extends MySqlColumn {
  static [entityKind] = "MySqlChar";
  length = this.config.length;
  enumValues = this.config.enum;
  getSQLType() {
    return this.length === undefined ? `char` : `char(${this.length})`;
  }
}
class MySqlDecimal extends MySqlColumnWithAutoIncrement {
  static [entityKind] = "MySqlDecimal";
  precision = this.config.precision;
  scale = this.config.scale;
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `decimal(${this.precision},${this.scale})`;
    } else if (this.precision === undefined) {
      return "decimal";
    } else {
      return `decimal(${this.precision})`;
    }
  }
}
class MySqlDouble extends MySqlColumnWithAutoIncrement {
  static [entityKind] = "MySqlDouble";
  precision = this.config.precision;
  scale = this.config.scale;
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `double(${this.precision},${this.scale})`;
    } else if (this.precision === undefined) {
      return "double";
    } else {
      return `double(${this.precision})`;
    }
  }
}
class MySqlEnumColumn extends MySqlColumn {
  static [entityKind] = "MySqlEnumColumn";
  enumValues = this.config.enumValues;
  getSQLType() {
    return `enum(${this.enumValues.map((value4) => `'${value4}'`).join(",")})`;
  }
}
class MySqlReal extends MySqlColumnWithAutoIncrement {
  static [entityKind] = "MySqlReal";
  precision = this.config.precision;
  scale = this.config.scale;
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `real(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "real";
    } else {
      return `real(${this.precision})`;
    }
  }
}
class MySqlText extends MySqlColumn {
  static [entityKind] = "MySqlText";
  textType = this.config.textType;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.textType;
  }
}
class MySqlTime extends MySqlColumn {
  static [entityKind] = "MySqlTime";
  fsp = this.config.fsp;
  getSQLType() {
    const precision = this.fsp === undefined ? "" : `(${this.fsp})`;
    return `time${precision}`;
  }
}
class MySqlDateBaseColumn extends MySqlColumn {
  static [entityKind] = "MySqlDateColumn";
  hasOnUpdateNow = this.config.hasOnUpdateNow;
}
class MySqlTimestamp extends MySqlDateBaseColumn {
  static [entityKind] = "MySqlTimestamp";
  fsp = this.config.fsp;
  getSQLType() {
    const precision = this.fsp === undefined ? "" : `(${this.fsp})`;
    return `timestamp${precision}`;
  }
  mapFromDriverValue(value4) {
    return new Date(value4 + "+0000");
  }
  mapToDriverValue(value4) {
    return value4.toISOString().slice(0, -1).replace("T", " ");
  }
}
class MySqlTimestampString extends MySqlDateBaseColumn {
  static [entityKind] = "MySqlTimestampString";
  fsp = this.config.fsp;
  getSQLType() {
    const precision = this.fsp === undefined ? "" : `(${this.fsp})`;
    return `timestamp${precision}`;
  }
}
class MySqlVarBinary extends MySqlColumn {
  static [entityKind] = "MySqlVarBinary";
  length = this.config.length;
  getSQLType() {
    return this.length === undefined ? `varbinary` : `varbinary(${this.length})`;
  }
}
class MySqlVarChar extends MySqlColumn {
  static [entityKind] = "MySqlVarChar";
  length = this.config.length;
  enumValues = this.config.enum;
  getSQLType() {
    return this.length === undefined ? `varchar` : `varchar(${this.length})`;
  }
}
// node_modules/@libsql/hrana-client/lib-esm/
class PgChar extends PgColumn {
  static [entityKind] = "PgChar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `char` : `char(${this.length})`;
  }
}
var isPgEnumSym = Symbol.for("drizzle:isPgEnum");
class PgEnumColumn extends PgColumn {
  static [entityKind] = "PgEnumColumn";
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table, config8) {
    super(table, config8);
    this.enum = config8.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}
class PgInterval extends PgColumn {
  static [entityKind] = "PgInterval";
  fields = this.config.intervalConfig.fields;
  precision = this.config.intervalConfig.precision;
  getSQLType() {
    const fields = this.fields ? ` ${this.fields}` : "";
    const precision = this.precision ? `(${this.precision})` : "";
    return `interval${fields}${precision}`;
  }
}
class PgText extends PgColumn {
  static [entityKind] = "PgText";
  enumValues = this.config.enumValues;
  getSQLType() {
    return "text";
  }
}
class PgVarchar extends PgColumn {
  static [entityKind] = "PgVarchar";
  length = this.config.length;
  enumValues = this.config.enumValues;
  getSQLType() {
    return this.length === undefined ? `varchar` : `varchar(${this.length})`;
  }
}

// node_modules/@libsql/hrana-client/lib-
var p = function(n, r2) {
  const o = getTableColumns(n), i = Object.entries(o);
  let a = Object.fromEntries(i.map(([e3, t2]) => [e3, d(t2)]));
  r2 && (a = Object.assign(a, Object.fromEntries(Object.entries(r2).map(([e3, t2]) => [e3, typeof t2 == "function" ? t2(a) : t2]))));
  for (const [t2, n2] of i)
    n2.notNull ? n2.hasDefault && (a[t2] = typebox2.Type.Optional(a[t2])) : a[t2] = typebox2.Type.Optional(u(a[t2]));
  return typebox2.Type.Object(a);
};
var y = function(n, r2) {
  const o = getTableColumns(n), i = Object.entries(o);
  let a = Object.fromEntries(i.map(([e3, t2]) => [e3, d(t2)]));
  r2 && (a = Object.assign(a, Object.fromEntries(Object.entries(r2).map(([e3, t2]) => [e3, typeof t2 == "function" ? t2(a) : t2]))));
  for (const [e3, t2] of i)
    t2.notNull || (a[e3] = u(a[e3]));
  return typebox2.Type.Object(a);
};
var d = function(t2) {
  let f;
  if (function(e3) {
    return ("enumValues" in e3) && Array.isArray(e3.enumValues) && e3.enumValues.length > 0;
  }(t2) && (f = t2.enumValues?.length ? typebox2.Type.Union(t2.enumValues.map((t3) => typebox2.Type.Literal(t3))) : typebox2.Type.String()), !f)
    if (t2.dataType === "custom")
      f = typebox2.Type.Any();
    else if (t2.dataType === "json")
      f = c;
    else if (t2.dataType === "array")
      f = typebox2.Type.Array(d(t2.baseColumn));
    else if (t2.dataType === "number")
      f = typebox2.Type.Number();
    else if (t2.dataType === "bigint")
      f = typebox2.Type.BigInt();
    else if (t2.dataType === "boolean")
      f = typebox2.Type.Boolean();
    else if (t2.dataType === "date")
      f = typebox2.Type.Date();
    else if (t2.dataType === "string") {
      const s = typebox2.Type.String();
      (is(t2, PgChar) || is(t2, PgVarchar) || is(t2, MySqlVarChar) || is(t2, MySqlVarBinary) || is(t2, MySqlChar) || is(t2, SQLiteText)) && typeof t2.length == "number" && (s.maxLength = t2.length), f = s;
    } else
      is(t2, PgUUID) && (f = typebox2.Type.RegEx(b));
  return f || (f = typebox2.Type.Any()), f;
};
var f = typebox2.Type.Union([typebox2.Type.String(), typebox2.Type.Number(), typebox2.Type.Boolean(), typebox2.Type.Null()]);
var c = typebox2.Type.Union([f, typebox2.Type.Array(typebox2.Type.Any()), typebox2.Type.Record(typebox2.Type.String(), typebox2.Type.Any())]);
var u = (t2) => typebox2.Type.Union([t2, typebox2.Type.Null()]);
var b = /^[\dA-Fa-f]{8}(?:-[\dA-Fa-f]{4}){3}-[\dA-Fa-f]{12}$/;

// node_modules/@libsql/hr
var tweets = sqliteTable("tweet", {
  id: integer("id", { mode: "number" }).primaryKey({ autoIncrement: true }),
  authorId: text("author_id").notNull(),
  content: text("content").notNull(),
  createdAt: integer("createdAt", { mode: "timestamp" }).notNull().$defaultFn(() => new Date)
}, (table) => {
  return {
    authorIdx: index("author_idx").on(table.authorId),
    createdAtIdx: index("created_at_idx").on(table.createdAt)
  };
});
var insertTweetSchema = p(tweets);
var selectTweetSchema = y(tweets);

// node_modules/@libsql/h
var userRelations = relations(user, ({ many }) => ({
  tweets: many(tweets)
}));
var tweetsRelations = relations(tweets, ({ one }) => ({
  author: one(user, {
    fields: [tweets.authorId],
    references: [user.id]
  })
}));

// node_modules/@l
var { DATABASE_CONNECTION_TYPE } = config.env;
var options = {
  local: { url: "file:local.sqlite" },
  remote: {
    url: config.env.DATABASE_URL,
    authToken: config.env.DATABASE_AUTH_TOKEN
  },
  "local-replica": {
    url: "file:local.sqlite",
    syncUrl: config.env.DATABASE_URL,
    authToken: config.env.DATABASE_AUTH_TOKEN
  }
};
var client8 = createClient(options[DATABASE_CONNECTION_TYPE]);
if (config.env.DATABASE_CONNECTION_TYPE === "local-replica") {
  await client8.sync();
}
var db = drizzle(client8, { schema: exports_schema, logger: true });

// node_modules/@lib
var envAliasMap = {
  production: "PROD",
  development: "DEV"
};
var envAlias = envAliasMap[config.env.NODE_ENV];
var elysia = () => {
  return ({ args: args2 }) => {
    const [{ request: request28, set }] = args2;
    return {
      request: request28,
      setCookie: (cookie4) => {
        const setCookieHeader = set.headers["Set-Cookie"] ?? [];
        const setCookieHeaders = Array.isArray(setCookieHeader) ? setCookieHeader : [setCookieHeader];
        setCookieHeaders.push(cookie4.serialize());
        set.headers["Set-Cookie"] = setCookieHeaders;
      }
    };
  };
};
var auth2 = lucia2({
  env: envAlias,
  middleware: elysia(),
  adapter: libsqlAdapter(client8, {
    user: "user",
    key: "user_key",
    session: "user_session"
  }),
  getUserAttributes: (data) => {
    return {
      handle: data.handle
    };
  }
});
var githubAuth = github(auth2, {
  clientId: config.env.GITHUB_CLIENT_ID,
  clientSecret: config.env.GITHUB_CLIENT_SECRET
});

// node_modules/@libsql
var loggerConfig = config.env.NODE_ENV === "development" ? {
  level: config.env.LOG_LEVEL,
  stream
} : { level: config.env.LOG_LEVEL };
var ctx = new c$({
  name: "@app/ctx"
}).decorate("db", db).decorate("config", config).decorate("auth", auth2).use(bethStack()).use(logger(loggerConfig)).use(config.env.NODE_ENV === "development" ? new HoltLogger().getLogger() : (a) => a).use(config.env.DATABASE_CONNECTION_TYPE === "local-replica" ? cron({
  name: "heartbeat",
  pattern: "*/2 * * * * *",
  run() {
    const now = performance.now();
    console.log("Syncing database...");
    client8.sync().then(() => {
      console.log(`Database synced in ${performance.now() - now}ms`);
    });
  }
}) : (a) => a).onStart(({ log: log3 }) => {
  if (log3 && config.env.NODE_ENV === "production") {
    log3.info("Server started");
  }
}).onStop(({ log: log3 }) => {
  if (log3 && config.env.NODE_ENV === "production") {
    log3.info("Server stopped");
  }
}).onRequest(({ log: log3, request: request28 }) => {
  if (log3 && config.env.NODE_ENV === "production") {
    log3.debug(`Request received: ${request28.method}: ${request28.url}`);
  }
}).onResponse(({ log: log3, request: request28, set }) => {
  if (log3 && config.env.NODE_ENV === "production") {
    log3.debug(`Response sent: ${request28.method}: ${request28.url}`);
  }
}).onError(({ log: log3, error: error6 }) => {
  if (log3 && config.env.NODE_ENV === "production") {
    log3.error(error6);
  }
});

// node_modules/@libsql/hra
class DuplicateEmailError extends Error {
  constructor() {
    super("Duplicate email");
  }
}
var authController = new c$({
  prefix: "/auth"
}).use(ctx).post("/signInOrUp", async ({ body: { handle, password, action }, auth: auth4, set }) => {
  let user2;
  if (action === "signup") {
    user2 = await auth4.createUser({
      key: {
        providerId: "basic",
        providerUserId: handle.toLowerCase(),
        password
      },
      attributes: {
        handle
      }
    }).catch((err) => {
      if (err.code === "SQLITE_CONSTRAINT") {
        throw new DuplicateEmailError;
      } else {
        throw err;
      }
    });
  } else if (action === "signin") {
    user2 = await auth4.useKey("basic", handle.toLowerCase(), password);
  } else {
    throw new Error("Invalid action");
  }
  const session3 = await auth4.createSession({
    userId: user2.userId,
    attributes: {}
  });
  const sessionCookie = auth4.createSessionCookie(session3);
  set.headers["Set-Cookie"] = sessionCookie.serialize();
  set.headers["HX-Location"] = "/";
}, {
  body: export_t.Object({
    handle: export_t.String({
      minLength: 1,
      maxLength: 20
    }),
    password: export_t.String({
      minLength: 4,
      maxLength: 255
    }),
    action: export_t.Enum({
      signup: "signup",
      signin: "signin"
    })
  }),
  error({ code, error: error6, set, log: log3 }) {
    log3.error(error6);
    let errorMessage = "";
    if (code === "VALIDATION") {
      errorMessage = "Invalid email or password";
    } else if (error6 instanceof DuplicateEmailError) {
      errorMessage = "Email already exists";
    } else if (error6 instanceof LuciaError && (error6.message === "AUTH_INVALID_KEY_ID" || error6.message === "AUTH_INVALID_PASSWORD")) {
      errorMessage = "Invalid email or password";
    } else {
      errorMessage = "Internal server error";
    }
    set.status = "Unauthorized";
    return `${errorMessage}`;
  }
}).post("/signout", async (ctx2) => {
  const authRequest = ctx2.auth.handleRequest(ctx2);
  const session3 = await authRequest.validate();
  if (!session3) {
    ctx2.set.status = "Unauthorized";
    return "You are not logged in";
  }
  await ctx2.auth.invalidateSession(session3.sessionId);
  const sessionCookie = ctx2.auth.createSessionCookie(null);
  ctx2.set.headers["Set-Cookie"] = sessionCookie.serialize();
  ctx2.set.headers["HX-Location"] = "/";
});

// node_modules/@libsql/hran
function TweetCard({
  author: { handle },
  createdAt,
  content,
  id
}) {
  return Html.createElement("div", {
    class: "rounded-lg border p-4 shadow-md",
    id: `tweet-${id}`,
    "hx-ext": "response-targets"
  }, Html.createElement("h2", {
    class: "text-xl font-bold",
    safe: true
  }, "@", handle), Html.createElement("p", {
    class: "text-gray-700",
    safe: true
  }, content), Html.createElement("div", {
    class: "flex flex-row justify-between"
  }, Html.createElement("span", {
    class: "text-sm text-gray-500"
  }, createdAt.toLocaleString()), Html.createElement("button", {
    class: "i-lucide-x text-lg text-red-500",
    "hx-delete": `/api/tweets/${id}`,
    "hx-target": `#tweet-${id}`,
    "hx-swap": "outerHTML",
    "hx-target-4xx": "next #tweetDeleteError",
    "hx-confirm": "Are you sure you want to delete this tweet?"
  })), Html.createElement("div", {
    id: "tweetDeleteError"
  }));
}
async function InitialTweetList() {
  const tweetData = await db.query.tweets.findMany({
    limit: 5,
    orderBy: (tweets3, { desc: desc2 }) => [desc2(tweets3.createdAt)],
    with: {
      author: {
        columns: {
          handle: true
        }
      }
    }
  });
  const lastTweetTime = tweetData[tweetData.length - 1]?.createdAt;
  return Html.createElement(Html.Fragment, null, Html.createElement("div", {
    class: "space-y-4",
    id: "tweetList"
  }, tweetData.map((tweet) => Html.createElement(TweetCard, {
    ...tweet
  })), Html.createElement("div", {
    "hx-get": `/api/tweets?after=${lastTweetTime?.toISOString()}`,
    "hx-swap": "beforeend",
    "hx-target": "#tweetList",
    "hx-trigger": "revealed"
  })));
}
async function AdditionalTweetList({ after }) {
  const tweetData = await db.query.tweets.findMany({
    where: (tweets3, { lt: lt2 }) => lt2(tweets3.createdAt, after),
    limit: 5,
    orderBy: (tweets3, { desc: desc2 }) => [desc2(tweets3.createdAt)],
    with: {
      author: {
        columns: {
          handle: true
        }
      }
    }
  });
  const lastTweetTime = tweetData[tweetData.length - 1]?.createdAt;
  return Html.createElement(Html.Fragment, null, tweetData.map((tweet) => Html.createElement(TweetCard, {
    ...tweet
  })), lastTweetTime && Html.createElement("div", {
    "hx-get": `/api/tweets?after=${lastTweetTime.toISOString()}`,
    "hx-swap": "beforeend",
    "hx-target": "#tweetList",
    "hx-trigger": "revealed"
  }));
}
function TweetCreationForm() {
  return Html.createElement("div", {
    class: "rounded-lg border p-4 shadow-md"
  }, Html.createElement("h2", {
    class: "mb-4 text-xl font-bold"
  }, "Create a new Tweet"), Html.createElement("form", {
    "hx-post": "/api/tweets",
    "hx-swap": "afterbegin",
    "hx-target": "#tweetList",
    _: "on submit target.reset()"
  }, Html.createElement("label", {
    class: "mb-2 block text-sm font-bold",
    for: "content"
  }, "Tweet:"), Html.createElement("input", {
    class: "w-full appearance-none rounded border px-3 py-2 leading-tight text-gray-700 shadow",
    name: "content",
    required: "true"
  }), Html.createElement("button", {
    class: "rounded bg-blue-500 px-4 py-2 font-bold text-white hover:bg-blue-700",
    type: "submit"
  }, "Post Tweet")));
}

// node_modules/@libsql/hrana
var tweetsController = new c$({
  prefix: "/tweets"
}).use(ctx).derive(async (ctx2) => {
  const authRequest = ctx2.auth.handleRequest(ctx2);
  const session3 = await authRequest.validate();
  return { session: session3 };
}).get("/", async ({ query: { after } }) => {
  const date4 = new Date(after);
  return Html.createElement(AdditionalTweetList, {
    after: date4
  });
}, {
  query: export_t.Object({
    after: export_t.String({
      format: "date-time"
    })
  })
}).post("/", async ({ session: session3, db: db5, body, set, log: log3 }) => {
  if (!session3) {
    set.status = "Unauthorized";
    set.headers["HX-Redirect"] = "/signin";
    return "Sign in to post a tweet.";
  }
  const [tweet] = await db5.insert(tweets).values({
    authorId: session3.user.userId,
    content: body.content
  }).returning();
  if (!tweet) {
    throw new Error("Failed to create tweet");
  }
  return Html.createElement(TweetCard, {
    content: tweet.content,
    createdAt: tweet.createdAt,
    author: { handle: session3.user.handle },
    id: tweet.id
  });
}, {
  body: export_t.Object({
    content: export_t.String({
      minLength: 1,
      maxLength: 280
    })
  })
}).delete("/:tweetId", async ({ session: session3, db: db5, params: { tweetId }, set, log: log3 }) => {
  if (!session3) {
    set.status = "Unauthorized";
    return Html.createElement("div", {
      id: "tweetDeleteError",
      class: "text-center text-red-500"
    }, "Unauthorized");
  }
  const [tweet] = await db5.select().from(tweets).where(eq(tweets.id, tweetId));
  log3.debug(tweet);
  if (!tweet) {
    set.status = "Not Found";
    return Html.createElement("div", {
      id: "tweetDeleteError",
      class: "text-center text-red-500"
    }, "Tweet not found");
  }
  if (tweet.authorId !== session3.user.userId) {
    set.status = "Unauthorized";
    return Html.createElement("div", {
      id: "tweetDeleteError",
      class: "text-center text-red-500"
    }, "Unauthorized");
  }
  await db5.delete(tweets).where(eq(tweets.id, tweetId));
}, {
  params: export_t.Object({
    tweetId: export_t.Numeric()
  })
});

// node_modules/@libsql
var api11 = new c$({
  prefix: "/api"
}).use(authController).use(tweetsController);
// node_modules/@libsql/hrana-client/lib-es
function liveReloadScript({
  debounceTime = 100,
  url: url3 = "ws://localhost:3001/ws"
} = {}) {
  return `
        let reloadTimeout;
        (function () {
          let socket = new WebSocket(\"${url3}\");

          socket.onopen = function(e) {
            console.log("connected")
          };


          socket.onmessage = function(event) {
            console.log("event", event.data)
            // Clear any existing reload timeout
            clearTimeout(reloadTimeout);

            // Set a new reload timeout
            reloadTimeout = setTimeout(() => {
              location.reload();
            }, ${debounceTime});  // 50ms debounce time
          };

          socket.onclose = function(event) {
            console.log("closed");
          };

          socket.onerror = function(error) {
            console.log("error: " + error.message);
          };
        })();
        `;
}

// node_modules/@libsql/hr
var safeScript = config.env.NODE_ENV === "development" ? liveReloadScript() : "";
var BaseHtml = ({ children }) => Html.createElement("html", null, Html.createElement("head", null, Html.createElement("meta", {
  charset: "UTF-8"
}), Html.createElement("meta", {
  name: "viewport",
  content: "width=device-width, initial-scale=1.0"
}), Html.createElement("title", null, "THE BETH STACK"), Html.createElement("link", {
  rel: "icon",
  type: "image/x-icon",
  href: "/public/icons/hermes.png"
}), Html.createElement("link", {
  rel: "manifest",
  href: "/public/pwa.webmanifest"
}), Html.createElement("link", {
  rel: "stylesheet",
  href: "/public/dist/unocss.css"
}), Html.createElement("script", {
  type: "module",
  src: "https://unpkg.com/htmx.org@1.9.5"
}), Html.createElement("script", {
  type: "module",
  src: "https://unpkg.com/htmx.org/dist/ext/response-targets.js"
}), Html.createElement("script", {
  type: "module",
  src: "https://unpkg.com/hyperscript.org@0.9.11"
}), Html.createElement("link", {
  rel: "stylesheet",
  href: "https://cdn.jsdelivr.net/npm/@unocss/reset/tailwind.min.css"
}), Html.createElement("script", {
  type: "module"
}, safeScript)), Html.createElement("body", {
  "hx-boost": "true",
  class: "h-screen"
}, Html.createElement("h1", {
  class: " bg-blue-500 p-5 text-center text-3xl font-bold text-white shadow-md"
}, "Create BETH App"), children, Html.createElement("footer", null, Html.createElement("a", {
  href: "https://www.flaticon.com/br/icones-gratis/hermes",
  title: "hermes \xEDcones"
}, "Hermes \xEDcones criados por Freepik - Flaticon"))));

// node_modules/@libsql/hrana-
var login = new c$().use(ctx).get("/login", async (ctx2) => {
  const authRequest = ctx2.auth.handleRequest(ctx2);
  const session3 = await authRequest.validate();
  if (session3) {
    ctx2.set.redirect = "/";
    return;
  }
  return ctx2.html(() => Html.createElement(BaseHtml, null, Html.createElement("div", {
    class: "flex h-screen w-full flex-col items-center justify-center bg-gray-200",
    "hx-ext": "response-targets"
  }, Html.createElement("div", {
    class: "p-4"
  }, Html.createElement("a", {
    href: "/",
    class: "text-indigo-600 hover:text-indigo-800 hover:underline"
  }, "Go Home")), Html.createElement("form", {
    "hx-post": "/api/auth/signInOrUp",
    "hx-swap": "innerHTML",
    "hx-target-4xx": "#errorMessage",
    class: "w-96 rounded-lg bg-white p-8 shadow-md"
  }, Html.createElement("div", {
    class: "mb-4"
  }, Html.createElement("label", {
    for: "handle",
    class: "mb-2 block text-sm font-medium text-gray-600"
  }, "Handle"), Html.createElement("input", {
    type: "text",
    name: "handle",
    id: "handle",
    placeholder: "Enter your handle",
    class: "w-full rounded-md border p-2 focus:border-transparent focus:outline-none focus:ring-2 focus:ring-indigo-400"
  })), Html.createElement("div", {
    class: "mb-4"
  }, Html.createElement("label", {
    for: "password",
    class: "mb-2 block text-sm font-medium text-gray-600"
  }, "Password"), Html.createElement("input", {
    type: "password",
    name: "password",
    id: "password",
    placeholder: "Enter your password",
    class: "w-full rounded-md border p-2 focus:border-transparent focus:outline-none focus:ring-2 focus:ring-indigo-400"
  })), Html.createElement("div", {
    class: "flex flex-col gap-2"
  }, Html.createElement("button", {
    type: "submit",
    name: "action",
    value: "signin",
    class: "w-full rounded-md bg-indigo-600 p-2 text-white hover:bg-indigo-500 focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-opacity-50"
  }, "Sign In"), Html.createElement("button", {
    type: "submit",
    name: "action",
    value: "signup",
    class: "w-full rounded-md bg-green-600 p-2 text-white hover:bg-green-500 focus:outline-none focus:ring-2 focus:ring-green-400 focus:ring-opacity-50"
  }, "Sign Up"), Html.createElement("a", {
    "hx-boost": "false",
    href: "/login/github",
    class: "display-block rounded-lg bg-gray-800 p-2 text-center text-white transition duration-200 hover:bg-gray-900 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-50"
  }, "Sign In with Github", Html.createElement("div", {
    class: "i-logos-github-icon inline-block text-2xl"
  }))), Html.createElement("div", {
    id: "errorMessage",
    class: "pt-4 text-red-500"
  })))));
}).get("/login/github", async ({ set }) => {
  const [url3, state] = await githubAuth.getAuthorizationUrl();
  const stateCookie = serializeCookie("github_oauth_state", state, {
    maxAge: 3600,
    secure: config.env.NODE_ENV === "production",
    httpOnly: true,
    path: "/"
  });
  set.headers["Set-Cookie"] = stateCookie;
  set.redirect = url3.toString();
}).get("/login/github/callback", async ({ request: request28, log: log3, path, query, set, auth: auth6 }) => {
  const { code, state } = query;
  const cookies = parseCookie(request28.headers.get("Cookie") ?? "");
  const storedState = cookies.github_oauth_state;
  if (!storedState || !state || storedState !== state || !code) {
    set.status = 400;
    return "Invalid state";
  }
  try {
    const { getExistingUser, githubUser, createUser } = await githubAuth.validateCallback(code);
    const getUser = async () => {
      const existingUser = await getExistingUser();
      if (existingUser)
        return existingUser;
      const user3 = await createUser({
        attributes: {
          handle: githubUser.login
        }
      });
      return user3;
    };
    const user2 = await getUser();
    const session3 = await auth6.createSession({
      userId: user2.userId,
      attributes: {}
    });
    const sessionCookie = auth6.createSessionCookie(session3);
    return new Response(null, {
      headers: {
        Location: "/",
        "Set-Cookie": sessionCookie.serialize()
      },
      status: 302
    });
  } catch (e3) {
    if (e3 instanceof OAuthRequestError) {
      set.status = 400;
      return e3.message;
    }
    set.status = 500;
    log3.error(e3);
    return "Internal server error";
  }
});

// node_modules/@libsql/
var authGroup = new c$().use(login);

// node_modules/@libsq
var index3 = new c$().use(ctx).derive(async (ctx2) => {
  const authRequest = ctx2.auth.handleRequest(ctx2);
  const session3 = await authRequest.validate();
  return { session: session3 };
}).get("/", async ({ htmlStream, session: session3, db: db5 }) => {
  return htmlStream(() => Html.createElement(BaseHtml, null, Html.createElement("div", {
    class: "flex flex-col items-center py-3"
  }, session3 ? Html.createElement(Html.Fragment, null, Html.createElement("h1", {
    class: "text-2xl font-bold text-gray-800",
    safe: true
  }, "Hi! ", session3.user.handle), Html.createElement("button", {
    "hx-post": "/api/auth/signout",
    class: "mt-4 rounded-lg bg-blue-500 px-4 py-2 text-white transition duration-200 hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-50"
  }, "Sign Out"), Html.createElement(TweetCreationForm, null)) : Html.createElement("a", {
    href: "/login",
    "hx-boost": "false",
    class: "mt-4 rounded-lg bg-blue-500 px-4 py-2 text-white transition duration-200 hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-50"
  }, "Sign In"), Html.createElement(InitialTweetList, null))));
});

// node_modules/@
var pages = new c$().use(index3).use(authGroup);

// node_module
var app = new c$().use(staticPlugin()).use(api11).use(pages).onStart(({ log: log3 }) => {
  if (config.env.NODE_ENV === "development") {
    fetch("http://localhost:3001/restart");
    console.log("\uD83E\uDD8A Triggering Live Reload");
  }
}).onError(({ code, error: error6, request: request28, log: log3 }) => {
  console.error(error6);
}).listen(3000);
console.log(`app is listening on http://${app.server?.hostname}:${app.server?.port}`);
